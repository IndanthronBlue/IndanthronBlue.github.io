<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>体系结构｜流水线</title>
    <link href="/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%B5%81%E6%B0%B4%E7%BA%BF/"/>
    <url>/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="流水线概述"><a class="markdownIt-Anchor" href="#流水线概述"></a> 流水线概述</h1><h2 id="mips流水线"><a class="markdownIt-Anchor" href="#mips流水线"></a> MIPS流水线</h2><ul><li>五个阶段，每个阶段一个步骤<ul><li>取指令(IF)<br />从指令存储器中取指令</li><li>译码(ID)<br />译码并读寄存器堆</li><li>执行(EX)<br />执行运算或计算地址</li><li>访存(MEM)<br />访问存储器</li><li>写回(WB)<br />将结果写回寄存器堆</li></ul></li></ul><blockquote><p>最长的执行阶段决定时钟周期时间</p></blockquote><h1 id="流水线数据通路及其控制"><a class="markdownIt-Anchor" href="#流水线数据通路及其控制"></a> 流水线数据通路及其控制</h1><h2 id="正确的流水线数据通路"><a class="markdownIt-Anchor" href="#正确的流水线数据通路"></a> 正确的流水线数据通路</h2><blockquote><p>指令的信息随着指令的执行在流水线寄存器中保存</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210621193858610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><ul><li>指令信息存储于各级流水线寄存器，在写回时调⽤，避免出错</li></ul><h2 id="流水线控制"><a class="markdownIt-Anchor" href="#流水线控制"></a> 流水线控制</h2><ul><li>所有控制信号可以在译码阶段（ID）生成<ul><li>控制信号沿着<strong>流水线状态寄存器</strong>传递</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20210621194056623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><h1 id="流水线冒险"><a class="markdownIt-Anchor" href="#流水线冒险"></a> 流水线冒险</h1><ul><li>流水线冒险：现流水线在下一个时钟周期不能执行下一条指令的情况</li></ul><h2 id="结构冒险structural-hazard"><a class="markdownIt-Anchor" href="#结构冒险structural-hazard"></a> 结构冒险(Structural Hazard)</h2><ul><li>缺乏硬件导致的冒险</li><li>MIPS流水线中的存储器使用冲突<ul><li>取指令需要访问寄存器</li><li>数据传输指令lw和sw需要访问存储器</li></ul></li><li>寄存器的访问冲突<ul><li>在同一个时钟周期内需要写和读寄存器</li></ul></li></ul><h3 id="解决结构冒险"><a class="markdownIt-Anchor" href="#解决结构冒险"></a> 解决结构冒险</h3><ul><li>对指令和数据采用分开的L1缓存<ul><li>Icache和Dcache</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20210621194534615.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><ul><li>时钟的前半部分进行写，后半部分进行读<ul><li>上升沿触发寄存器读 下降沿触发寄存器写</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20210621194618358.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><h2 id="数据冒险data-hazard"><a class="markdownIt-Anchor" href="#数据冒险data-hazard"></a> 数据冒险(Data Hazard)</h2><ul><li>无法提供指令执行所需要的数据，即需要等待前面的某些指令执行完数据的读写</li><li>寄存器导致的数据冒险<ul><li>一条指令的操作数来自于前面的某条指令</li></ul></li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs asm">add $s0,$t0,$t1<br>sub $t2,$s0,$t3 #第二条指令需要的s0寄存器需要等待前面的指令写回<br></code></pre></td></tr></table></figure><ul><li>取数-使用型数据冒险<ul><li>在数据需要使用时，数据还没有从存储器读出</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">lw  $s0,20($t1)<br>sub $t2,$s0,$t3 #第二条指令需要的s0寄存器需要等待lw指令从存储器中取出数据<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210621194833154.png" alt="" /></p><h3 id="检测数据冒险"><a class="markdownIt-Anchor" href="#检测数据冒险"></a> 检测数据冒险</h3><ul><li><p>设<code>[流水线阶段].Reg[Rs/Rd/Rt]</code>表示某流水线阶段需要的源/目的寄存器</p></li><li><p>当满足下列条件时会出现数据冒险</p><ul><li><code>EX/MEM.RegRd=ID/EX.RegRs</code></li><li><code>EX/MEM.RegRd=ID/EX.RegRt</code></li><li><code>MEM/WB.RegRd=ID/EX.RegRs</code></li><li><code>MEM/WB.RegRd=ID/EX.RegRt</code></li></ul></li><li><p>只有需要写回寄存器的指令才需要旁路</p><ul><li>即在MEM或WB阶段需要写入寄存器</li></ul></li><li><p>目的寄存器不能是$0</p><ul><li><code>EX/MEM.RegRd!=0</code></li><li><code>MEM/WB.RegRd!=0</code></li></ul></li><li><p>例如</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">add $s0,$t0,$t1<br>sub $t2,$s0,$t3<br></code></pre></td></tr></table></figure><ul><li>第一条指令的<code>MEM.RegRd</code>=第二条指令的<code>ID.RegRs</code>所以会发生数据冒险</li></ul><h3 id="解决数据冒险"><a class="markdownIt-Anchor" href="#解决数据冒险"></a> 解决数据冒险</h3><h4 id="旁路寄存器导致的数据冒险"><a class="markdownIt-Anchor" href="#旁路寄存器导致的数据冒险"></a> 旁路（寄存器导致的数据冒险）</h4><blockquote><p>前推：在EX级产生结果之后马上发送给下一条指令。</p></blockquote><ul><li>旁路：建立额外的数据通路连接ALU的输出到输入</li><li>不需要等待结果写回到寄存器</li><li>例如  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">add $s0,$t0,$t1<br>sub $t2,$s0,$t3<br></code></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/20210621201019781.png" alt="" /></li><li>可以建立一条额外的数据通路 直接将第一条的ALU输出结果连接到第二条的ALU输入就不用再等待上一条指令的访存和写回阶段</li></ul><p><img src="https://img-blog.csdnimg.cn/20210621201242784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><h5 id="旁路的数据通路"><a class="markdownIt-Anchor" href="#旁路的数据通路"></a> 旁路的数据通路</h5><p><img src="https://img-blog.csdnimg.cn/20210621201320123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><h5 id="旁路多选器的控制信号"><a class="markdownIt-Anchor" href="#旁路多选器的控制信号"></a> 旁路多选器的控制信号</h5><table><thead><tr><th style="text-align:left">Mux control</th><th style="text-align:left">Source</th><th style="text-align:left">Explanation</th></tr></thead><tbody><tr><td style="text-align:left"><code>ForwardA=00</code></td><td style="text-align:left">ID/EX</td><td style="text-align:left">第一个ALU来自寄存器堆</td></tr><tr><td style="text-align:left"><code>ForwardA=10</code></td><td style="text-align:left">EX/MEM</td><td style="text-align:left">第一个ALU操作数由上一个ALU运算结果旁路获得</td></tr><tr><td style="text-align:left"><code>ForwardA=01</code></td><td style="text-align:left">MEM/WB</td><td style="text-align:left">第一个ALU操作数从数据存储器或者往前数第二条指令的ALU结果中旁路获得</td></tr><tr><td style="text-align:left"><code>ForwardB=00</code></td><td style="text-align:left">ID/EX</td><td style="text-align:left">第二个ALU操作数来自寄存器堆</td></tr><tr><td style="text-align:left"><code>ForwardB=10</code></td><td style="text-align:left">EX/MEM</td><td style="text-align:left">第二个ALU操作数由上一个ALU运算结果旁路获得</td></tr><tr><td style="text-align:left"><code>ForwardB=01</code></td><td style="text-align:left">MEM/WB</td><td style="text-align:left">第二个ALU操作数由数据存储器或者往前数第二条指令的ALU结果旁路获得</td></tr></tbody></table><h5 id="旁路条件"><a class="markdownIt-Anchor" href="#旁路条件"></a> 旁路条件</h5><ul><li><p>EX冒险<br /><img src="https://img-blog.csdnimg.cn/20210621204301843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><ul><li>if(EX/MEM.RegWrite and (EX/MEM.RegRd!=0) and(EX/MEM.RegRd=ID/EX.RegRs)) <code>ForwardA=10</code></li><li>if(EX/MEM.RegWrite and (EX/MEM.RegRd!=0) and (EX/MEM.RegRd=ID/EX.RegRt)) <code>ForwardB=10</code></li></ul></li><li><p>MEM冒险<br /><img src="https://img-blog.csdnimg.cn/20210621204325298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><ul><li>if(MEM/WB.RegWrite and (MEM/WB.RegRd!=0) and (MEM/WB.RegRd=ID/EX.RegRs)) <code>ForwardA=01</code></li><li>if(MEM/WB.RegWrite and (MEM/WB.RegRd!=0) and (MEM/WB.RegRd=ID/EX.RegRt)) <code>ForwardB=01</code></li></ul></li><li><p>这种生成的旁路信号无法解决潜在数据冒险</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asm">add $1,$1,$2<br>add $1,$1,$3<br>add $1,$1,$4<br>#在这种情况下对于二三条指令EX/MEM.RegRd=ID/EX.RegRs会发生MEM冒险<br>#对于第一三条指令有MEM/WB.RegRd=ID/EX.RegRs<br>#所以会同时发生EX级和MEM级的数据冒险<br>#而EX级的数据是更新的(即第二条指令的结果)<br>#所以只需要使用第二第三条指令之间的EX旁路<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210621202202365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><ul><li>所以我们要修改旁路信号生成条件(生成MEM级旁路信号时判断是否有EX级信号)</li></ul><h4 id="阻塞取数-使用-冒险"><a class="markdownIt-Anchor" href="#阻塞取数-使用-冒险"></a> 阻塞（取数-使用 冒险）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">lw  $s0,20($t1)<br>sub $t2,$s0,$t3<br></code></pre></td></tr></table></figure><ul><li>对于第二种数据冒险(取数-使用型)无法使用旁路来解决，因为数据只有在MEM阶段后才能获得</li><li>可以<code>阻塞掉一个时钟周期，再通过旁路就能从MEM阶段将数据传输到下一个指令的EX阶段</code></li><li>插入空指令nop阻塞掉一个时钟周期</li></ul><blockquote><p>空指令（nop）：一种不进行任何操作或不改变任何状态的指令</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210621204801870.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><ul><li>第二种数据冒险要在译码(ID)阶段检测</li><li>取数使用型冒险发生条件：if(ID/EX.MemRead and ((ID/EX.RegRd=IF/ID.RegRd) or (ID/EX.RegRd=IF/ID.RegRt)))</li><li>如果有取数-使用型冒险，则阻塞流水线一个时钟周期</li><li>实现nop指令<ul><li>将ID/EX寄存器中的控制信号置为0<ul><li>EX MEM WB阶段不进行操作</li></ul></li><li>阻止PC和IF/ID寄存器更新<ul><li>重复译码当前指令</li><li>重复提取下一条指令</li></ul></li></ul></li><li>阻塞一个时钟周期可以让取数操作取得数据，接下来可以旁路到EX级</li><li>冒险检测的数据通路：</li></ul><p><img src="https://img-blog.csdnimg.cn/20210621205111272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><ul><li>通过编译器优化来避免取数-使用型数据冒险<ul><li>例如：</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">A=B+E;<br>C=B+F;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210621205155463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><h2 id="控制冒险control-hazard"><a class="markdownIt-Anchor" href="#控制冒险control-hazard"></a> 控制冒险(Control Hazard)</h2><ul><li>分支冒险，指令执行不是顺序的，即下一条指令的地址依赖于正在执行的指令<ul><li>无条件分支(j,jal,jr)</li><li>条件分支(beq,bne)</li><li>异常</li></ul></li><li>解决方案<ul><li>阻塞</li><li>提前产生分支结果</li><li>延迟分支决策</li><li>分支预测</li></ul></li></ul><h3 id="解决控制冒险"><a class="markdownIt-Anchor" href="#解决控制冒险"></a> 解决控制冒险</h3><h4 id="跳转"><a class="markdownIt-Anchor" href="#跳转"></a> 跳转</h4><ul><li>首先假定分支不会发生(正常PC+4)</li><li>在跳转指令完成ID阶段得到跳转地址后清除流水线（此时下一条指令已经取值）</li></ul><blockquote><p>清除（flush）：因发生了意外而丢弃流水线中的指令</p></blockquote><ul><li>用<code>IF.Flush</code>将IF/ID流水线寄存器中的指令置为空指令</li><li>跳转指令设置PC,将分支目标地址加入到流水线寄存器</li></ul><p><img src="https://img-blog.csdnimg.cn/2021062121010087.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><h4 id="提前计算分支结果"><a class="markdownIt-Anchor" href="#提前计算分支结果"></a> 提前计算分支结果</h4><ul><li>分支结果在MEM级获得，若等待分支结果（flush），影响性能</li><li>计算分支地址<ul><li>将生成分支结果的硬件从EX级移到ID级（加法器、符号扩展）</li></ul></li><li>判断分支条件<ul><li>在ID级决定是否将数据旁路到相等检测单元进行检测</li><li>如果有分支按照无条件跳转处理</li><li>提前算分支可能会发生数据冒险,这时候需要阻塞流水线<ul><li>普通的寄存器冒险:阻塞一次</li><li>取数-使用型:阻塞两次</li></ul></li></ul></li><li>分支旁路<ul><li>EX冒险<ul><li>if(IDcontrol.Branch and(EX/MEM.RegRd!=0) and (EX/MEM.RegRd==IF/ID.RegRs) <code>ForwardC=10</code></li></ul></li><li>if(IDcontrol.Branch and(EX/MEM.RegRd!=0) and (EX/MEM.RegRd==IF/ID.RegRt) <code>ForwardD=10</code></li><li>MEM冒险<ul><li>if(IDcontrol.Branch and(MEM/WB.RegRd!=0) and (MEM/WB.RegRd==IF/ID.RegRs) <code>ForwardC=01</code></li><li>if(IDcontrol.Branch and(MEM/WB.RegRd!=0) and (MEM/WB.RegRd==IF/ID.RegRt) <code>ForwardD=01</code></li></ul></li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20210621212433494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><h4 id="编译器优化延迟分支"><a class="markdownIt-Anchor" href="#编译器优化延迟分支"></a> 编译器优化：延迟分支</h4><blockquote><p>延迟分支：MIPS编译器将一条指令移到分支指令之后可以延迟分支目的指令的执行从而隐藏分支延迟</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210621212631379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><ul><li>方案A最佳，分支发生概率大时选择方案B，分支不发生概率大时选C</li></ul><h4 id="动态分支预测"><a class="markdownIt-Anchor" href="#动态分支预测"></a> 动态分支预测</h4><ul><li><p>流水线级数增加，预测错误的代价增加</p></li><li><p>静态分支预测是粗略的预测方法</p></li><li><p>动态分支预测</p><ul><li>分支预测缓存或分支历史记录表</li><li>分支指令的地址低位索引</li><li>存储分支结果</li></ul></li><li><p>执行分支</p><ul><li>查表，如果预测的结果与上一次结果一样，按照预测结果取指令</li><li>如果错误，清空流水线，重新执行，并取反预测结果</li></ul></li><li><p>1位预测器<br /><img src="https://img-blog.csdnimg.cn/20210621213934322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><ul><li>内层循环至少两次预测错误<ul><li>最后一次预测出错</li><li>第一次预测出错</li></ul></li><li>每次错误都取反预测结果</li></ul></li><li><p>2位预测器<br /><img src="https://img-blog.csdnimg.cn/20210621214039756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><ul><li>错误两次再取反</li></ul></li><li><p>计算分支目标地址</p><ul><li>结合分支预测器，计算分支目标地址</li><li>分支目标缓存<ul><li>缓存分支目标地址</li><li>取指令时，由PC中的地址索引<ul><li>如果预测正确，且分支指令发生，则直接从缓存中提取目标地址</li></ul></li></ul></li></ul></li></ul><h1 id="异常"><a class="markdownIt-Anchor" href="#异常"></a> 异常</h1><blockquote><p>异常指打断程序正常执行的突发事件，会改变指令执行顺序</p></blockquote><ul><li>异常exceptions）<ul><li>产生原因可能来自处理器内部或者外部</li><li>例如，使用未定义的指令，算术溢出，系统调用</li><li>与程序执行同步，必须停止随后的指令在流水线中运行</li></ul></li><li>中断（Interrupt）<ul><li>由处理器外部引起的事件</li><li>例如I/O设备请求</li><li>与程序执行不同步，可以等流水线中指令执行结束再处理</li></ul></li><li>处理异常和中断会牺牲系统性能</li></ul><h2 id="流水线中的异常"><a class="markdownIt-Anchor" href="#流水线中的异常"></a> 流水线中的异常</h2><p><img src="https://img-blog.csdnimg.cn/20210621214810893.png" alt="" /></p><table><thead><tr><th>异常</th><th>流水级</th><th>是否同步</th></tr></thead><tbody><tr><td>算数溢出</td><td>EX</td><td>是</td></tr><tr><td>未定义指令</td><td>ID</td><td>是</td></tr><tr><td>TLB或页缺失</td><td>IF MEM</td><td>是</td></tr><tr><td>I/O请求</td><td>全部</td><td>否</td></tr><tr><td>硬件故障</td><td>全部</td><td>否</td></tr></tbody></table><ul><li>多种异常可能同步发生</li></ul><h2 id="流水线中的异常处理"><a class="markdownIt-Anchor" href="#流水线中的异常处理"></a> 流水线中的异常处理</h2><ul><li>另一种形式的控制冒险</li><li>在EX级加法出现算术溢出<ul><li>add $1, $2, $1</li><li>停止运行add指令</li><li>add之前的指令可以正常运行</li><li>清空add及其之后的指令</li><li>设置EPC（异常程序计数器）和cause（状态寄存器）的值</li><li>将控制权交给处理程序</li></ul></li><li>与处理分支预测错误相似</li><li>数据通路与控制</li></ul><p><img src="https://img-blog.csdnimg.cn/20210621215133177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><h1 id="指令级并行ilp"><a class="markdownIt-Anchor" href="#指令级并行ilp"></a> 指令级并行（ILP）</h1><h2 id="依赖"><a class="markdownIt-Anchor" href="#依赖"></a> 依赖</h2><ul><li>结构冒险——资源冲突</li><li>数据冒险——数据依赖</li><li>控制冒险——过程依赖</li><li>通过软硬件结合的方式来缓解依赖带来的影响</li></ul><h3 id="数据冒险"><a class="markdownIt-Anchor" href="#数据冒险"></a> 数据冒险</h3><p><img src="https://img-blog.csdnimg.cn/20210621215601165.png" alt="" /></p><ul><li>RAW<br />写后读(真相关)<br />当前指令使用的时前面指令更新的数据，必须保持执行顺序</li><li>WAR<br />读后写(反相关)<br />当前指令需要更新数据，前面指令使用的时原来的数据，必须保持指令的执行顺序</li><li>WAW<br />写后写(输出相关)<br />两条指令会相继更新数据，必须保持指令执行顺序</li></ul><h3 id="解决存储冲突"><a class="markdownIt-Anchor" href="#解决存储冲突"></a> 解决存储冲突</h3><blockquote><p>寄存器重命名（Register Renaming）<br />处理器重新命名指令中的寄存器标识符</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210621215723209.png" alt="" /></p><ul><li>硬件通过从空闲寄存器池中分配一个寄存器进行重命名</li><li>数据使用之后将寄存器释放回空闲寄存器池</li></ul><h2 id="静态多发射"><a class="markdownIt-Anchor" href="#静态多发射"></a> 静态多发射</h2><ul><li>编译器封装多条指令处理冒险<ul><li>将可以在同一时钟周期执行的指令封装成发射包</li><li>由流水线的资源数量所决定</li></ul></li><li>一条执行多个操作的长指令<ul><li>指定多个并发操作</li><li>超长指令字(VLIW)</li></ul></li><li>编译器处理数据冒险和控制冒险<ul><li>调度代码、封装发射包</li><li>发射包内指令间不能存在依赖</li><li>发射包间可以存在指令间依赖</li><li>如果需要可以封装nop操作</li></ul></li><li>相关技术<ul><li>双发射中的冒险<ul><li>EX级发射数据冒险</li><li>取数使用型数据冒险</li></ul></li><li>需要编译技术<ul><li>指令调度</li><li>循环展开</li></ul></li></ul></li></ul><h2 id="动态多发射"><a class="markdownIt-Anchor" href="#动态多发射"></a> 动态多发射</h2><blockquote><p>超标量（Superscalar）<br />硬件在运行时动态决定哪些指令同时发射和执行</p></blockquote><ul><li>超标量处理器运行机制<ul><li>取指令和发射：取指令、译码并发射到功能单元，等待执行</li><li>指令执行：一旦所需要的功能单元、源操作数就绪，就可以执行指令</li><li>提交：当可以写回数据时进行写回</li></ul></li><li>按序&amp;乱序<br /><img src="https://img-blog.csdnimg.cn/20210621220105655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></li></ul>]]></content>
    
    
    <categories>
      
      <category>体系结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>体系结构</tag>
      
      <tag>MIPS</tag>
      
      <tag>流水线</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用二叉树构造范式</title>
    <link href="/%E6%97%A5%E5%B8%B8/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9E%84%E9%80%A0%E8%8C%83%E5%BC%8F/"/>
    <url>/%E6%97%A5%E5%B8%B8/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9E%84%E9%80%A0%E8%8C%83%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="从逻辑表达式中提取主合取范式和主析取范式"><a class="markdownIt-Anchor" href="#从逻辑表达式中提取主合取范式和主析取范式"></a> 从逻辑表达式中提取主合取范式和主析取范式</h1><h2 id="真值表法"><a class="markdownIt-Anchor" href="#真值表法"></a> 真值表法</h2><ul><li>对于一个命题公式 A，如果它包含: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">!</mo><mo separator="true">,</mo><mo>∧</mo><mo separator="true">,</mo><mo>∨</mo><mo separator="true">,</mo><mo>→</mo><mo separator="true">,</mo><mo>↔</mo></mrow><annotation encoding="application/x-tex">!, \land, \lor, \rightarrow, \leftrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mclose">!</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∧</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∨</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span></span><span class="base"><span class="strut" style="height:0.56131em;vertical-align:-0.19444em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↔</span></span></span></span> 等逻辑关系，普遍的求范式的步骤为：<ul><li>消去 A 中的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo><mo separator="true">,</mo><mo>↔</mo></mrow><annotation encoding="application/x-tex">\rightarrow, \leftrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span><span class="base"><span class="strut" style="height:0.56131em;vertical-align:-0.19444em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↔</span></span></span></span></li><li>否定连接词 ! 内移并消除</li><li>使用分配律</li></ul></li><li>因此对于这样的命题公式 A 很难使用构造树再递归构造范式的方式，因此考虑使用真值表法获取范式<ul><li>即根据真值表的取值获取最小项和最大项，继而构造主析取范式和主合取范式</li></ul></li></ul><hr /><ul><li>算法步骤：<ul><li>获取命题公式 A，并判断其输入合法性</li><li>计算 A 中变元个数</li><li>将 A 的中缀表达式转为后缀表达式</li><li>穷举变元的取值，带入表达式中计算</li><li>根据计算值即可得到最小项和最大项</li><li>构造主析取范式和主合取范式并输出</li></ul></li></ul><blockquote><p>具体代码实现在网上有很多<br />例如<a href="https://blog.csdn.net/MangoNova/article/details/53002138?ABstrategy=codes_snippets_optimize_v3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-5.pc_relevant_default&amp;spm=1001.2101.3001.4242.4&amp;utm_relevant_index=8">C++实现求主析取范式、主合取范式</a></p></blockquote><hr /><h2 id="二叉树递归法"><a class="markdownIt-Anchor" href="#二叉树递归法"></a> 二叉树递归法</h2><blockquote><p>考虑命题公式 A 中只含有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mo separator="true">,</mo><mi mathvariant="normal">&amp;</mi></mrow><annotation encoding="application/x-tex">|, \&amp;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">&amp;</span></span></span></span> 的情况</p></blockquote><h3 id="创建二叉树"><a class="markdownIt-Anchor" href="#创建二叉树"></a> 创建二叉树</h3><ul><li>要建立一颗二叉树，首先要得到 A 的后缀表达式<ul><li>以 PPT 的命题公式 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mi mathvariant="normal">∣</mi><mi>b</mi><mo stretchy="false">)</mo><mi mathvariant="normal">&amp;</mi><mo stretchy="false">(</mo><mi>b</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">(</mo><mi>c</mi><mi mathvariant="normal">&amp;</mi><mi>d</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a|b)\&amp;(b|(c\&amp;d))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord">∣</span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mord">&amp;</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mord">∣</span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mord">&amp;</span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>为例，其后缀表达式为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>d</mi><mi mathvariant="normal">&amp;</mi><mi>b</mi><mi mathvariant="normal">∣</mi><mi>a</mi><mi>b</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">&amp;</mi></mrow><annotation encoding="application/x-tex">cd\&amp;b|ab|\&amp;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mord">&amp;</span><span class="mord mathdefault">b</span><span class="mord">∣</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord">∣</span><span class="mord">&amp;</span></span></span></span></li><li>首先读入变元 c, d，因此创建两颗单结点树并指向它们的指针压入栈中<br /><img src="1.png" alt="" /></li><li>接着读入 &amp;, 因此指向两棵树的指针被弹出，形成一棵新的树，并将指向它的指针压入栈中<br /><img src="2.png" alt="" /></li><li>然后 b 被读入，同样创建单结点树并压入栈中<br /><img src="3.png" alt="" /></li><li>接下来读入 |, 因此，弹出两棵树的指针合并形成一棵新的树，| 是它的根<br /><img src="4.png" alt="" /></li><li>然后 a, b 被读入，创建单结点树并压入栈中<br /><img src="5.png" alt="" /></li><li>接下来读入 |, 两棵树合并<br /><img src="6.png" alt="" /></li><li>最后读入 &amp;, 两棵树合并，指向最后的树的指针留在栈中<br /><img src="7.png" alt="" /></li></ul></li></ul><hr /><h3 id="根据二叉树构造合取范式"><a class="markdownIt-Anchor" href="#根据二叉树构造合取范式"></a> 根据二叉树构造合取范式</h3><ul><li>考虑合取范式的标准形式: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>A</mi><mn>0</mn></msub><mi mathvariant="normal">∣</mi><msub><mi>A</mi><mn>1</mn></msub><mi mathvariant="normal">∣</mi><msub><mi>A</mi><mn>2</mn></msub><mi mathvariant="normal">∣</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">∣</mi><msub><mi>A</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mi mathvariant="normal">&amp;</mi><mo stretchy="false">(</mo><msub><mi>B</mi><mn>0</mn></msub><mi mathvariant="normal">∣</mi><msub><mi>B</mi><mn>1</mn></msub><mi mathvariant="normal">∣</mi><msub><mi>B</mi><mn>2</mn></msub><mi mathvariant="normal">∣</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">∣</mi><msub><mi>B</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mi mathvariant="normal">&amp;</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">&amp;</mi><mo stretchy="false">(</mo><msub><mi>N</mi><mn>0</mn></msub><mi mathvariant="normal">∣</mi><msub><mi>N</mi><mn>1</mn></msub><mi mathvariant="normal">∣</mi><msub><mi>N</mi><mn>2</mn></msub><mi mathvariant="normal">∣</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">∣</mi><msub><mi>N</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">( A_0 | A_1 | A_2 | ... | A_n ) \&amp; ( B_0 | B_1 | B_2 | ... | B_n ) \&amp; ... \&amp; ( N_0 | N_1 | N_2 | ... | N_n )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">&amp;</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">&amp;</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">&amp;</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><ul><li>在合取范式构造的二叉树中，节点有如下几种情况<ul><li>| 的子节点只能是变元 N 或 | 算子</li><li>&amp; 的子节点可以是变元也可以是 &amp;, |, 变元 N</li><li>变元 N 只能做叶子结点</li></ul></li><li>因此只需要搜索 <strong>父结点为 | 的 &amp; 结点</strong> ，并作相应的变换即可得到合取范式的二叉树，仍需考虑以下两种情况<ul><li>| 的子节点之一为 &amp;</li><li>| 的子节点均为 &amp;</li></ul></li></ul></li></ul><hr /><h4 id="的子节点之一为"><a class="markdownIt-Anchor" href="#的子节点之一为"></a> | 的子节点之一为 &amp;</h4><ul><li><p>仍以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mi mathvariant="normal">∣</mi><mi>b</mi><mo stretchy="false">)</mo><mi mathvariant="normal">&amp;</mi><mo stretchy="false">(</mo><mi>b</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">(</mo><mi>c</mi><mi mathvariant="normal">&amp;</mi><mi>d</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a|b)\&amp;(b|(c\&amp;d))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord">∣</span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mord">&amp;</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mord">∣</span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mord">&amp;</span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> 为例，考虑下图中子树<br /><img src="8.png" alt="" /></p><ul><li>中序表达为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>c</mi><mi mathvariant="normal">&amp;</mi><mi>d</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">(c \&amp; d) | b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mord">&amp;</span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mord">∣</span><span class="mord mathdefault">b</span></span></span></span>，利用分配律转换为合取范式即为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>b</mi><mi mathvariant="normal">∣</mi><mi>c</mi><mo stretchy="false">)</mo><mi mathvariant="normal">&amp;</mi><mo stretchy="false">(</mo><mi>b</mi><mi mathvariant="normal">∣</mi><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(b|c) \&amp; (b|d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mord">∣</span><span class="mord mathdefault">c</span><span class="mclose">)</span><span class="mord">&amp;</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mord">∣</span><span class="mord mathdefault">d</span><span class="mclose">)</span></span></span></span>，转化为二叉树即为：<br /><img src="9.png" alt="" /></li></ul></li><li><p>由此可以得到 | 的子节点之一为 &amp; 时，二叉树的变换方法：</p><ul><li>记该 | 结点的 &amp; 左右子树为 T1, T2，非 &amp; 子树为 T3<br /><img src="10.png" alt="" /></li><li>将该子树转换为下图形式，即将(T1,T3), (T2,T3) 分别作为两个 | 结点的左右子树，再将两颗 | 子树连接到一个 &amp; 结点上<br /><img src="11.png" alt="" /></li></ul></li><li><p>因此，在构造二叉树后，利用后序遍历整颗二叉树，修正不规范的 | 结点即可。</p></li></ul><hr /><h4 id="的子节点均为"><a class="markdownIt-Anchor" href="#的子节点均为"></a> | 的子节点均为 &amp;</h4><ul><li>考虑以下情况：<br /><img src="12.png" alt="" /></li><li>可以仿照上述方法，指定左子树为 “T3”，即可得到如下二叉树：<br /><img src="13.png" alt="" /></li><li>但考虑到使用后序遍历，不会再遍历生成的 | - &amp; 子树，所以需要一步到位，构建如下子树，具体构造规则不再赘述。<br /><img src="14.png" alt="" /></li></ul><hr /><h3 id="根据二叉树构造合取范式-2"><a class="markdownIt-Anchor" href="#根据二叉树构造合取范式-2"></a> 根据二叉树构造合取范式</h3><ul><li>核心思想和构造合取范式类似，只是将 | 与 &amp; 互换，此处不再赘述。</li></ul><hr /><h3 id="构造步骤"><a class="markdownIt-Anchor" href="#构造步骤"></a> 构造步骤</h3><blockquote><p>以合取范式为例</p></blockquote><ol><li>获取合法的逻辑公式</li><li>将逻辑公式转化为后缀表达式</li><li>根据后缀表达式构造二叉树</li><li>后序遍历二叉树，将其他的二元逻辑连接词如$ \rightarrow, \leftrightarrow$按照规则转化为合取式</li><li>后序遍历二叉树，将 ! 结点按如下图方式下沉，直至其子节点为叶子结点<br /><img src="15.png" alt="" /></li><li>后序遍历二叉树，修正非法 | 结点</li><li>中序遍历二叉树，输出合取范式</li></ol><hr /><h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3><ul><li>这个方法有存储空间爆炸的风险</li><li>需要多次遍历二叉树，效率低下</li></ul>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>主范式</tag>
      
      <tag>命题逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库实验｜SQL Programming</title>
    <link href="/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/dblab2/"/>
    <url>/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/dblab2/</url>
    
    <content type="html"><![CDATA[<h1 id="一-目的"><a class="markdownIt-Anchor" href="#一-目的"></a> 一、目的</h1><ol><li>熟悉DBMS环境</li><li>掌握SQL的数据定义和数据操纵的功能</li><li>掌握数据库中的完整性约束的基本概念和使用方法</li></ol><hr /><h1 id="二-内容与设计思想"><a class="markdownIt-Anchor" href="#二-内容与设计思想"></a> 二、内容与设计思想</h1><ol><li>基于实验一插入的 University 数据，完成SQL基础查询</li><li>基于实验文件给出的数据，完成 SQL 进阶查询</li></ol><hr /><h1 id="三-使用环境"><a class="markdownIt-Anchor" href="#三-使用环境"></a> 三、使用环境</h1><ul><li>Windows 10</li><li>Navicat Premium 15</li></ul><hr /><h1 id="四-实验过程"><a class="markdownIt-Anchor" href="#四-实验过程"></a> 四、实验过程</h1><h2 id="project-1"><a class="markdownIt-Anchor" href="#project-1"></a> Project 1</h2><ul><li>在<a href="https://www.db-book.com/university-lab-dir/sample_tables-dir/index.html">教材官方网站</a>获取完整的 University 数据库<br /><img src="1.png" alt="" /></li><li>完成查询要求</li></ul><ol><li>List all information stored in the table course</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs mysql">SELECT * <br>FROM course;<br></code></pre></td></tr></table></figure><ol start="2"><li>List the dept_name and buildings of all departments;</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT dept_name, building FROM department;<br></code></pre></td></tr></table></figure><ol start="3"><li>List the instructor’s name appears in the table instructor;</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT ALL name <br>FROM instructor;<br></code></pre></td></tr></table></figure><ol start="4"><li>List the instructor‘s name whose salary is more than 90000 and dept_nameis ’Comp. Sci.’ ;</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT name<br>FROM instructor<br>WHERE salary &gt; 90000 AND dept_name = &#x27;Comp. Sci.&#x27;;<br></code></pre></td></tr></table></figure><ol start="5"><li>List the instructor’s all information after we gave a 10% raise to each instructor;</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT ID, name, dept_name, salary * 1.1<br>FROM instructor;<br></code></pre></td></tr></table></figure><ol start="6"><li>Show the different dept_name in the table instructor;</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT DISTINCT dept_name <br>FROM instructor;<br></code></pre></td></tr></table></figure><ol start="7"><li>List the course’s title ,dept_name,and credits which prerep_id is ‘130’;</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT title,dept_name,credits<br>FROM course,prereq<br>WHERE course.course_id=prereq.course_id AND prereq.prereq_id=&#x27;130&#x27;;<br></code></pre></td></tr></table></figure><ol start="8"><li>Find the titles of courses in the ‘Comp. Sci.’ department the have 3 credits;</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT title<br>FROM course<br>WHERE dept_name=&#x27;Comp. Sci.&#x27; AND credits=3;<br></code></pre></td></tr></table></figure><ol start="9"><li>List the course_id which prereq_id is ‘130’;</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT course_id<br>FROM prereq<br>WHERE prereq_id=&#x27;130&#x27;;<br></code></pre></td></tr></table></figure><ol start="10"><li>Find all courses that were taught at least three times from 2008 to 2010;</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT title<br>FROM section,course<br>WHERE year BETWEEN 2008 AND 2010 AND section.course_id=course.course_id<br>GROUP BY section.course_id<br>HAVING COUNT(section.course_id)&gt;=3;<br></code></pre></td></tr></table></figure><ol start="11"><li>Find the instructor names and the course name they taught for all instructors in Biology department who have taught some courses；</li></ol><blockquote><p>查找生物系所有教过至少一门课程的教员的教员姓名和所教的课程名；</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT name,title<br>FROM teaches NATURAL JOIN instructor JOIN course USING(course_id)<br>WHERE name IN<br>(<br>SELECT name<br>FROM teaches NATURAL JOIN instructor<br>WHERE instructor.dept_name=&#x27;Biology&#x27; <br>GROUP BY name<br>HAVING COUNT(name)&gt;1<br>);<br></code></pre></td></tr></table></figure><ol start="12"><li>List all courses taught in Fall 2009;</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT *<br>FROM course NATURAL JOIN teaches<br>WHERE semester=&#x27;FALL&#x27; AND year=2009;<br></code></pre></td></tr></table></figure><ol start="13"><li>Find the set of all courses taught either in Fall 2010 or in Spring 2009,or both.</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">(SELECT course_id, title<br>FROM section NATURAL JOIN course<br>WHERE semester=&#x27;FALL&#x27; AND year=2010)<br>UNION<br>(SELECT course_id, title<br>FROM section NATURAL JOIN course<br>WHERE semester=&#x27;Spring&#x27; AND year=2009);<br></code></pre></td></tr></table></figure><ol start="14"><li>Find all courses taught in the Fall 2009 but not in the Spring 2008;</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT *<br>FROM section<br>WHERE year=2009 AND semester=&#x27;Fall&#x27;<br>AND course_id NOT IN(<br>SELECT course_id<br>FROM section<br>WHERE year=2010 AND semester=&#x27;Spring&#x27;<br>);<br></code></pre></td></tr></table></figure><ol start="15"><li>Find the average salary of instructors in the ‘Comp. Sci.’ department;</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT AVG(salary)<br>FROM instructor<br>WHERE dept_name=&#x27;Comp. Sci.&#x27;;<br></code></pre></td></tr></table></figure><ol start="16"><li>Find the total number of instructors who teach a course in the Spring 2010 semester;</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT COUNT(DISTINCT ID)<br>FROM teaches<br>WHERE year=2010 AND semester=&#x27;Spring&#x27;;<br></code></pre></td></tr></table></figure><ol start="17"><li>Find the number of tuples in the course relation;</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT COUNT(*)<br>FROM course;<br></code></pre></td></tr></table></figure><ol start="18"><li>Find the average salary in each department;</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT dept_name,AVG(salary)<br>FROM instructor<br>GROUP BY dept_name;<br></code></pre></td></tr></table></figure><ol start="19"><li>Find the average salary of instructors in those departments where the average salary is more than 80000;</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT dept_name,AVG(salary)<br>FROM instructor<br>GROUP BY dept_name<br>HAVING AVG(salary) &gt; 80000;<br></code></pre></td></tr></table></figure><ol start="20"><li>Find the names of all instructors whose salary is greater than at least one  instructor in the ‘Comp. Sci. ‘ department.</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT name<br>FROM instructor<br>WHERE salary &gt; SOME (<br>SELECT salary<br>FROM instructor<br>WHERE dept_name=&#x27;Comp. Sci.&#x27;);<br></code></pre></td></tr></table></figure><hr /><h2 id="project-2"><a class="markdownIt-Anchor" href="#project-2"></a> Project 2</h2><ol><li>查询每一个战队的人员数量，并根据人员数降序排序，若人员数相同，按照队名字典序排序</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT team, COUNT(player_name) as num_players<br>FROM player<br>GROUP BY team<br>ORDER BY num_players DESC, team ASC;<br></code></pre></td></tr></table></figure><p><img src="2.png" alt="" /></p><ol start="2"><li>列举出每个战队的成员，成员间用逗号分隔。根据队名字典序排序</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT team, GROUP_CONCAT(player_name) as members<br>FROM player<br>GROUP BY team<br>ORDER BY team ASC;<br></code></pre></td></tr></table></figure><p><img src="3.png" alt="" /></p><ol start="3"><li>统计选手Alex使用的所有角色次数，并降序排列</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT record_role,COUNT(record_role) AS times<br>FROM record<br>WHERE record_player = &#x27;Alex&#x27;<br>GROUP BY record_role<br>ORDER BY times DESC;<br></code></pre></td></tr></table></figure><p><img src="4.png" alt="" /></p><ol start="4"><li>查看最喜欢使用角色为雕刻家的前五位选手及其使用次数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT record_player,record_role AS role,COUNT(record_player) AS times <br>FROM record <br>WHERE record_role = &#x27;雕刻家&#x27; <br>GROUP BY record_player<br>ORDER BY times DESC, record_player ASC<br>LIMIT 5;<br></code></pre></td></tr></table></figure><p><img src="5.png" alt="" /></p><ol start="5"><li>统计所有监管者的上场次数，并降序排列</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT record_role, COUNT(record_role) AS times<br>FROM record <br>WHERE identifier = 4 <br>GROUP BY record_role<br>ORDER BY times DESC;<br></code></pre></td></tr></table></figure><p><img src="6.png" alt="" /></p><ol start="6"><li>根据局均恐惧震慑数据(heals_or_terror_shocks，保留2位小数)对监管者排序，要求上场次数大于5</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT ROUND(AVG(heals_or_terror_shocks),2) AS avg, <br>   COUNT(record_player) AS total, <br>       record_player<br>FROM record <br>WHERE identifier = 4 <br>GROUP BY record_player<br>HAVING total &gt; 5<br>ORDER BY avg DESC;<br></code></pre></td></tr></table></figure><p><img src="7.png" alt="" /></p><ol start="7"><li>查看FPX.ZQ的求生者阵容(4人为一个阵容)以及出场次数，阵容以逗号分隔</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT temp.lineup_temp AS lineup,COUNT(temp.lineup_temp) AS times <br>FROM <br>(<br>SELECT DISTINCT <br>GROUP_CONCAT(r.record_player ORDER BY r.record_player ASC) AS lineup_temp, <br>r.record_half_id<br>FROM record AS r, player AS p<br>WHERE <br>r.record_player = p.player_name <br>AND p.team = &#x27;FPX.ZQ&#x27; <br>AND r.identifier &lt;&gt; 4<br>GROUP BY r.record_half_id<br>) AS temp<br>GROUP BY temp.lineup_temp;<br></code></pre></td></tr></table></figure><p><img src="8.png" alt="" /></p><ol start="8"><li>根据监管者的胜率降序排序，以百分比的形式显示</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT CONCAT(ROUND(win/total*100,0),&#x27;%&#x27;) AS ratio, record_player<br>FROM<br>(<br>SELECT record_player, COUNT(record_player) AS total<br>FROM record <br>WHERE identifier = 4 <br>GROUP BY record_player<br>) AS r1 NATURAL JOIN<br>(<br>SELECT record_player, COUNT(record_player) AS win<br>FROM record <br>WHERE identifier = 4 AND escape_or_eliminate &gt; 2 <br>GROUP BY record_player<br>) AS r2<br>ORDER BY ratio+0 DESC;<br></code></pre></td></tr></table></figure><p><img src="9.png" alt="" /></p><blockquote><p><strong>注意</strong>，此处结果与 PPT 展示不同，原因是 CONCAT 的返回值是一个 string 类型的字符串，在做比较的时候按照字典序排列，100% 就被排在了最后。本人一开始得到的结果和 PPT 展示的结果类似，即 45% 在首项，但是这样不符合题目<code>降序</code>的要求，因此在做排序的时候添加了 <code>+0</code> 给字符串进行类型转化，转化后得到正确答案</p></blockquote><ol start="9"><li>查询未在本次比赛上场的求生者</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT b.role_name<br>FROM record AS a RIGHT JOIN role AS b<br>ON a.record_role = b.role_name<br>WHERE a.record_role IS NULL AND b.survivor = 1<br></code></pre></td></tr></table></figure><p><img src="10.png" alt="" /></p><ol start="10"><li>查询平均牵制时间(contained_hunter_or_knockdowns，取整数)的第二名</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT record_player, ROUND(AVG(contained_hunter_or_knockdowns),0) AS time<br>FROM record <br>GROUP BY record_player<br>ORDER BY time DESC<br>LIMIT 1,1<br></code></pre></td></tr></table></figure><p><img src="11.png" alt="" /></p><ol start="11"><li>查询FPX.ZQ战队未赢过的队</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT total.team<br>FROM<br>(<br>SELECT DISTINCT team<br>FROM player<br>)AS total<br>LEFT JOIN <br>(<br>SELECT DISTINCT *<br>FROM<br>(<br>SELECT<br>CASE WHEN (m.away = &#x27;FPX.ZQ&#x27; AND m.winner = &#x27;FPX.ZQ&#x27;) THEN m.home<br> WHEN(m.home = &#x27;FPX.ZQ&#x27; AND m.winner = &#x27;FPX.ZQ&#x27;) THEN m.away<br> ELSE NULL<br>END AS winner<br>FROM `match` AS m<br>)AS temp<br>WHERE temp.winner IS NOT NULL<br>) AS won<br>ON total.team = won.winner<br>WHERE won.winner IS NULL<br></code></pre></td></tr></table></figure><p><img src="12.png" alt="" /></p><ol start="12"><li>查询Wolves主场客场都战胜的队</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT win_home.winner<br>FROM<br>(<br>SELECT home AS winner<br>FROM `match`<br>WHERE away = &#x27;Wolves&#x27; AND winner = &#x27;Wolves&#x27;<br>)AS win_home <br>INNER JOIN<br>(<br>SELECT away AS winner<br>FROM `match`<br>WHERE home = &#x27;Wolves&#x27; AND winner = &#x27;Wolves&#x27;<br>)AS win_away<br> ON win_home.winner = win_away.winner<br></code></pre></td></tr></table></figure><p><img src="13.png" alt="" /></p><ol start="13"><li>统计在第一轮(sequence=0)中求生者被禁用次数，并根据次数降序排列</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT <br>ban.bp_role_name AS role, <br>COUNT(ban.bp_role_name) AS ban_times<br>FROM <br>half JOIN ban_pick AS ban <br>ON half.half_id = ban.bp_half_id <br>JOIN round <br>ON half.half_round_id = round.round_id<br>WHERE ban.bp_role_name IN (<br>SELECT role_name<br>FROM role<br>WHERE survivor = 1<br>) AND round.sequence = 0<br>GROUP BY ban.bp_role_name <br>ORDER BY ban_times DESC<br></code></pre></td></tr></table></figure><p><img src="14.png" alt="" /></p><ol start="14"><li>查询主场为Gr，客场为DOU5第二轮(sequence=1)上半场(first=1)的比赛情况。（一共5行，包括4求生1监管）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT re.record_player, re.record_role, r.map, re.escape_or_eliminate<br>FROM <br>`match` AS m JOIN round AS r <br>ON m.match_id = r.round_match_id<br>JOIN half AS h<br>ON r.round_id = h.half_round_id<br>JOIN record AS re<br>ON h.half_id = re.record_half_id<br>WHERE <br>m.away = &#x27;DOU5&#x27; <br>AND m.home = &#x27;Gr&#x27; <br>AND r.sequence = 1<br>AND h.`first` = 1<br></code></pre></td></tr></table></figure><p><img src="15.png" alt="" /></p><ol start="15"><li>查询Wolves求生者的每轮逃脱情况（求和escape_or_eliminate），显示主场、客场、比赛时间和轮次，按照时间和轮次升序排序。（截图只保留前10行，Round数据库中从0开始计数，显示时从1开始计数，用字符串拼接）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT  <br>SUM(r.escape_or_eliminate) AS escape_num, m.home, <br>m.away, <br>m.date, <br>CONCAT(&#x27;Round&#x27;,ro.sequence+1) AS round<br>FROM <br>player AS p JOIN record AS r<br>ON p.player_name = r.record_player<br>JOIN half AS h<br>ON r.record_half_id = h.half_id<br>JOIN round AS ro<br>ON h.half_round_id = ro.round_id<br>JOIN `match` AS m<br>ON ro.round_match_id = m.match_id<br>WHERE p.team = &#x27;Wolves&#x27; AND r.survivor = 1<br>GROUP BY(ro.round_id)<br>ORDER BY m.date, round<br></code></pre></td></tr></table></figure><p><img src="16.png" alt="" /></p><ol start="16"><li>查询DOU5监管者的每轮淘汰人数(escape_or_eliminate)情况，显示主场、客场、比赛时间和轮次，按照时间和轮次升序排序，截图只保留前10行。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT  <br>SUM(r.escape_or_eliminate) AS escape_num, m.home, <br>m.away, <br>m.date, <br>CONCAT(&#x27;Round&#x27;,ro.sequence+1) AS round<br>FROM <br>player AS p JOIN record AS r<br>ON p.player_name = r.record_player<br>JOIN half AS h<br>ON r.record_half_id = h.half_id<br>JOIN round AS ro<br>ON h.half_round_id = ro.round_id<br>JOIN `match` AS m<br>ON ro.round_match_id = m.match_id<br>WHERE p.team = &#x27;DOU5&#x27; AND r.survivor = 0<br>GROUP BY(ro.round_id)<br>ORDER BY m.date, round<br></code></pre></td></tr></table></figure><p><img src="17.png" alt="" /></p><ol start="17"><li>查询监管者选手yan的得分情况。按照时间和轮次升序排序，截图只保留前10行</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT  <br>IF(r.escape_or_eliminate = 4,5,r.escape_or_eliminate) AS score,<br>  m.home, <br>  m.away, <br>  m.date, <br>  CONCAT(&#x27;Round&#x27;,ro.sequence+1) AS round<br>FROM <br>player AS p JOIN record AS r<br>ON p.player_name = r.record_player<br>JOIN half AS h<br>ON r.record_half_id = h.half_id<br>JOIN round AS ro<br>ON h.half_round_id = ro.round_id<br>JOIN `match` AS m<br>ON ro.round_match_id = m.match_id<br>WHERE p.player_name = &#x27;yan&#x27; AND r.survivor = 0<br>GROUP BY ro.round_id, date<br></code></pre></td></tr></table></figure><p><img src="18.png" alt="" /></p><ol start="18"><li>查询所有未和监管者gy交手的求生者及其战队，根据战队名字典序排序</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT A.player_name, A.team<br>FROM player AS A LEFT JOIN<br>(<br>SELECT record_player<br>FROM record<br>WHERE record_half_id IN (<br>SELECT  <br>r.record_half_id<br>FROM <br>player AS p JOIN record AS r<br>ON p.player_name = r.record_player<br>WHERE p.player_name = &#x27;gy&#x27; AND r.survivor = 0<br>) AND survivor = 1<br>)AS B<br>ON A.player_name = B.record_player<br>WHERE B.record_player IS NULL<br>ORDER BY A.team ASC, A.player_name ASC<br></code></pre></td></tr></table></figure><p><img src="19.png" alt="" /></p><ol start="19"><li>查询Wolves战队不同选图的胜率情况</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT t1.win_time/t2.total_time AS ratio, t1.map<br>FROM<br>(<br>SELECT r.map, COUNT(map) AS win_time<br>FROM `match` AS m JOIN round AS r ON m.match_id = r.round_match_id<br>WHERE (m.home = &#x27;Wolves&#x27; AND r.home_big_point = 1) OR (m.away = &#x27;Wolves&#x27; AND r.away_big_point = 1)<br>GROUP BY map<br>) AS t1<br>JOIN<br>(<br>SELECT r.map, COUNT(map) AS total_time<br>FROM `match` AS m JOIN round AS r ON m.match_id = r.round_match_id<br>WHERE m.away = &#x27;Wolves&#x27; OR m.home = &#x27;Wolves&#x27;<br>GROUP BY map<br>) AS t2<br>ON t1.map = t2.map<br></code></pre></td></tr></table></figure><p><img src="20.png" alt="" /></p><ol start="20"><li>根据胜利次数对战队降序排序。若胜场相同，按照获胜场的净胜数(不用减去负局丢掉的净胜数)降序排序</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT t_cnt.cnt, t_cnt.winner, t_net.net<br>FROM<br>(<br>SELECT winner, SUM(net) AS net<br>FROM<br>(<br>SELECT m.winner, <br>CASE WHEN (SUM(r.away_big_point) &gt;= SUM(r.home_big_point)) THEN SUM(r.away_big_point)<br>   ELSE SUM(r.home_big_point)<br>END AS net<br>FROM round AS r JOIN `match` AS m ON r.round_match_id = m.match_id<br>GROUP BY r.round_match_id, m.winner<br>)AS t1<br>GROUP BY winner<br>) AS t_net<br>JOIN<br>(<br>SELECT winner, COUNT(winner) AS cnt<br>FROM<br>(<br>SELECT m.winner<br>FROM `match` AS m JOIN round AS r ON m.match_id = r.round_match_id<br>GROUP BY m.match_id, m.winner<br>)AS t1<br>GROUP BY winner<br>) AS t_cnt<br>ON t_cnt.winner = t_net.winner<br>ORDER BY t_cnt.cnt DESC, t_net.net DESC<br></code></pre></td></tr></table></figure><p><img src="21.png" alt="" /></p><ol start="21"><li>统计所有求生者的四人逃脱、三人逃脱、二人逃脱、一人逃脱和无人逃脱局数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT 4-r.escape_or_eliminate AS escape, COUNT(r.escape_or_eliminate) AS cnt<br>FROM record as r<br>WHERE r.survivor = 0<br>GROUP BY r.escape_or_eliminate<br></code></pre></td></tr></table></figure><p><img src="22.png" alt="" /></p><ol start="22"><li>计算每一个战队的总净胜得分(减去负局丢掉的净胜数)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT t_win.net+t_lose.net AS net_rating, t_win.winner AS team<br>FROM<br>(<br>SELECT winner, SUM(net) AS net<br>FROM<br>(<br>SELECT m.winner, <br>CASE WHEN (SUM(r.away_big_point) &gt;= SUM(r.home_big_point)) THEN SUM(r.away_big_point)<br>   ELSE SUM(r.home_big_point)<br>END AS net<br>FROM round AS r JOIN `match` AS m ON r.round_match_id = m.match_id<br>GROUP BY r.round_match_id, m.winner<br>)AS t1<br>GROUP BY winner<br>) AS t_win<br>JOIN<br>(<br>SELECT loser, SUM(net) AS net<br>FROM<br>(<br>SELECT <br>CASE WHEN m.away = m.winner THEN m.home<br>     ELSE m.away<br>END AS loser, <br>CASE WHEN (SUM(r.away_big_point) &lt;= SUM(r.home_big_point)) THEN SUM(r.away_big_point)<br>     ELSE SUM(r.home_big_point)<br>END AS net<br>FROM round AS r JOIN `match` AS m ON r.round_match_id = m.match_id<br>GROUP BY r.round_match_id<br>)AS t1<br>GROUP BY loser<br>) AS t_lose<br>ON t_win.winner = t_lose.loser<br>ORDER BY net_rating DESC<br></code></pre></td></tr></table></figure><p><img src="23.png" alt="" /></p><ol start="23"><li>查询比赛胜者净胜分为2分且无平局记录的对战及获胜战队</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT m.home, m.away, m.winner, m.date<br>FROM round AS r JOIN `match` AS m ON r.round_match_id = m.match_id<br>GROUP BY r.round_match_id, m.winner<br>HAVING COUNT(r.round_id) = 2 <br><br>-- 净胜分为2分且无平局的情况：两轮全胜 <br></code></pre></td></tr></table></figure><p><img src="24.png" alt="" /></p><ol start="24"><li>查询选手DongX在哪几场比赛中胜平率为100%</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT m.home, m.away, m.date<br>FROM player AS p <br>JOIN record AS r<br>ON p.player_name = r.record_player<br>JOIN half AS h<br>ON r.record_half_id = h.half_id<br>JOIN round AS ro<br>ON h.half_round_id = ro.round_id<br>JOIN `match` AS m<br>ON ro.round_match_id = m.match_id<br>WHERE r.record_player = &#x27;DongX&#x27; AND m.winner = p.team<br>GROUP BY m.match_id<br>HAVING MIN(r.escape_or_eliminate) &gt;=2<br></code></pre></td></tr></table></figure><p><img src="25.png" alt="" /></p><h1 id="五-总结"><a class="markdownIt-Anchor" href="#五-总结"></a> 五、总结</h1><ul><li>完成 PPT 要求的查询任务，并且包含 PPT 展示的部分正确结果</li><li>整个实验过程耗时四个多小时，感觉难度很大，但是收获也很大，完全改变了之前做项目的时候在DAO层随便取数据再去业务层处理数据的陋习</li><li>部分题目完成时只考虑了 JOIN 方法，导致代码量大并且查询效率不高</li></ul>]]></content>
    
    
    <categories>
      
      <category>实验报告</category>
      
      <category>数据库系统及其应用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>sql</tag>
      
      <tag>实验报告</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图覆盖｜结构化准则与数据流准则</title>
    <link href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%99%BA%E8%83%BD%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/graph-1/"/>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%99%BA%E8%83%BD%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/graph-1/</url>
    
    <content type="html"><![CDATA[<h1 id="graph-coverage"><a class="markdownIt-Anchor" href="#graph-coverage"></a> Graph Coverage</h1><h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2><ul><li><p>图是测试中<code>最常用</code>的结构</p><ul><li>图有很多的来源：控制流图、设计结构、有限状态机、状态图、用例等</li></ul></li><li><p>图的基本概念：</p><ul><li>一个<code>节点的集合</code> N</li><li>一个<code>初始节点</code>的集合 N<sub>0</sub>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>N</mi><mn>0</mn></msub><mo>⊆</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">N_0 \subseteq N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></li><li>一个<code>终止节点</code>的集合 N<sub>f</sub>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>N</mi><mi>f</mi></msub><mo>⊆</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">N_f \subseteq N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></li><li>一个<code>边</code>的集合 E，E 是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>×</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">N \times N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 的一个子集<ul><li>边可以看作从一个节点到另一个节点的连接，表示为 (n<sub>i</sub>, n<sub>j</sub>)</li><li>n<sub>i</sub> 是先驱节点（predecessor），n<sub>j</sub> 是后继节点（successor）</li></ul></li><li>一个图要想产生有用的测试用例，那 N, N<sub>0</sub>, N<sub>f</sub> 不可为空，边集可为空<br /><img src="1.png" alt="图的示例" /><ul><li>有<code>入边</code>(incoming edge) 但没有前驱节点的初始节点；有加粗边框的节点是终止节点</li></ul></li></ul></li><li><p>路径(path)：</p><ul><li>一个由节点组成的序列(sequence) [n1, n2, …, n<sub>M</sub>]<ul><li>其中每对临近节点(n<sub>i</sub>,n<sub>i</sub>+1), <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">1 \le i \le M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span> 属于边集合 E</li><li>路径的长度为所<code>包含边的数目</code><ul><li>只有一个节点的路径长度为0</li></ul></li><li>路径 p 的子路径(subpath) 是 p 的一个子序列（也可能是 p 本身）</li></ul></li></ul></li><li><p>测试路径(Test path)</p><ul><li>定义：一条长度可能为 0 的路径 p，它起始于 N<sub>0</sub> 中的某个节点，终止于 N<sub>f</sub> 中的某个节点</li><li>测试路径表示测试用例的执行<ul><li>一些测试路径可以由多个测试执行</li><li>一些测试路径不能由任何测试执行</li></ul></li></ul></li><li><p>单入单出图(SESE graphs)</p><ul><li>所有的测试路径都只有一个起始节点和一个终结节点</li><li>N<sub>0</sub> 只有一个节点 n<sub>0</sub>，N<sub>f</sub> 也只有一个节点 n<sub>f</sub><br /><img src="2.png" alt="单入单出图" /></li></ul></li><li><p>访问(visiting) 和游历(touring)</p><ul><li>如果一个节点 n 或一条边 e 存在于一条测试路径 p 中，则 p 访问了 n 或 e</li><li>如果路径 q 是另一条路径 p 的<code>子路径</code>，则 p 游历了 q<br /><img src="3.png" alt="访问和游历" /></li></ul></li><li><p>测试与测试路径</p><ul><li>路径映射<ul><li>path(t): 测试 t 所执行的测试路径</li><li>path(T): 测试集 T 所执行的测试路径的集合</li></ul></li><li>一个图的位置（边和节点）能否被另一个位置到达取决于第一个位置到第二个位置有没有边<ul><li>语法可达(Syntactic reach): 在<code>图</code>中可以找到两个位置之间的一条子路径</li><li>语义可达(Semantic reach): <code>测试可以执行</code>这条子路径</li><li>reach<sub>G</sub>(N<sub>0</sub>) 代表从节点 N<sub>0</sub> 开始所有可达的位置的集合<br /><img src="4.png" alt="可达" /></li></ul></li></ul></li><li><p>测试用例与测试路径的映射关系</p><ul><li>在确定性(Deterministic)软件中，每个测试用例只游历图 G 中的一条测试用例<ul><li>存在多对一关系</li></ul></li><li>在不确定性(Non-deterministic)软件中，每个测试用例游历图 G 中的多条测试用例<ul><li>存在多对多关系<br /><img src="5.png" alt="测试用例映射到测试路径" /></li></ul></li></ul></li></ul><hr /><h2 id="图覆盖标准"><a class="markdownIt-Anchor" href="#图覆盖标准"></a> 图覆盖标准</h2><blockquote><p>Graph Coverage Criteria</p></blockquote><ul><li><p>测试中图的使用方法：</p><ul><li>以图的形式开发软件模型</li><li>需要测试来访问或浏览特定的节点、边或子路径集</li></ul></li><li><p>两类图覆盖准则：</p><ul><li>数据流覆盖标准(Data Flow Coverage Criteria): 要求用变量引用对图表进行注释</li><li>结构覆盖标准(Structural Coverage Criteria): 仅根据节点和边在图上定义</li></ul></li><li><p>图覆盖(Graph Coverage)</p><ul><li>给定图覆盖标准 C 的一组测试需求 TR，当且仅当对于 TR 中的每个测试需求 tr，测试路径集 path(T) 中都至少存在一个测试路径 p 满足 tr 的时候，测试用例集 T 满足图 G 的覆盖标准 C</li></ul></li></ul><hr /><h3 id="结构化的覆盖准则"><a class="markdownIt-Anchor" href="#结构化的覆盖准则"></a> 结构化的覆盖准则</h3><ul><li>节点覆盖, Node Coverage (NC)<ul><li>标准定义：测试集 T 满足图 G 上的节点覆盖当且仅当对于 n 中的每个语法上可到达的节点 n ，path(T) 中存在一些路径 p ，使得 p 访问 n</li><li>形式化定义：对于图 G 中的每个可达的节点 n，TR 包含谓词“访问 n ”</li><li>简化定义：TR 包含 G 中的每个可到达节点</li></ul></li><li>边覆盖, Edge Coverage (EC)<ul><li>TR 包含 G 中每个可达的，<code>长度小于等于 1</code> 的路径<ul><li>允许只有一个节点且没有边的图</li></ul></li></ul></li><li>NC和EC仅在一对节点之间存在边和另一个子路径时是不同的</li></ul><p><img src="6.png" alt="节点覆盖与边覆盖" /></p><ul><li><p>边对覆盖, Edge-Pair Coverage (EPC)</p><ul><li>TR 包含 G 中每个可达的长度<code>小于等于 2</code>的路径</li><li>用于包含边数少于 2 的图<br /><img src="7.png" alt="边对覆盖" /></li></ul></li><li><p>完全路径覆盖, Complete Path Coverage (CPC)</p><ul><li>TR 包含 G 中的所有路径</li><li>如果图 G 中有环，则不存在实际意义，会产生无穷的路径</li></ul></li><li><p>指定路径覆盖, Specified Path Coverage (SPC)</p><ul><li>TR 包含一个测试路径集合 S，其中 S 是一个参数</li></ul></li></ul><hr /><h4 id="解决图中的环"><a class="markdownIt-Anchor" href="#解决图中的环"></a> 解决图中的环</h4><ul><li>简单路径(Simple Path)<ul><li>定义：一个从 n<sub>i</sub> 到 n<sub>j</sub> 的路径是简单路径当且仅当路径中的节点 <strong>只出现</strong> 一次（除了初始节点和终止节点相同的情况）</li><li>简单路径可能是一个自环，但是它没有内在的循环</li></ul></li><li>主路径(Prime Path)<ul><li>定义：对于一条从 n<sub>i</sub> 到 n<sub>j</sub> 的路径是主路径当且仅当该路径是一条简单路径，并且它<code>不是其他任何简单路径的子路径</code>时，这条路径是主路径</li></ul></li><li>主路径覆盖, Prime Path Coverage (PPC)<ul><li>TR 包含 G 中的每一条主路径</li><li>主路径包含点覆盖和边覆盖，但是<code>不能包含边对覆盖</code><br /><img src="8.png" alt="主路径覆盖" /></li></ul></li></ul><hr /><ul><li>游历, touring<ul><li>如果路径 q 是测试路径 p 的子路径，那么测试用例 p 游历了子路径q</li></ul></li><li>经旁游历, Tour With Sidetrips<ul><li>当且仅当子路径 q 中的每条<code>边</code>出现的顺序和在测试路径 p 中出现的顺序相同，那么 p 经旁游历 q</li><li>当游历返回到同一个节点，这个游历就包含一个侧旁游历</li></ul></li><li>绕路游历, Tour With Detours<ul><li>子路径 q 中的所有<code>节点</code>出现的顺序在测试路径 p 中也是相同的</li><li>当游历作为 ni 的后继返回到主路径上，这个游历就包含一个绕道游历</li></ul></li></ul><p><img src="9.png" alt="游历、经旁、绕路" /></p><hr /><ul><li>往返路径, Round-Trip Path<ul><li>一条长度非零且初始节点和终止节点相同的主路径</li></ul></li><li>简单往返覆盖, Simple Round Trip Coverage (SRTC)<ul><li>对于 G 中所有可达的，且可以作为往返路径起点和终点的节点，TR 包含至少一条往返路径</li></ul></li><li>完全往返覆盖, Complete Round Trip Coverage (CRTC)<ul><li>对于 G 中所有可达的节点，TR 包含所有的往返路径</li></ul></li></ul><hr /><h4 id="处理不可行的测试需求"><a class="markdownIt-Anchor" href="#处理不可行的测试需求"></a> 处理不可行的测试需求</h4><ul><li><p>不可行的测试需求主要有</p><ul><li>死代码</li><li>程序中自相矛盾的错误</li></ul></li><li><p>尽量不使用sidetrips或者detour去满足测试需求</p></li><li><p>在不可避免的情况下使用sidetrip和detour（实际上是降低了测试标准）满足测试需求</p></li><li><p>最大限度游历, Best Effort Touring<br /><img src="10.png" alt="最大限度游历" /></p></li></ul><hr /><h3 id="数据流准则"><a class="markdownIt-Anchor" href="#数据流准则"></a> 数据流准则</h3><ul><li><p>应用数据流图的目的是确保变量能够被正确的 <strong>定义和使用</strong></p></li><li><p>定义和使用相关定义</p><ul><li>定义, Definition(def)<ul><li>变量被定义出来并且存储到内存的某个位置</li></ul></li><li>使用, use<ul><li>变量被使用的位置</li></ul></li></ul><blockquote><p>对于一条语句来说，语句左边的变量就是def，语句右边的变量就是use<br />对于一条测试路径，要有包含从定义到使用的部分</p></blockquote><ul><li>def(n) / def(e)<ul><li>在节点n和边e上定义的变量的集合</li></ul></li><li>use(n) / use(e)<ul><li>在节点n和边e上使用的变量的集合<br /><img src="11.png" alt="定义与使用" /></li></ul></li></ul></li><li><p>DU Pairs and DU Paths</p><ul><li>DU pair（定义使用对）<ul><li>定义使用对 (I<sub>i</sub>,I<sub>j</sub>) 表示变量 v 在 I<sub>i</sub> 被定义，在 I<sub>j</sub> 被使用</li></ul></li><li>Def-Clear, 无重复定义<ul><li>存在一条由 I<sub>i</sub> 到 I<sub>j</sub> 的路径，对于这条路径上的每个不属于起始节点和终止节点的节点和边都不存在对于变量 v 的定义</li></ul></li><li>Reach, 可达<ul><li>针对变量 v 从定义处 I<sub>i</sub> 到使用处 I<sub>j</sub> 存在一条无重复定义的路径</li></ul></li><li>du-path<ul><li>变量 v 从定义到使用这一段路径即<code>是简单路径也是无重复定义路径</code></li><li>du(I<sub>i</sub>, I<sub>j</sub>, v)表示变量 v 从定义处 I<sub>i</sub> 到使用处 I<sub>j</sub> 的 du-path 的集合</li><li>du(I<sub>i</sub>, v)表示变量 v 从定义处 I<sub>i</sub> 开始的 du-path 的集合</li></ul></li><li>du-tour<ul><li>路径 p <code>du游历</code> 子路径 d 当且仅当 d 是针对变量 v 的一条无重复定义的简单路径</li></ul></li></ul></li></ul><hr /><ul><li>测试标准<ul><li>全定义覆盖, All-defs coverage (ADC)<ul><li>对于每个定义路径集合 S = du(n, v), TR 包含 S 中<code>至少一条</code>路径 d</li><li>每一个 def 都能到达一个 use</li></ul></li><li>全使用覆盖, All-uses coverage (AUC)<ul><li>对于每个定义对集合 S = du(n<sub>i</sub>, n<sub>j</sub>, v), TR 包含 S 中至少一条路径 d</li><li>让每一个定义可能到达的use都被覆盖到</li></ul></li></ul><blockquote><p>两者的区别在于</p><ul><li>针对一个变量的定义处，ADC 只要求从定义处出发的 du-path 中其中一条就可以</li><li>而 AUC 则要求定义处到多个使用处的每一个 du-path 集合里，都要至少一条</li></ul></blockquote><ul><li>全定义使用路径覆盖, All-du-paths coverage (ADUPC)<ul><li>在针对变量 v 的 du(I<sub>i</sub>,I<sub>j</sub>,v) 集合的<code>所有路径</code>都要在 TR 中<br /><img src="12.png" alt="" /></li></ul></li></ul></li></ul><hr /><h3 id="图覆盖的包含关系"><a class="markdownIt-Anchor" href="#图覆盖的包含关系"></a> 图覆盖的包含关系</h3><p><img src="13.png" alt="图覆盖的包含关系" /></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>专业课</category>
      
      <category>智能软件测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件测试</tag>
      
      <tag>图覆盖</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>词法分析｜从 RE 到 DFA</title>
    <link href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/compile-4/"/>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/compile-4/</url>
    
    <content type="html"><![CDATA[<h1 id="lexical-analysis-词法分析-3"><a class="markdownIt-Anchor" href="#lexical-analysis-词法分析-3"></a> Lexical Analysis 词法分析-3</h1><h2 id="从正则表达式构造nfa"><a class="markdownIt-Anchor" href="#从正则表达式构造nfa"></a> 从正则表达式构造NFA</h2><ul><li><p><strong>Thompson 算法</strong> ：</p><ul><li>将任何正则表达式转变为接受相同语言的 NFA</li><li>这个算法是语法制导的，也就是说它沿着正则表达式的语法分析树<code>自底向上</code>递归地进行处理</li><li><code>对于每个子表达式，该算法构造一个只有一个接受状态的NFA</code></li></ul></li><li><p>算法具体内容：</p><ul><li>方法：<ul><li>首先对 r 进行语法分析，分解出组成它的子表达式</li><li>构造一个 NFA 的规则分为基本规则和归纳规则两组<ul><li>基本规则处理<code>不包含运算符</code>的子表达式</li><li>归纳规则根据一个给定表达式的直接子表达式的 NFA 构造出这个表达式的 NFA</li></ul></li></ul></li><li>基本规则<ul><li>对于表达式∈，构造下面的 NFA<br /><img src="1.png" alt="" /></li><li>对于字母表 Σ 中的子表达式 a，构造下面的 NFA<br /><img src="2.png" alt="" /></li><li>i 和 f 都是新状态，分别是这个 NFA 的开始状态和接受状态</li></ul></li><li>归纳规则<ul><li>两个正则表达式的 <strong>并</strong> 的 NFA<br /><img src="3.png" alt="" /></li><li>两个正则表达式的 <strong>连接</strong> 的 NFA<br /><img src="4.png" alt="" /></li><li>一个正则表达式的 <strong>闭包</strong> 的 NFA<br /><img src="5.png" alt="" /></li></ul></li></ul></li><li><p>Thompson 构造法的性质</p><ul><li>N(r) 的状态数最多为<code>r 中出现的运算符和运算分量的总数的 2 倍</code><ul><li>得出这个上界的原因是算法的每一个构造步骤最多只引入两个新状态</li></ul></li><li>N(r) <code>有且只有</code>一个开始状态和一个接受状态</li><li>N(r) 中除接受状态之外的每个状态要么有一条其标号为 Σ 中符号的出边，要么有两条标号为 ∈ 的出边</li></ul></li><li><p>构造示例：<br /><img src="6.png" alt="(a|b)*a" /></p></li><li><p>处理算法的效率<br /><img src="7.png" alt="" /></p></li></ul><hr /><h2 id="根据正则表达式构建dfa"><a class="markdownIt-Anchor" href="#根据正则表达式构建dfa"></a> 根据正则表达式构建DFA</h2><ul><li><p>在一个正则表达式 r 的右端连接一个独特的右端结束标记符 <code>#</code>，使得 r 的接受状态增加一个在 # 上的转换</p><ul><li>换句话说，通过使用扩展的（augment）正则表达式（r）#，我们可以在构造过程中不考虑接受状态的问题<ul><li>当构造过程结束后，<code>任何在 # 上有离开转换的状态必然是一个接受状态</code></li></ul></li></ul></li><li><p>抽象语法树的<code>叶子结点</code>可以标号为∈，也可以用字母表中的符号作为标号</p><ul><li>对于每一个标号<code>不为∈</code>的叶子结点，我们赋予一个独有的整数。我们将这个整数称为叶子结点的位置（position），同时也表示和它对应的符号的位置</li><li>请注意，一个符号可以有多个位置，抽象语法树中的这些位置对应于构造出的NFA中的重要状态<br /><img src="8.png" alt="（a|b）*abb#的抽象语法树" /></li></ul></li></ul><hr /><h3 id="根据抽象语法树计算得到的函数"><a class="markdownIt-Anchor" href="#根据抽象语法树计算得到的函数"></a> 根据抽象语法树计算得到的函数</h3><ul><li>要从一个正则表达式直接构造出DFA，我们要首先构造它的<code>抽象语法树</code>，然后计算如下四个函数：nullable、firstpos、lastpos和followpos<ul><li><strong>nullable(n)</strong> : 对于一个抽象语法树结点 n 为真当且仅当此结点代表的子表达式的语言中包含空串∈<ul><li>也就是说，这个子表达式可以“生成空串”或者本身就是空串，即使它也可能表示一些其他的串</li></ul></li><li><strong>firstpos(n)</strong> : 定义了以结点 n 为根的子树中的位置集合，这些位置对应于以 n 为根的子表达式的语言中某个串的<code>第一个符号</code></li><li><strong>lastpos(n)</strong> : 定义了以结点 n 为根的子树中的位置集合，这些位置对应于以 n 为根的子表达式的语言中某个串的<code>最后一个符号</code></li><li><strong>followpos(i)</strong> : 在增广正则表达式生成的字符串中，可以跟随位置i的位置集。</li></ul></li></ul><hr /><h3 id="计算nullable-firstpos及lastpos"><a class="markdownIt-Anchor" href="#计算nullable-firstpos及lastpos"></a> 计算nullable、firstpos及lastpos</h3><ul><li>可以使用一个对树的高度直接进行递归的过程来计算 nullable 、firstpos 和 lastpos</li><li>计算方法：<br /><img src="9.png" alt="计算nullable、firstpos及lastpos" /></li><li>示例，其中，firstpos(n) 显示在结点 n 的左边，lastpos(n) 显示在结点右边<br /><img src="10.png" alt="(a|b)*abb#的语法分析树的结点的firstpos和lastpos" /><ul><li>每个叶子结点的firstpos和lastpos只包含它自身</li><li>or 结点的firstpos和lastpos分别是它的所有子结点的firstpos和lastpos的并集</li><li>针对star结点的规则是，它的firstpos及lastpos分别是它的唯一子结点的firstpos和lastpos</li></ul></li></ul><hr /><h3 id="计算followpos"><a class="markdownIt-Anchor" href="#计算followpos"></a> 计算followpos</h3><ul><li><p>只有两种情况会使得一个正则表达式的某个位置会跟在另一个位置之后：</p><ul><li>如果 n 是一个 cat（连接） 结点，且其左右子结点分别为 c1、 c2，那么对于 lastpos（c1） 中的每个位置 i， firstpos（c2） 中的所有位置都在 followpos（i）中</li><li>如果 n 是 star 结点，并且 i 是 lastpos（n） 中的一个位置，那么 firstpos（n）中的所有位置都在 followpos（i）中</li><li>如果为每个节点计算了 firstpos 和 lastpos，则可以通过对语法树进行一次深度优先遍历来计算每个位置的后续位置。<br /><img src="11.png" alt="以(a|b)*a#为例" /></li></ul></li><li><p>经过以下的处理，一个图可以变成 NFA</p><ul><li>将根结点的 firstpos 中的所有位置设为开始状态</li><li>在每条从 i 到 j 的有向边上添加位置 i 上的符号作为标号</li><li>把和结尾 # 相关的位置当作唯一的接受状态</li></ul></li></ul><hr /><h3 id="根据正则表达式构建-dfa"><a class="markdownIt-Anchor" href="#根据正则表达式构建-dfa"></a> 根据正则表达式构建 DFA</h3><ul><li><p>方法：</p><ul><li>根据扩展的正则表达式 (r)# 构造出一棵抽象语法树 T</li><li>计算得到 T 的函数 nullable、firstpos、lastpos 和 followpos</li><li>使用下图所示的过程，构造出 D 的状态集 Dstates 和 D 的转换函数 Dtran<br /><img src="12.png" alt="从一个正则表达式直接构造一个DFA" /></li></ul></li><li><p>示例：<br /><img src="13.png" alt="以(a|b)*a#为例" /></p></li></ul><hr /><h2 id="最小化一个dfa的状态数"><a class="markdownIt-Anchor" href="#最小化一个dfa的状态数"></a> 最小化一个DFA的状态数</h2><blockquote><p>Minimizing</p></blockquote><ul><li><p>如果只需改变状态名字就可以将一个自动机转换成为另一个自动机，那么这两个自动机是<code>同构</code>的</p><ul><li>任何正则语言都有一个唯一的（不计同构）状态数目最少的DFA</li></ul></li><li><p>如果分别从状态 s 和 t 出发，沿着标号为 x 的路径到达的<code>两个状态中只有一个是接受状态</code>，那么串 x 区分状态 s 和 t</p><ul><li>如果存在某个能够区分状态 s 和状态 t 的串，那么它们就是<code>可区分的(distinguishable)</code></li><li>空串 ∈ 可以区分任何一个接受状态和非接受状态</li></ul></li><li><p>DFA 状态最小化算法的工作原理：</p><ul><li>将一个DFA的状态集合分划成多个组，每个组中的各个状态之间相互不可区分。</li><li>然后，将每个组中的状态合并成状态最少 DFA 的一个状态</li></ul></li><li><p>DFA 状态最小化算法基本步骤</p><ul><li>最初，该分划包含两个组：接受状态组和非接受状态组</li><li>从当前分划中取一个状态组，比如 A = {s1，s2，…，sk}，并选定某个输入符号 a，检查 a 是否可以用于区分 A 中的某些状态。</li><li>检查 s1，s2，…，sk 在 a 上的转换，如果这些转换到达的状态落入当前分划的<code>两个或多个组</code>中，就将 A 分割成为多个组，使得 si 和 sj 在同一组中当且仅当它们在 a 上的转换都到达同一个组的状态</li><li>重复这个分割过程，直到无法根据某个输入符号对任意个组进行分割为止。</li></ul></li></ul><p><img src="14.png" alt="" /><br /><img src="15.png" alt="最小化示例" /></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>专业课</category>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
      <tag>词法分析</tag>
      
      <tag>汤普森构造法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>智能软件测试｜Criteria-Based Test Design</title>
    <link href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%99%BA%E8%83%BD%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/softtest-2/"/>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%99%BA%E8%83%BD%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/softtest-2/</url>
    
    <content type="html"><![CDATA[<h1 id="基于标准的测试设计"><a class="markdownIt-Anchor" href="#基于标准的测试设计"></a> 基于标准的测试设计</h1><blockquote><p>Criteria-Based Test Design</p></blockquote><h2 id="新旧测试观念"><a class="markdownIt-Anchor" href="#新旧测试观念"></a> 新旧测试观念</h2><ul><li><p>旧的观点把重点放在每个 <strong>软件开发</strong> 阶段的测试上，因为它与其他阶段非常不同</p><ul><li>模块，集成，系统</li></ul></li><li><p>新的测试观念侧重于 <strong>结构(structures)</strong> 和 <strong>标准(criteria)</strong></p><ul><li>输入空间、图形、逻辑表达式、语法<br /><img src="1.png" alt="基于结构的标准" /></li><li>每个阶段的测试设计基本相同<ul><li>创建 <strong>模型</strong> 是不同的</li><li><strong>选择值</strong> 和 <strong>自动化测试</strong> 是不同的</li></ul></li></ul></li><li><p>基于结构的标准的结构来源：这些结构可以从大量软件工件中<code>提取</code></p><ul><li><strong>图(Garphs)</strong> 可以从UML用例、有限状态机和源代码中提取</li><li><strong>逻辑表达式(Logical expressions)</strong> 可以从程序源代码中的决策、转换保护、用例中的条件等中提取…</li><li>基于结构的测试标准和 <code>“基于模型的测试”</code> 不同，后者从描述被测系统某些方面的模型派生测试<ul><li><code>模型</code>通常描述<code>行为</code>的一部分</li><li><code>源代码</code>不作为考量的部分</li></ul></li></ul></li></ul><p><img src="2.png" alt="" /></p><hr /><h2 id="测试覆盖标准test-coverage-criteria"><a class="markdownIt-Anchor" href="#测试覆盖标准test-coverage-criteria"></a> 测试覆盖标准（Test Coverage Criteria）</h2><blockquote><p>测试人员的工作很简单：定义软件的模型，然后找到覆盖它的方法</p></blockquote><ul><li><strong>测试需求(Test Requirements)</strong> ：测试需求是软件工件的一个特定元素，测试用例必须满足或覆盖这个特定元素（提炼通用部分）</li><li><strong>覆盖标准(Coverage Criterion)</strong> ：一个覆盖标准是一条规则，或者是将测试需求施加在一个测试集上的一组规则<ul><li>覆盖标准以一种全面并且精确的方式描述了测试需求</li></ul></li><li><strong>覆盖(Coverage)</strong> ：给定一个覆盖标准 C 和相关的测试需求集合 TR，要使一个测试集合 T 满足 C，当且仅当对于测试需求集合 TR 中的每一条测试需求 tr，在 T 中至少存在一个测试 t 可以满足 tr</li><li><strong>覆盖程度(Coverage Level)</strong> ：给定一个测试需求集合 TR 和一个测试集合 T，覆盖程度就是 T 满足的测试需求数占 TR 总数的比例</li><li><strong>不可行(Infeasible)的测试要求</strong> ：无法满足的测试要求<ul><li>不存在满足测试要求的测试用例值</li><li>例如：死代码(Dead code)</li><li>对于大多数覆盖标准来说，检测不可行测试需求形式上是<code>不可判定的</code></li><li>因此 <strong>100%的覆盖率在实际中是不存在的</strong></li></ul></li></ul><hr /><ul><li>使用测试标准的两种方法<ul><li><code>直接生成</code>满足标准的测试值<ul><li>通常由研究界承担</li><li>使用标准的最明显方式</li><li>没有自动化工具很难</li></ul></li><li><code>外部</code>地生成测试用例值（例如手动或使用伪随机工具），然后根据覆盖标准来<code>度量</code>测试<ul><li>通常受到工业界的青睐</li><li>有时存在误差</li></ul></li></ul></li></ul><hr /><ul><li>生成器和识别器<ul><li><strong>生成器(Generator)</strong> ：一个程序可以自动生成满足标准的值</li><li><strong>识别器(Recognizer)</strong> ：一个判定给定测试用例值集合是否满足标准的程序</li><li>对于大多数标准来说，这两个问题都是<code>不可证明</code>的</li><li>与生成满足标准的测试相比，识别测试用例是否满足标准的可能性要高得多</li></ul></li></ul><hr /><ul><li><strong>标准包含(Criteria Subsumption)</strong> ：覆盖标准 C1 包含 C2，当且仅当满足 C1 的每一个测试集合都满足 C2</li></ul><blockquote><p>对于<code>每一组</code>测试用例都必须为真</p></blockquote><ul><li><p>例如：如果一个测试集覆盖了程序中的<code>每个分支</code>（满足分支标准），那么该测试集就保证也覆盖了<code>每个语句</code></p></li><li><p>不可行与包含</p><ul><li>当且仅当所有的测试需求都是可行的，有时标准 C1 包含另一个标准 C2</li><li>如果 C1 的某些测试需求是不可行的，C1 将不包含 C2</li></ul></li></ul><hr /><h2 id="好的覆盖标准的特征"><a class="markdownIt-Anchor" href="#好的覆盖标准的特征"></a> 好的覆盖标准的特征</h2><ol><li><p>自动计算测试需求应该相当容易</p></li><li><p>生成测试值应该是有效的</p></li><li><p>由此产生的测试应尽可能多地揭示故障</p></li></ol><blockquote><p>包含只是故障揭示能力的<code>粗略近似值</code></p></blockquote><hr /><h2 id="基于准则的测试设计的优势"><a class="markdownIt-Anchor" href="#基于准则的测试设计的优势"></a> 基于准则的测试设计的优势</h2><ul><li><p>标准最大限度地提高了“<code>成本效益</code>”</p><ul><li><code>更少</code>的测试更有效地发现故障</li></ul></li><li><p>具有<code>最小重叠</code>的综合测试集</p></li><li><p>从软件工件到测试的<code>可追溯性</code></p><ul><li>来源、需求、设计模型…</li><li>回答每个测试的“为什么”</li><li>对回归测试的内置支持</li></ul></li><li><p>测试的“<code>停止规则</code>”可以提前知道需要进行多少次测试</p><ul><li>有利于自动操作</li><li>可以通过强大的工具得到很好的支持</li></ul></li></ul><hr /><h1 id="概述总结"><a class="markdownIt-Anchor" href="#概述总结"></a> 概述总结</h1><ul><li>我们为什么要进行测试：以<code>降低使用软件的风险</code><ul><li>目标：尽早消除故障（提高质量、降低成本、保持客户满意度）</li><li>Faults, failures, the RIPR model</li><li>测试过程成熟度级别 —— 4级是一种提高软件质量的心理训练</li></ul></li><li>测试活动<ul><li>V模型、多V模型</li><li>模型驱动的测试设计：四种类型的<code>测试活动</code>——测试设计、自动化、执行和评估</li></ul></li><li>术语<ul><li>Validation, Verification; Testing, debugging;</li><li>Testability, observability and controllability, test automation frameworks</li><li>Criteria-based test design: <code>Four structures</code> – test <code>requirements</code> and <code>criteria</code></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>专业课</category>
      
      <category>智能软件测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>词法分析｜从 NFA 到 DFA</title>
    <link href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/compile-3/"/>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/compile-3/</url>
    
    <content type="html"><![CDATA[<h1 id="lexical-analysis-词法分析-2"><a class="markdownIt-Anchor" href="#lexical-analysis-词法分析-2"></a> Lexical Analysis 词法分析-2</h1><h2 id="词法单元的识别"><a class="markdownIt-Anchor" href="#词法单元的识别"></a> 词法单元的识别</h2><p><img src="1.png" alt="常见词法单元模式(patterns)" /></p><p><img src="2.png" alt="空白符" /></p><p><img src="3.png" alt="词法单元、它们的模式以及属性值" /></p><ul><li>上表总结了词法分析器的目标。对于各个词素或词素的集合，该表显示了应该将哪个词法单元名返回给语法分析器，以及应该返回什么属性值</li></ul><hr /><h3 id="状态转换图transition-diagram"><a class="markdownIt-Anchor" href="#状态转换图transition-diagram"></a> 状态转换图（transition diagram）</h3><ul><li>作为构造词法分析器的一个中间步骤，我们首先将 <strong>模式</strong> 转换成具有特定风格的流图，称为 <strong>状态转换图</strong><ul><li>在读取字符时，使用相关的 <strong>TDs</strong> 尝试将词素与模式匹配</li></ul></li><li>每个状态转移图都有：<ul><li><strong>States（状态）</strong> : 由圆圈代表<ul><li>词法分析器在扫描输入串的过程中寻找和某个模式匹配的词素，而转换图中的每个状态代表一个可能在这个过程中出现的情况</li></ul></li><li><strong>Actions（动作）</strong> : 从图的一个状态指向另一个状态的箭头</li><li><strong>Start State（开始状态）</strong> : 该状态由一条没有出发结点的、标号为“start”的边指明</li><li><strong>Final State（接受状态或最终状态）</strong> : 用双层的圈来表示一个接受状态<br /><img src="5.png" alt="逻辑运算符的状态转移图" /></li></ul></li></ul><hr /><h3 id="保留字和标识符的识别"><a class="markdownIt-Anchor" href="#保留字和标识符的识别"></a> 保留字和标识符的识别</h3><p><img src="6.png" alt="保留字和标识符的识别" /></p><ul><li>初始化时就将各个保留字填入符号表中。符号表条目的某个字段会指明这些串并不是普通的标识符，并指出它们所代表的词法单元。</li><li>当找到一个标识符时，如果该标识符尚未出现在符号表中，就会调用 <strong>installID</strong> 将此标识符放入符号表中，并返回一个指针，指向这个刚找到的词素所对应的符号表条目</li></ul><p><img src="7.png" alt="关键字符号表" /></p><ul><li>函数 <strong>getToken</strong> 查看对应于刚找到的词素的符号表条目，并根据符号表中的信息返回该词素所代表的词法单元名</li></ul><hr /><h2 id="有穷自动机finite-automata"><a class="markdownIt-Anchor" href="#有穷自动机finite-automata"></a> 有穷自动机(finite automata)</h2><ul><li><p>有穷自动机在本质上是与状态转换图类似的图，但有如下几点不同：</p><ul><li>有穷自动机是<strong>识别器（recognizer）</strong>，它们只能对每个可能的输入串简单地回答“是”或“否”。</li><li>有穷自动机分为两类：<ul><li><strong>不确定的有穷自动机（Nondeterministic Finite Automata，NFA）</strong> 对其边上的标号没有任何限制。一个符号标记离开同一状态的多条边，并且空串∈也可以作为标号</li><li>对于每个状态及自动机输入字母表中的每个符号，<strong>确定的有穷自动机（Deterministic Finite Automata，DFA）</strong> 有且只有<code>一条离开该状态</code>、以该符号为标号的边</li></ul></li><li>确定性和非确定性有限自动机都能识别正则集。<ul><li>DFA 识别速度更快，但需要占用更多的空间</li><li>NFA 的识别速度可能稍慢（需要回溯），但是占用空间更小</li></ul></li></ul></li><li><p>首先要为词法单元定义正则表达式，再将其转换为 DFA 以获取词法单元的词法分析器</p></li></ul><hr /><h3 id="nfa"><a class="markdownIt-Anchor" href="#nfa"></a> NFA</h3><ul><li><p>一个不确定的有穷自动机（NFA）是一个数学模型，它由以下几个部分组成：</p><ul><li>一个有穷的状态集合 S</li><li>一个输入符号集合 Σ，即输入字母表（input alphabet）</li><li>一个转换函数（transition function），它为每个状态和 <code>Σ∪&#123;∈&#125;</code> 中的每个符号都给出了相应的<strong>后继状态（next state）</strong> 的集合</li><li>S 中的一个状态 s0 被指定为开始状态，或者说初始状态</li><li>S 的一个子集 F 被指定为接受状态（或者说终止状态的）集合</li></ul></li><li><p>在 NFA 中允许<strong>空转移(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ε</mi></mrow><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ε</span></span></span></span>- transitions)</strong> ，可以在不使用任何符号的情况下从一个状态移动到另一个状态。</p></li><li><p>一个 NFA <strong>接受（accept）</strong> 输入字符串 x，当且仅当对应的转换图中存在一条从开始状态到某个接受状态的路径，使得<code>该路径中各条边上的标号组成符号串 x</code></p><ul><li>注意，路径中的∈标号将被忽略</li><li>由一个 NFA 定义（或接受）的语言是从开始状态到某个接受状态的所有路径上的标号串的集合</li></ul></li></ul><p><img src="8.png" alt="(a|b)*abb" /></p><hr /><h3 id="转换表"><a class="markdownIt-Anchor" href="#转换表"></a> 转换表</h3><ul><li>为了计算机存储、理解方便，可以将一个NFA表示为一张<strong>转换表（transition table）</strong><ul><li>表的各行对应于状态</li><li>各列对应于输入符号和 ∈</li><li>对应于一个给定状态和给定输入的条目是将NFA的转换函数应用于这些参数后得到的值</li><li>如果转换函数没有给出对应于某个 状态-输入 对的信息，我们就把 Ø 放入相应的表项中</li><li>注意：需要标明 <strong>开始/结束</strong> 状态</li></ul></li></ul><p><img src="9.png" alt="" /></p><hr /><h3 id="dfa"><a class="markdownIt-Anchor" href="#dfa"></a> DFA</h3><ul><li><strong>确定的有穷自动机（DFA）</strong> 是不确定有穷自动机的一个特例，其中：<ul><li>没有输入 ∈ 之上的转换动作</li><li>对每个状态 s 和每个输入符号 a，<code>有且只有一条</code>标号为 a 的边离开 s</li></ul></li><li>NFA 抽象地表示了用来识别某个语言中的串的算法，而相应的 DFA 则是一个简单具体的识别串的算法。</li></ul><hr /><h2 id="从正则表达式到自动机"><a class="markdownIt-Anchor" href="#从正则表达式到自动机"></a> 从正则表达式到自动机</h2><h3 id="从-nfa-到-dfa-的转换"><a class="markdownIt-Anchor" href="#从-nfa-到-dfa-的转换"></a> 从 NFA 到 DFA 的转换</h3><ul><li><p>子集构造法的基本思想是让构造得到的DFA的每个状态对应于 NFA 的一个状态集合</p><ul><li>消除空转移</li><li>在单个输入字符上从一个状态进行多次转换</li></ul></li><li><p>子集构造法算法：</p><ul><li>输入：一个 NFA, N</li><li>输出：一个 DFA, D</li><li>方法：为D构造一个转换表 Dtran，D 的每个状态是一<br />个 NFA 状态集合。构造的 Dtran 使得 D “并行地”模拟 N 在遇到一个给定输入串时可能执行的所有动作</li></ul></li></ul><p><img src="10.png" alt="NFA状态集上的操作" /></p><p><img src="11.png" alt="子集构造法" /></p><ul><li>D 的开始状态是 ∈-closure（s0）</li><li>D 的接受状态是所有至少包含了 N 的一个接受状态的状态集合</li><li>只需要说明如何对NFA的任何状态集合 T 计算 ∈-closure（T） ，就可以完整地描述子集构造法</li></ul><hr /><blockquote><p>子集构造法示例</p></blockquote><ul><li>下图为接受语言 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mi mathvariant="normal">∣</mi><mi>b</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>a</mi><mi>b</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">(a|b)*abb</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord">∣</span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault">b</span></span></span></span> 的 NFA</li></ul><p><img src="12.png" alt="N" /></p><ul><li>等价 NFA 的<strong>开始状态</strong> <strong>S0</strong> 是∈-closure（0），即 S0={0，1，2，4，7}<ul><li>能够从状态 0 出发，只经过标号为∈的路径到达的所有状态</li></ul></li><li>NFA的输入字母表是 {a，b}，因此我们<strong>标记 S0</strong>，计算：<ul><li>Dtran［S0，a］= ∈-closure(move(S0,a)) = ∈-closure({3,8}) = {1,2,3,4,6,7,8} = <strong>S1</strong></li><li>Dtran［S0，b］= ∈-closure(move(S0,b)) = ∈-closure({5}) = {1,2,4,5,6,7} = <strong>S2</strong></li></ul></li><li>之后对未加标记的 S1 和 S2 继续这个处理过程，最终就能使得 DFA 的所有状态都被加上标记</li></ul><p><img src="13.png" alt="" /><br /><img src="14.png" alt="完整处理过程" /></p><p><img src="15.png" alt="DFA 转换表 Dtran" /></p><p><img src="16.png" alt="最终得到的NFA" /></p><hr /><h1 id="练习"><a class="markdownIt-Anchor" href="#练习"></a> 练习</h1><h2 id="3-1"><a class="markdownIt-Anchor" href="#3-1"></a> 3-1</h2><p><img src="NFA.png" alt="a(a|b) *b" /></p><hr /><ul><li><p>开始状态 S0 = ∈-closure({0}) = {0}</p></li><li><p>标记 S0：</p><ul><li>Dtran［S0，a］= ∈-closure(move(S0,a)) = ∈-closure({1}) = {1,2,3,5,8} = S1</li><li>Dtran［S0，b］= ∈-closure(move(S0,b)) = ∈-closure(∈) = {∈}</li></ul></li><li><p>标记 S1：</p><ul><li>Dtran［S1，a］= ∈-closure(move(S1,a)) = ∈-closure({4}) = {2,3,4,5,7,8} = S2</li><li>Dtran［S1，b］= ∈-closure(move(S1,b)) = ∈-closure({6,9}) = {2,3,5,6,7,8,9} = S3</li></ul></li><li><p>标记 S2：</p><ul><li>Dtran［S2，a］= ∈-closure(move(S2,a)) = ∈-closure({4}) = S2</li><li>Dtran［S2，b］= ∈-closure(move(S2,b)) = ∈-closure({6,9}) = S3</li></ul></li><li><p>标记 S3</p><ul><li>Dtran［S3，a］= ∈-closure(move(S3,a)) = ∈-closure({4}) = S2</li><li>Dtran［S3，b］= ∈-closure(move(S3,b)) = ∈-closure({6,9}) = S3</li></ul></li><li><p>因此转移表为</p></li></ul><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">输入符号</th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">状态</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">S0</td><td style="text-align:center">S1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">S1</td><td style="text-align:center">S2</td><td style="text-align:center">S3</td></tr><tr><td style="text-align:center">S2</td><td style="text-align:center">S2</td><td style="text-align:center">S3</td></tr><tr><td style="text-align:center">S3</td><td style="text-align:center">S2</td><td style="text-align:center">S3</td></tr></tbody></table><blockquote><p>起始状态为 S0，接收状态为 S3</p></blockquote><ul><li>转换后的 DFA 为：</li></ul><p><img src="3-1DFA.png" alt="" /></p><blockquote><p>可以将 S1 精简掉，精简后和 PPT 上答案一致</p></blockquote><hr /><h2 id="3-2"><a class="markdownIt-Anchor" href="#3-2"></a> 3-2</h2><p><img src="3-2NFA.png" alt="" /></p><hr /><ul><li><p>开始状态 S0 = ∈-closure({0}) = {0}</p></li><li><p>标记 S0：</p><ul><li>Dtran［S0，a］= ∈-closure(move(S0,a)) = ∈-closure(∈) = {∈}</li><li>Dtran［S0，b］= ∈-closure(move(S0,b)) = ∈-closure({1}) = {1,2,4} = S1</li></ul></li><li><p>标记 S1：</p><ul><li>Dtran［S1，a］= ∈-closure(move(S1,a)) = ∈-closure({3}) = {3,6,7,8,9,11,14} = S2</li><li>Dtran［S1，b］= ∈-closure(move(S1,b)) = ∈-closure({5}) = {5,6,7,8,9,11,14} = S3</li></ul></li><li><p>标记 S2：</p><ul><li>Dtran［S2，a］= ∈-closure(move(S2,a)) = ∈-closure({10,15}) = {8,9,10,11,13,14,15} = S4</li><li>Dtran［S2，b］= ∈-closure(move(S2,b)) = ∈-closure({12}) = {8,9,11,12,13,14} = S5</li></ul></li><li><p>标记 S3</p><ul><li>Dtran［S3，a］= ∈-closure(move(S3,a)) = ∈-closure({10,15}) = S4</li><li>Dtran［S3，b］= ∈-closure(move(S3,b)) = ∈-closure({12}) = {5,6,7,8,9,11,14} = S5</li></ul></li><li><p>标记 S4：</p><ul><li>Dtran［S4，a］= ∈-closure(move(S4,a)) = ∈-closure({10,15}) = S4</li><li>Dtran［S4，b］= ∈-closure(move(S4,a)) = ∈-closure({12}) = S5</li></ul></li><li><p>标记 S5：</p><ul><li>Dtran［S5，a］= ∈-closure(move(S5,a)) = ∈-closure({10,15}) = S4</li><li>Dtran［S5，b］= ∈-closure(move(S5,a)) = ∈-closure({12}) = S5</li></ul></li><li><p>因此转移表为</p></li></ul><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">输入符号</th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">状态</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">S0</td><td style="text-align:center">-</td><td style="text-align:center">S1</td></tr><tr><td style="text-align:center">S1</td><td style="text-align:center">S2</td><td style="text-align:center">S3</td></tr><tr><td style="text-align:center">S2</td><td style="text-align:center">S4</td><td style="text-align:center">S5</td></tr><tr><td style="text-align:center">S3</td><td style="text-align:center">S4</td><td style="text-align:center">S5</td></tr><tr><td style="text-align:center">S4</td><td style="text-align:center">S4</td><td style="text-align:center">S5</td></tr><tr><td style="text-align:center">S5</td><td style="text-align:center">S4</td><td style="text-align:center">S5</td></tr></tbody></table><blockquote><p>起始状态为 S0，接收状态为 S4</p></blockquote><ul><li>转换后的 DFA 为：</li></ul><p><img src="3-2DFA.png" alt="" /></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>专业课</category>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
      <tag>词法分析</tag>
      
      <tag>子集构造法</tag>
      
      <tag>有限自动机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>词法分析｜词法单元与正则表达式</title>
    <link href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/compile-2/"/>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/compile-2/</url>
    
    <content type="html"><![CDATA[<h1 id="lexical-analysis-词法分析-1"><a class="markdownIt-Anchor" href="#lexical-analysis-词法分析-1"></a> Lexical Analysis 词法分析-1</h1><h2 id="词法分析器的作用"><a class="markdownIt-Anchor" href="#词法分析器的作用"></a> 词法分析器的作用</h2><ul><li><strong>Lexical Analyzer (词法分析)</strong> 是编译器的第一阶段，它<code>逐字符</code>读取源程序，将它们组成词素，生成并输出一个词法单元(token)序列，每个词法单元对应于一个词素。<ul><li>这个词法单元序列被输出到语法分析器进行语法分析。</li><li>词法分析器通常还要和符号表进行交互。当词法分析器发现了一个标识符的词素时，它要将这个词素添加到符号表中。</li></ul></li><li>通常，词法分析器不会一次返回词法单元列表，而是<code>在解析器向其请求时</code>返回</li><li><strong>词法分析器 = 扫描+词法分析</strong><ul><li><strong>扫描阶段</strong>主要负责完成一些不需要生成词法单元的简单处理，比如删除注释和将多个连续的空白字符压缩成一个字符。<br /><img src="1.png" alt="Scanner" /></li><li><strong>词法分析</strong>阶段是较为复杂的部分，它处理扫描阶段的输出并生成词法单元。<ul><li>将源程序作为字符文件读取</li><li>将文件划分为单词(token)<ul><li><strong>Token（单词）</strong>： 表示源程序中的一个信息单元</li><li>例如：keywords（关键词/保留字）, identifiers（标识符）, arithmetic symbols, multicharacter symbols(&gt;=, &lt;&gt;)</li></ul></li></ul></li></ul></li><li>重点：什么是单词？什么是合法单词？<ul><li>正则表达式中标记的说明和识别</li><li>如何识别单词 - 有限自动机</li><li>用C或LEX编程的词法分析器的设计</li></ul></li></ul><p><img src="2.png" alt="词法分析器与语法分析器的交互" /></p><hr /><h3 id="词法分析及语法分析"><a class="markdownIt-Anchor" href="#词法分析及语法分析"></a> 词法分析及语法分析</h3><ul><li>把编译过程的分析部分划分为词法分析和语法分析阶段有如下几个原因：<ul><li>词法分析和句法分析的分离提供了一个更简单的概念模型<ul><li>高内聚、低耦合、并行实现</li></ul></li><li>提高编译器效率（I/O 技术可以增强词法分析）</li><li>增强编译器的<strong>可移植性(Portability)</strong>。输入设备相关的特殊性可以被限制在词法分析器中。</li></ul></li></ul><hr /><h3 id="词法单元-模式和词素"><a class="markdownIt-Anchor" href="#词法单元-模式和词素"></a> 词法单元、模式和词素</h3><ul><li>Token（词法单元）<ul><li>由一个词法单元名和一个可选的属性值组成</li><li>词法单元名是一个表示某种词法单位的抽象符号<ul><li>例如：&lt;Identifier&gt;, &lt;number&gt;, etc.<br /><img src="5.png" alt="词法单元可分为几类" /></li></ul></li></ul></li><li>Pattern（模式）<ul><li>描述了一个词法单元的词素可能具有的形式。<ul><li>当词法单元是一个关键字时，它的模式就是组成这个关键字的字符序列。</li></ul></li></ul></li><li>Lexeme（词素）<ul><li>源程序中的一个字符序列，它和某个词法单元的模式匹配，并被词法分析器识别为该词法单元的一个实例。</li></ul></li></ul><hr /><h3 id="词法单元的属性"><a class="markdownIt-Anchor" href="#词法单元的属性"></a> 词法单元的属性</h3><p><img src="3.png" alt="词法单元的例子" /></p><blockquote><p>词法单元是扫描中的逻辑单元；词素是词法单元中的一个实例</p></blockquote><ul><li><p>由于一个词法单元可以代表多个词素，因此应该为该特定词素保留其他信息。此附加信息称为词法单元的<strong>属性(attribute)</strong></p></li><li><p>假设一个词法单元至多有一个相关的属性值，当然这个属性值可能是一个组合了多种信息的结构化数据。</p><ul><li>一般来说，和一个标识符有关的信息 —— 例如它的词素、类型、它第一次出现的位置（在发出一个有关该标识符的错误消息时需要使用这个信息）—— 都保存在<code>符号表</code>中。</li><li>一个标识符的属性值是一个指向符号表中该标识符对应条目的<code>指针</code>。</li></ul></li><li><p><code>词法单元类型及其属性值唯一标识词素</code></p></li><li><p><strong>Regular expressions(正则表达式）</strong> 广泛用于指定模式。</p></li></ul><p><img src="4.png" alt="属性的例子" /></p><ul><li>词法单元记录的例子：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs C">Typedef  <span class="hljs-class"><span class="hljs-keyword">struct</span> </span><br><span class="hljs-class">&#123;</span>  <br>    TokenType tokenval;<br>    <span class="hljs-type">char</span> *stringval;<br>    <span class="hljs-type">int</span> numval;<br>&#125; TokenRecord<br></code></pre></td></tr></table></figure><ul><li>一种更常见的安排是：扫描器只返回词法单元的值，并将其他属性放入变量中（例如在LEX和YACC中）。</li><li>输入字符字符串保存在 <strong>缓冲区(buffer)</strong> 中，或由系统输入设备提供。</li></ul><hr /><h2 id="输入缓冲"><a class="markdownIt-Anchor" href="#输入缓冲"></a> 输入缓冲</h2><h3 id="带哨兵的缓冲iobuffered-io-with-sentinels"><a class="markdownIt-Anchor" href="#带哨兵的缓冲iobuffered-io-with-sentinels"></a> 带哨兵的缓冲I/O(Buffered I/O with Sentinels)</h3><p><img src="6.png" alt="" /></p><ul><li>lexemeBegin指针：该指针指向当前词素的开始处。当前我们正试图确定这个词素的结尾</li><li>forward指针：它一直向前扫描，直到发现某个模式被匹配为止</li><li>“哨兵”（sentinel）字符：<ul><li>可以把对缓冲区末端的测试和对当前字符的测试合二为一</li><li>哨兵字符必须是一个不会在源程序中出现的特殊字符，一个自然的选择就是字符eof</li></ul></li></ul><p><img src="7.png" alt="带有哨兵标记的forward指针移动算法" /></p><hr /><p><img src="8.png" alt="逐字符I/O(Character-at-a-time I/O) " /></p><hr /><h2 id="词法单元的规约"><a class="markdownIt-Anchor" href="#词法单元的规约"></a> 词法单元的规约</h2><h3 id="串和语言"><a class="markdownIt-Anchor" href="#串和语言"></a> 串和语言</h3><ul><li><p><strong>字母表(Alphabet)</strong>：是一个有限的符号集合</p><ul><li>符号的典型例子包括字母、数位和标点符号</li><li>ASCII是字母表的一个重要例子</li></ul></li><li><p><strong>串(String)</strong></p><ul><li>某个字母表上的一个串是该字母表中符号的一个有穷序列。</li><li>在语言理论中，术语<code>“句子”</code>和<code>“字”</code>常常被当作<code>“串”</code>的同义词</li><li>串s的长度，通常记作<code>|s|</code>，是指s中符号出现的次数</li><li><strong>空串（empty string）</strong> 是长度为0的串，用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">∈</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span>表示。</li></ul></li><li><p>串的各部分术语：示例串 S 为 banana</p><ul><li>串s的<strong>前缀（prefix）</strong> 是从s的尾部删除0个或多个符号后得到的串。<ul><li>ban、banana 和 ∈ 是 banana 的前缀</li></ul></li><li>串s的<strong>后缀（suffix）</strong> 是从s的开始处删除0个或多个符号后得到的串<ul><li>nana、banana 和 ∈ 是 banana 的后缀</li></ul></li><li>串s的<strong>真（true）</strong> 前缀、真后缀、真子串分别是 s 的既不等于 ∈，也不等于 s 本身的前缀、后缀和子串</li><li>串s的<strong>子序列（subsequence）</strong> 是从s中删除0个或多个符号后得到的串，这些被删除的符号可能不相邻<ul><li>baan是banana的一个子序列</li></ul></li></ul></li><li><p>串的运算符</p><ul><li><strong>连接（concatenation）</strong>：如果 x 和 y 是串，那么 x 和 y 的 <strong>连接（记作xy）</strong> 是把 y 附加到 x 后面而形成的串<ul><li>空串是连接运算的单位元，也就是说，对于任何串 s 都有， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>∈</mo><mo>=</mo><mo>∈</mo><mi>s</mi><mo>=</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">s∈=∈s=s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span></li></ul></li><li>如果把两个串的连接看成是这两个串的“乘积”，我们可以定义串的“指数”运算：<ul><li>定义 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>s</mi><mn>0</mn></msup><mo>=</mo><mo>∈</mo></mrow><annotation encoding="application/x-tex">s^0 = ∈</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span> ，并且对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>&gt;</mo><mn>0</mn><mi mathvariant="normal">，</mi><msup><mi>s</mi><mi>i</mi></msup><mo>=</mo><msup><mi>s</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup><mi>s</mi></mrow><annotation encoding="application/x-tex">i&gt;0，s^i = s^{i-1}s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord mathdefault">s</span></span></span></span></li><li>由此可知 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>s</mi><mn>1</mn></msup><mo>=</mo><mi>s</mi><mo separator="true">,</mo><msup><mi>s</mi><mn>2</mn></msup><mo>=</mo><mi>s</mi><mi>s</mi><mo separator="true">,</mo><msup><mi>s</mi><mn>3</mn></msup><mo>=</mo><mi>s</mi><mi>s</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">s^1=s, s^2=ss, s^3=sss</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span></span></span></span> ，以此类推</li></ul></li></ul></li></ul><hr /><ul><li><strong>语言(Language)</strong>：一个语言 L 就是是某个给定字母表上一个任意的可数的串集合。<ul><li>根据这个定义，像空集 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi></mrow><annotation encoding="application/x-tex">\Theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Θ</span></span></span></span> 和仅包含空串的集合<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">{∈}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mrel">∈</span></span></span></span></span>都是语言</li><li>所有可能的标识符集都是一种语言</li></ul></li></ul><p><img src="9.png" alt="语言的示例" /></p><hr /><h3 id="语言上的运算"><a class="markdownIt-Anchor" href="#语言上的运算"></a> 语言上的运算</h3><p><img src="10.png" alt="语言上的运算的定义" /></p><p><img src="11.png" alt="语言上的运算的示例" /></p><hr /><h3 id="正则表达式regular-expressions"><a class="markdownIt-Anchor" href="#正则表达式regular-expressions"></a> 正则表达式(Regular Expressions)</h3><ul><li><p><strong>正则表达式</strong> 是从字母表中构造符号（字符串）序列的一组<code>规则/技术</code></p><ul><li>正则表达式可以描述所有通过对某个字母表上的符号应用<code>并、连接和闭包</code>这些运算符而得到的<code>语言</code></li></ul><blockquote><p>令 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span> 为字母表，r 是一个正则表达式，那么 L(r) 就是以规则 r 为特征的语言</p></blockquote></li><li><p>正则表达式可以由较小的正则表达式按照如下规则递归地构建。</p><ul><li>每个正则表达式 r 表示一个语言 L(r)，这个语言也是根据 r 的子表达式所表示的语言递归地定义的</li></ul></li><li><p>下面的规则定义了某个字母表Σ上的正则表达式以及这些表达式所表示的语言：</p><ul><li>归纳基础<ul><li>∈ 是一个正则表达式， L(∈) = {∈} ，即该语言只包含空串。</li><li>如果 a 是 Σ 上的一个符号，那么 a 是一个正则表达式，并且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">L(a) = {a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span></span></span><ul><li>也就是说，这个语言仅包含一个长度为 1 的符号串 a</li></ul></li></ul></li><li>归纳步骤：假定 r 和 s 都是正则表达式，分别表示语言 L(r) 和 L(s)，那么：<ul><li><strong>(r) | (s)</strong> 是一个正则表达式，表示语言 L(r) <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∪</mo></mrow><annotation encoding="application/x-tex">\cup</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord">∪</span></span></span></span> L(s)</li><li><strong>(r)(s)</strong> 是一个正则表达式，表示语言 <strong>L(r) L(s)</strong></li><li>(r)<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow></mrow><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span> 是一个正则表达式，表示语言 (L(r))<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow></mrow><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></li><li><strong>(r)</strong> 是一个正则表达式，表示语言 <strong>L(r)</strong></li></ul></li><li><code>所有这些都是左关联的。优先规则允许删除括号。</code></li></ul></li></ul><p><img src="12.png" alt="字母表上的正则表达式" /></p><ul><li><strong>?</strong> 表示出现 0 次或 1 次</li></ul><p><img src="13.png" alt="正则表达式示例" /></p><p><img src="14.png" alt="正则表达式的代数定律" /></p><hr /><h3 id="正则定义regular-definitions"><a class="markdownIt-Anchor" href="#正则定义regular-definitions"></a> 正则定义(Regular Definitions)</h3><ul><li>有些语言的正则表达式可能非常复杂，为方便表示，我们可能希望给某些正则表达式命名，并在之后的正则表达式中用这些名称作为符号来定义其他正则表达式</li><li>一个 <strong>正则定义(regular definition)</strong> 是具有如下形式的定义序列<br /><img src="15.png" alt="正则定义基本形式" /></li></ul><hr /><h3 id="正则表达式的扩展"><a class="markdownIt-Anchor" href="#正则表达式的扩展"></a> 正则表达式的扩展</h3><p><img src="16.png" alt="正则表达式的扩展" /></p><hr /><h2 id="复习"><a class="markdownIt-Anchor" href="#复习"></a> 复习</h2><ul><li>Lexical analyzer (scanner)   词法分析器</li><li>Syntax analyzer (parser)   语法分析器</li><li>Token 单词</li><li>Attribute 属性</li><li>Regular expression 正规/正则表达式</li><li>Regular definition 正规定义</li></ul><hr /><h2 id="练习题"><a class="markdownIt-Anchor" href="#练习题"></a> 练习题</h2><h3 id="31"><a class="markdownIt-Anchor" href="#31"></a> 3.1</h3><p>描述下列正规式（正则）定义的语言（请用汉语直白地描述该语言）</p><ol><li>0 (0 | 1) * 0</li><li>(( e | 0 ) 1*)*</li><li>(0|1)*0(0|1)(0|1)</li><li>0*10*10*10*</li><li>(00 | 11)*((01 | 10)(00 | 11)*(01 | 10)(00 | 11)*)*</li></ol><hr /><p><strong>答：</strong></p><ol><li>以 0 开始并以 0 结束的 0 和 1 组成的数串。</li><li>0 和 1 组成的数串。</li><li>倒数第三个数字为 0 的 0 和 1 组成的数串。</li><li>含且只含三个 1 的 0 和 1 组成的数串。</li><li>含有偶数个 0 和 1 的 0 和 1 组成的数串。</li></ol><hr /><h3 id="32"><a class="markdownIt-Anchor" href="#32"></a> 3.2</h3><p>为下列语言写出正规定义(或正规式)</p><ol><li>包含五个元音，且按顺序排列的所有字母串（RE）</li><li>字母按字典升序排列的所有字母串（RE）</li><li>以/*开始，*/结束的注释，中间不能包含*/，除非包含在&quot;和&quot;中（RE）</li><li>不包含重复数字的数字串（正规定义）</li><li>包含至多一个重复数字的数字串（正规定义）</li><li>包含偶数个0和奇数个1的0、1串 （正规定义）</li></ol><hr /><p><strong>答：</strong></p><ol><li><p>[bcdfghjklmnpqrstvwxyz]* a ([bcdfghjklmnpqrstvwxyz] | a)* e ([bcdfghjklmnpqrstvwxyz] | e)* i ([bcdfghjklmnpqrstvwxyz] | i)* o ([bcdfghjklmnpqrstvwxyz] | o)* u ([bcdfghjklmnpqrstvwxyz] | u)*</p></li><li><p>A*B*C*…Z*a*b*c*…z*</p></li><li><p>\/\*   ( “.*”|\*+[^/]*|[^*&quot;]*)*        \*\/</p></li><li><p>正则规定如下：</p><ul><li>d0 -&gt; 0?</li><li>d1 -&gt; 1?</li><li>d2 -&gt; 2?</li><li>d3 -&gt; 3?</li><li>d4 -&gt; 4?</li><li>d5 -&gt; 5?</li><li>d6 -&gt; 6?</li><li>d7 -&gt; 7?</li><li>d8 -&gt; 8?</li><li>d9 -&gt; 9?</li><li>d10 -&gt; d0d1d2d3d4d5d6d7d8d9 | d0d1d2d3d4d5d6d7d9d8 | …</li><li>d10 后有10！个表达式</li></ul></li><li><p>不会</p></li><li><p>正则规定如下：</p><ul><li>e_0_e_1 -&gt; (00|11)((01|10)(00|11)(01|10)(00|11))</li><li>e_0_o_1 -&gt; 1e_0_e_1|0(00|11)*(01|10)e_0_e_1</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>专业课</category>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
      <tag>正则表达式</tag>
      
      <tag>词法分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL｜基本操作</title>
    <link href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/db-3/"/>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/db-3/</url>
    
    <content type="html"><![CDATA[<h2 id="sql"><a class="markdownIt-Anchor" href="#sql"></a> SQL</h2><h3 id="sql-是什么"><a class="markdownIt-Anchor" href="#sql-是什么"></a> SQL 是什么？</h3><ul><li><p>SQL 有四个能力：</p><ul><li><strong>数据定义语言(Data definition language, DDL)</strong>：SQL可以用来<code>定义、删除</code>数据库模式</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> instructor <br>( ID         <span class="hljs-type">char</span>(<span class="hljs-number">5</span>),<br>  name       <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>  dept_name  <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>  salary     <span class="hljs-type">numeric</span>(<span class="hljs-number">8</span>,<span class="hljs-number">2</span>)<br>  <span class="hljs-keyword">PRIMARY</span> KEY (ID)<br>)<br></code></pre></td></tr></table></figure><ul><li><strong>查询语言(Query language)</strong>：SQL可以用来<code>检索</code>数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ID<br><span class="hljs-keyword">FROM</span>    instructor<br><span class="hljs-keyword">WHERE</span>  salary<span class="hljs-operator">&gt;</span><span class="hljs-number">65000</span>;     <br></code></pre></td></tr></table></figure><ul><li><strong>数据操纵语言(Data manipulation language)</strong>：SQL可以用来完成数据的<code>增删改操作</code>，例如向数据表中删除一条记录和插入一条记录</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> instructor<br><span class="hljs-keyword">where</span> dept_name <span class="hljs-operator">=</span> ‘History’;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> instructor  <span class="hljs-keyword">values</span> (‘<span class="hljs-number">10211</span>’, ’Smith’, ’Biology’, <span class="hljs-number">66000</span>);<br></code></pre></td></tr></table></figure><ul><li><strong>数据控制语言(Data Control language)</strong>：SQL可以用来控制访问数据的<code>权限</code>以及数据的<code>完整性约束</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">PRIMARY</span> KEY (ID),     <span class="hljs-keyword">CHECK</span> (name <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>)<br><span class="hljs-keyword">grant</span> <span class="hljs-keyword">select</span> <span class="hljs-keyword">on</span> instructor <span class="hljs-keyword">to</span> U1,U2<br></code></pre></td></tr></table></figure></li><li><p>SQL是非过程语言，即只需告诉要什么，而不需告诉如何得到。</p></li></ul><hr /><h3 id="sql-数据定义"><a class="markdownIt-Anchor" href="#sql-数据定义"></a> SQL 数据定义</h3><ul><li>数据库中的关系集必须通过 DDL 向系统指定。DDL 不仅允许指定一组关系，还允许指定有关每个关系的信息，包括：<ul><li>定义数据库中每个关系的<code>模式(schema)</code>（关系表结构）</li><li>定义每个属性的<code>值域(domain)</code>（比如年龄为<code>short int</code>，name 为 <code>varchar(10)</code>）</li><li>定义完整性约束（例如年龄取值在0~150之间，成绩在0-100之间）</li><li>定义每个关系的<code>索引(index)</code>（加快查询速度的一种技术）</li><li>定义每个关系的安全和权限</li><li>定义每个关系在磁盘上的物理存储结构（例如每个关系对应的文件结构，每个记录的存储方式）</li></ul></li></ul><hr /><h4 id="基本数据类型"><a class="markdownIt-Anchor" href="#基本数据类型"></a> 基本数据类型</h4><ul><li>SQL 标准支持多种固有类型，包括：<ul><li>char(n)：固定长度的字符串，用户指定长度 n</li><li>varchar(n)：可变长度的字符串，用户指定最大长度 n</li><li>int：整数类型</li><li>smallint：小整数类型</li><li>numeric(p, d)：定点数，精度由用户指定<ul><li>这个数有 p 位数字（加上一个符号位），其中 d 位数字在小数点右边</li></ul></li><li>real, double precision：浮点数与双精度浮点数</li><li>float(n)：精度至少为 n 位的浮点数</li></ul></li></ul><hr /><h4 id="基本模式定义"><a class="markdownIt-Anchor" href="#基本模式定义"></a> 基本模式定义</h4><ul><li>创建表结构<ul><li>SQL 关系是用 <code>create table</code> 命令定义的</li><li><code>create table</code> 命令的通用形式是：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> r (A1 D1, A2 D2, ..., An Dn,<br>      (integrity<span class="hljs-operator">-</span>constraint_1),<br>            ...,<br>            (integrity<span class="hljs-operator">-</span>constraint_k))<br></code></pre></td></tr></table></figure><ul><li>r 是关系名</li><li>每个 A_i 是关系 r 模式中的一个属性名</li><li>D_i 是属性 A_i 的值域，指定了属性 A_i 的类型以及可选的约束</li></ul></li></ul><hr /><ul><li>SQL 支持许多不同的<strong>完整性约束(Integrity Constraints)</strong><ul><li><strong>Not null</strong>：非空</li><li><strong>primary key (A1, …, An )</strong>：表示属性集合(A1, …, An )构成<code>主码</code>，自动保证<code>非空和唯一</code></li><li><strong>foreign key (Am, …, An ) references r</strong>：属性集合(A1, …, An )构成<code>外码</code>，这些属性是<code>关系r的主码</code></li><li><strong>check §</strong>: P 是一个<code>谓词表达式</code>，根据数据库中对数据的要求，程序员写这个谓词表达式，例如 <code>credit&gt;0 and credit&lt;4</code></li></ul></li></ul><hr /><ul><li>删库跑路(Drop and Alter Table Constructs)<ul><li><strong>drop table</strong> student<ul><li>表示删除了 studen t<code>表以及表中所有的数据</code></li></ul></li><li><strong>delete from</strong> student<ul><li>删除表的所有内容，但<code>保留表</code></li></ul></li></ul><blockquote><p><strong>Drop table</strong> r 和 <strong>delete from</strong> table r 本质不同，drop 是彻底删除了表以及表中的数据，delete 只是删除了表中的数据记录，表还是存在着，delete 可以删除部分满足某个条件的记录</p></blockquote><ul><li><strong>alter table</strong>：修改表的模式，即修改表的结构<ul><li><strong>alter table r add A D</strong>：给表 r <code>增加</code>一列，命名为A，值域为D</li><li><strong>alter table r drop A</strong>：<code>去掉</code>表 r 中的A列</li></ul></li></ul></li></ul><hr /><h3 id="sql-查询的基本结构"><a class="markdownIt-Anchor" href="#sql-查询的基本结构"></a> SQL 查询的基本结构</h3><h4 id="基本结构"><a class="markdownIt-Anchor" href="#基本结构"></a> 基本结构</h4><ul><li>SQL 数据操作语言(data-manipulation language, DML) 提供了查询信息以及插入、删除和更新元组的功能</li><li>典型的 SQL 查询的格式为：</li></ul>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> A1, A2, ..., An<br><span class="hljs-keyword">from</span> r1, r2, ..., rm<br><span class="hljs-keyword">where</span> P<br></code></pre></td></tr></table></figure><ul><li>A_i 表示属性、r_i 表示关系、P 是谓词</li></ul><blockquote><p><strong>sql 查询的结果依然是一个关系</strong></p></blockquote><hr /><h4 id="select-子句"><a class="markdownIt-Anchor" href="#select-子句"></a> Select 子句</h4><ul><li>Select 子句列出了查询结果中所需的属性，对应于关系代数的投影运算</li><li><code>注意</code>：SQL 名称不区分大小写</li><li>数据表中每一个记录都是唯一的，但是当查询只关注某些列时，查询结果中的记录可能不唯一，会出现重复数据<ul><li>SQL 提供了关键字 <strong>distinct</strong>，在查询结果中<code>去掉重复</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> dept_name<br><span class="hljs-keyword">from</span> instructor<br></code></pre></td></tr></table></figure><ul><li>也可以使用 <strong>all</strong> 关键字，指定不删除重复项</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">all</span> dept_name<br><span class="hljs-keyword">from</span> instructor<br></code></pre></td></tr></table></figure><ul><li>使用 <code>*</code> 表示所有属性</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> instructor<br></code></pre></td></tr></table></figure><ul><li>Select 子句可以<code>包含涉及运算</code> +、–、*和 /的算术表达式，以及<code>对元组的常量或属性进行运算</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ID, name, salary<span class="hljs-operator">/</span><span class="hljs-number">12</span><br><span class="hljs-keyword">from</span> instructor<br></code></pre></td></tr></table></figure><blockquote><p><code>select salary/12</code> 中可以对表中的属性进行数学计算，查询结果是属性计算后的结果，<strong>原数据表中该属性的值不变</strong>，意思是原表中的 salary 还是年薪，但查询结果显示的是月薪，即<code>salary/12</code></p></blockquote></li></ul><hr /><h4 id="from-子句"><a class="markdownIt-Anchor" href="#from-子句"></a> From 子句</h4><ul><li>From 子句列出了查询中涉及的关系<ul><li>对应于关系代数的<code>笛卡尔积</code>运算</li></ul><blockquote><p>两个关系上的<strong>笛卡尔积</strong>：将第一个关系的<code>每个元组</code>与第二个关系的<code>所有元组</code>进行连接</p></blockquote></li></ul><hr /><h4 id="自然连接natural-join"><a class="markdownIt-Anchor" href="#自然连接natural-join"></a> 自然连接(Natural Join)</h4><ul><li><p><strong>Joins</strong></p><ul><li>Join 是 SQL 常用的操作，用于查询数据来自多张数据表时</li></ul></li><li><p><strong>Natural Join</strong></p><ul><li>自然连接运算作用于两个关系，并产生一个关系作为结果</li><li>不同于两个关系上的笛卡尔积，自然链接只考虑那些在两个关系模式中<code>都出现的属性</code>上<code>取值相同</code>的元组对</li><li>举例：列出教师的姓名以及他们所教授的课程的课程 ID。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 不使用 <span class="hljs-keyword">join</span><br><span class="hljs-keyword">select</span> name, course_id<br><span class="hljs-keyword">from</span> instructor, teaches<br><span class="hljs-keyword">where</span> instructor.ID <span class="hljs-operator">=</span> teaches.ID;   # 实际上是外键约束<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 使用 <span class="hljs-keyword">join</span><br><span class="hljs-keyword">select</span> name, course_id<br><span class="hljs-keyword">from</span> instructor <span class="hljs-keyword">natural</span> <span class="hljs-keyword">join</span> teaches;<br></code></pre></td></tr></table></figure></li><li><p>在使用 Natural join 时需要<strong>注意</strong>：<code>同名的不相关属性</code>被错误地做相等判断</p><ul><li>理解该例子：列出教师的姓名以及他们教授的课程名称<ul><li>正确做法-1</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> name, title<br><span class="hljs-keyword">from</span> instructor <span class="hljs-keyword">natural</span> <span class="hljs-keyword">join</span> teaches, course  # 先做自然连接，再做笛卡尔积<br><span class="hljs-keyword">where</span> teaches.course_id <span class="hljs-operator">=</span> course.course_id;<br></code></pre></td></tr></table></figure><ul><li>正确做法-2</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> name, title<br><span class="hljs-keyword">from</span> (instructor <span class="hljs-keyword">natural</span> <span class="hljs-keyword">join</span> teaches)                                             <span class="hljs-keyword">join</span> course <span class="hljs-keyword">using</span>(course_id);   # 有条件的 <span class="hljs-keyword">join</span><br></code></pre></td></tr></table></figure><blockquote><p>为了发扬自然连接的优点，同时避免不必要的相等属性带来的危险，SQL 提供了一种自然连接的构造形式，允许用户来指定需要哪些列相等</p></blockquote><ul><li>错误做法</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> name, title<br><span class="hljs-keyword">from</span> instructor <span class="hljs-keyword">natural</span> <span class="hljs-keyword">join</span> teaches <span class="hljs-keyword">natural</span> <span class="hljs-keyword">join</span> course;<br># 该做法要求 course.dept_name <span class="hljs-operator">=</span> instructor.dept_name，如果老师教授非本专业课程则会出错<br></code></pre></td></tr></table></figure></li></ul></li></ul><hr /><h3 id="附加的基本运算"><a class="markdownIt-Anchor" href="#附加的基本运算"></a> 附加的基本运算</h3><h4 id="重命名操作rename-operation"><a class="markdownIt-Anchor" href="#重命名操作rename-operation"></a> 重命名操作(Rename Operation)</h4><ul><li>SQL 允许使用 <strong>as 子句</strong>重命名<code>关系</code>和<code>属性</code>：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">old</span><span class="hljs-operator">-</span>name <span class="hljs-keyword">as</span> <span class="hljs-keyword">new</span><span class="hljs-operator">-</span>name<br></code></pre></td></tr></table></figure><ul><li>as 子句既可以出现在 select 子句中，也可以出现在 from 子句中</li><li>as 关键字是可选的，<code>instructor as T</code> 和 <code>instructor T</code> 等价</li></ul><hr /><h4 id="字符串运算"><a class="markdownIt-Anchor" href="#字符串运算"></a> 字符串运算</h4><ul><li><p>SQL 使用一对单引号来标示字符串，如果单引号是字符串的组成部分，那就用两个单引号字符表示</p></li><li><p>SQL 包括一个字符串匹配运算符，用于比较字符串。 在字符串上可以使用 <strong>like</strong> 操作符实现模式匹配，用两个特殊字符来描述模式</p><ul><li>百分号(%)：匹配任意子串</li><li>下划线(_)：匹配任意一个字符</li><li>使用 <strong>escape</strong> 关键字定义转义字符</li><li>示例：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> name<br><span class="hljs-keyword">from</span> instructor<br><span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%dar%&#x27;</span> ;<br># 查找姓名包含子字符串&quot;dar&quot;的所有教师的姓名。<br><br><span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;100 \%&#x27;</span>  <span class="hljs-keyword">escape</span>  <span class="hljs-string">&#x27;\&#x27;</span> <br># 匹配字符串&quot;100 %&quot;<br></code></pre></td></tr></table></figure><ul><li>模式区分大小写</li></ul></li><li><p>SQL 支持各种字符串操作</p><ul><li>串联：使用&quot;||&quot;</li><li>大小写转换：upper(s)、lower(s)</li><li>查找字符串长度、提取子字符串等</li></ul></li></ul><hr /><h4 id="排列元组的显示次序"><a class="markdownIt-Anchor" href="#排列元组的显示次序"></a> 排列元组的显示次序</h4><ul><li>SQL提供了查询结果有序输出的关键字 <strong>Order by</strong><ul><li>by 后面写排序所基于的属性</li></ul></li><li>order by 子句默认使用升序<ul><li>为了说明顺序，可以用 <strong>desc</strong> 表示降序，或用 <strong>asc</strong> 表示升序</li><li>排序可以在多个属性上进行</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> instructor<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> salary <span class="hljs-keyword">desc</span>, name <span class="hljs-keyword">asc</span>;<br></code></pre></td></tr></table></figure></li></ul><hr /><h4 id="where-子句谓词"><a class="markdownIt-Anchor" href="#where-子句谓词"></a> where 子句谓词</h4><ul><li><strong>between</strong> 比较运算符说明一个值是小于或等于某个值，同时大于或等于另一个值</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> name<br><span class="hljs-keyword">from</span> instructor<br><span class="hljs-keyword">where</span> salary <span class="hljs-keyword">between</span> <span class="hljs-number">90000</span> <span class="hljs-keyword">and</span> <span class="hljs-number">100000</span><br></code></pre></td></tr></table></figure><ul><li>比较结果可以使用逻辑连接词进行组合 <strong>and, or, not</strong></li><li>SQL 允许用记号 (v_1, v_2, …, v_n) 来表示一个分量值为 v_1, v_2, …, v_n 的 n 维元组</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> name, course_id<br><span class="hljs-keyword">from</span> instructor, teaches<br><span class="hljs-keyword">where</span> (instructor.ID, dept_name) <span class="hljs-operator">=</span> (teaches.ID, ’Biology’);<br></code></pre></td></tr></table></figure><hr /><h3 id="集合运算"><a class="markdownIt-Anchor" href="#集合运算"></a> 集合运算</h3><ul><li>SQL 作用在关系上的 <strong>union、intersect、except</strong> 运算对应于数学集合论中的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∪</mo><mi mathvariant="normal">、</mi><mo>∩</mo><mi mathvariant="normal">、</mi><mo>−</mo></mrow><annotation encoding="application/x-tex">\cup、\cap、-</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord">∪</span><span class="mord cjk_fallback">、</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">、</span><span class="mord">−</span></span></span></span> 运算<ul><li>上述每个操作都会<code>自动消除重复项</code>，要保留所有重复项，请使用相应的多集版本：<strong>union all, intersect all, except all</strong></li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><br>#查找 <span class="hljs-number">2009</span> 年秋季或 <span class="hljs-number">2010</span> 年春季开设的课程<br>(<span class="hljs-keyword">select</span> course_id <span class="hljs-keyword">from</span> section <span class="hljs-keyword">where</span> sem <span class="hljs-operator">=</span> ‘Fall’ <span class="hljs-keyword">and</span> <span class="hljs-keyword">year</span> <span class="hljs-operator">=</span> <span class="hljs-number">2009</span>)<br><span class="hljs-keyword">union</span><br>(<span class="hljs-keyword">select</span> course_id <span class="hljs-keyword">from</span> section <span class="hljs-keyword">where</span> sem <span class="hljs-operator">=</span> ‘Spring’ <span class="hljs-keyword">and</span> <span class="hljs-keyword">year</span> <span class="hljs-operator">=</span> <span class="hljs-number">2010</span>)<br><br>#查找 <span class="hljs-number">2009</span> 年秋季和 <span class="hljs-number">2010</span> 年春季开设的课程<br>(<span class="hljs-keyword">select</span> course_id <span class="hljs-keyword">from</span> section <span class="hljs-keyword">where</span> sem <span class="hljs-operator">=</span> ‘Fall’ <span class="hljs-keyword">and</span> <span class="hljs-keyword">year</span> <span class="hljs-operator">=</span> <span class="hljs-number">2009</span>)<br><span class="hljs-keyword">intersect</span><br>(<span class="hljs-keyword">select</span> course_id <span class="hljs-keyword">from</span> section <span class="hljs-keyword">where</span> sem <span class="hljs-operator">=</span> ‘Spring’ <span class="hljs-keyword">and</span> <span class="hljs-keyword">year</span> <span class="hljs-operator">=</span> <span class="hljs-number">2010</span>)<br><br>#查找 <span class="hljs-number">2009</span> 年秋季开设但未在 <span class="hljs-number">2010</span> 年春季开设的课程<br>(<span class="hljs-keyword">select</span> course_id <span class="hljs-keyword">from</span> section <span class="hljs-keyword">where</span> sem <span class="hljs-operator">=</span> ‘Fall’ <span class="hljs-keyword">and</span> <span class="hljs-keyword">year</span> <span class="hljs-operator">=</span> <span class="hljs-number">2009</span>)<br><span class="hljs-keyword">except</span><br>(<span class="hljs-keyword">select</span> course_id <span class="hljs-keyword">from</span> section <span class="hljs-keyword">where</span> sem <span class="hljs-operator">=</span> ‘Spring’ <span class="hljs-keyword">and</span> <span class="hljs-keyword">year</span> <span class="hljs-operator">=</span> <span class="hljs-number">2010</span>)<br><br></code></pre></td></tr></table></figure><hr /><h3 id="空值null-values"><a class="markdownIt-Anchor" href="#空值null-values"></a> 空值(Null Values)</h3><ul><li>NULL是一个特殊的属性取值，表明某个记录的该属性取值不确定，不知道或不存在</li><li>任何涉及 null 的<code>算术</code>表达式的结果都是 null</li><li>任何涉及 null 的<code>比较运算</code>的结果都是 <code>unknown</code></li><li>谓词为 null 可用于<code>检查空值</code><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> name<br><span class="hljs-keyword">from</span> instructor<br><span class="hljs-keyword">where</span> salary <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure></li></ul><hr /><ul><li>使用真值为 <code>unknown</code> 的三值逻辑：<ul><li>OR:<ul><li>(unknown or true)   = true</li><li>(unknown or false)  = unknown</li><li>(unknown or unknown) = unknown</li></ul></li><li>AND:<ul><li>(true and unknown)  = unknown</li><li>(false and unknown) = false</li><li>(unknown and unknown) = unknown</li></ul></li><li>NOT:<ul><li>(not unknown) = unknown</li></ul></li><li>如果谓词 P 的值为 unknown, “P is unknown” 为 true</li></ul></li><li>如果 where 子句谓词的计算结果为 unknown，则将其视为 false</li></ul><hr /><h3 id="聚集函数aggregate-functions"><a class="markdownIt-Anchor" href="#聚集函数aggregate-functions"></a> 聚集函数(Aggregate Functions)</h3><h4 id="基本聚集"><a class="markdownIt-Anchor" href="#基本聚集"></a> 基本聚集</h4><ul><li><strong>聚集函数</strong>是以值的一个集合（集或多重集）为输入、返回单个值的函数。SQL 提供了五个固有聚集函数：<ul><li>avg(attr)：返回平均 attr 值</li><li>min(attr)：返回最小 attr 值</li><li>max(attr)：返回最大 attr 值</li><li>sum(attr)：返回 attr 中值的总和</li><li>count(attr)：返回 attr 的值数</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查找计算机科学系教师的平均工资</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span> (salary)<br><span class="hljs-keyword">from</span> instructor<br><span class="hljs-keyword">where</span> dept_name<span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Comp. Sci.&#x27;</span>;<br><br><span class="hljs-comment">-- 查找在 2010 年春季学期教授课程的教师总数</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span> (<span class="hljs-keyword">distinct</span> ID)<br><span class="hljs-keyword">from</span> teaches<br><span class="hljs-keyword">where</span> semester <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Spring&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">year</span> <span class="hljs-operator">=</span> <span class="hljs-number">2010</span><br><br><span class="hljs-comment">-- 查找课程中的元组数</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span> (<span class="hljs-operator">*</span>)<br><span class="hljs-keyword">from</span> course;<br></code></pre></td></tr></table></figure><hr /><h4 id="分组聚集group-by"><a class="markdownIt-Anchor" href="#分组聚集group-by"></a> 分组聚集：Group By</h4><ul><li>在 SQL 中使用 <strong>group by</strong> 子句将聚集函数作用到一组元组集上</li><li>group by 子句给出一个或多个属性用于构造分组，在 group by 子句中的所有属性上取值相同的元组被分在一个组中</li><li>示例：查找每个系的平均工资</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> dept_name, <span class="hljs-built_in">avg</span> (salary)<br><span class="hljs-keyword">from</span> instructor<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> dept_name;<br></code></pre></td></tr></table></figure><p><img src="group.png" alt="" /></p><ul><li><strong>注意</strong>：使用分组时，需要保证出现在 select 语句中但没有<code>被聚集</code>的属性只能是出现在 group by 子句中的那些属性</li></ul><hr /><h4 id="having-子句"><a class="markdownIt-Anchor" href="#having-子句"></a> having 子句</h4><ul><li><strong>having</strong> 子句中的谓词在形成分组后起作用，可以使用聚集函数<ul><li>where 子句中的谓词在形成分组之前起作用</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 查询平均薪水大于<span class="hljs-number">42000</span>的院系有哪些<br><span class="hljs-keyword">select</span> dept_name, <span class="hljs-built_in">avg</span> (salary)<br><span class="hljs-keyword">from</span> instructor<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> dept_name<br><span class="hljs-keyword">having</span> <span class="hljs-built_in">avg</span> (salary) <span class="hljs-operator">&gt;</span> <span class="hljs-number">42000</span>;<br></code></pre></td></tr></table></figure><ul><li><p>和 select 子句类似，任何出现在 having 语句中但没有<code>被聚集</code>的属性只能是出现在 group by 子句中的那些属性</p></li><li><p>包含聚集、group by 子句或 having 子句的查询的含义可以通过下属操作序列定义：</p><ul><li>与不带聚集的查询情况类似，最先根据 from 子句来计算出一个关系</li><li>如果出现了 where 子句， where 子句中的谓词将应用到 from 子句的结果关系上</li><li>如果出现了 group by 子句．满足 where 谓词的元组通过 group by 子句形成分组。如果没有group 子句，满足 where 谓词的整个元组集被当作一个分组</li><li>如果出现了 having 子句，它将应用到每个分组上；不满足 having 子句谓词的分组将被抛弃</li><li>select 子句利用剩下的分组产生出查询结果中的元组，即在每个分组上应用聚集函数来得到单个结果元组</li></ul></li></ul><hr /><h4 id="对空值和布尔值的聚集"><a class="markdownIt-Anchor" href="#对空值和布尔值的聚集"></a> 对空值和布尔值的聚集</h4><ul><li>聚集函数根据以下原则处理 null<ul><li>除了 <code>count(*)</code> 外所有的聚集函数都忽略输入集合中的 null<ul><li>但是当属性取值都是 null 的时候，结果为 null</li></ul></li><li>规定空集的 <code>count</code> 运算值为 0</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>专业课</category>
      
      <category>数据库系统及其应用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>sql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>智能软件测试｜概述</title>
    <link href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%99%BA%E8%83%BD%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/software-testing/"/>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%99%BA%E8%83%BD%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/software-testing/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2><h3 id="为什么测试软件"><a class="markdownIt-Anchor" href="#为什么测试软件"></a> 为什么测试软件</h3><ul><li><p>软件故障的术语</p><ul><li><code>Fault</code>（故障）, <code>failure</code>（失败）, <code>defect</code>（缺陷）往往暗示一种非常严重，甚至可能是危险的情况。<ul><li>fault = defect</li></ul></li><li><code>Anomaly</code>（异常）, <code>incident</code>（事故）, <code>variance</code>（偏差）通常用于推断意外操作而不是全面失败</li><li><code>Problem</code>, <code>error</code>（错误）, bug 可能是最通用的术语</li></ul></li><li><p>重要的三个概念</p><ul><li><strong>软件故障</strong>(Software Fault)：软件中一个<code>静态</code>的缺陷</li><li><strong>软件失败</strong>(Software Failure)：一个<code>与软件需求</code>或是与其行为描述不符的、<code>外在的</code>行为</li><li><strong>软件错误</strong>(Software Error)：软件运行中一个<code>不正确的内部状态</code>，是某个<code>故障的表现</code></li></ul></li></ul><blockquote><p>Faults in software are equivalent to design mistakes in hardware.<br />具体来说，软件故障就是<code>设计失误</code></p></blockquote><ul><li><p>RIPR 模型</p><ol><li><strong>Reachability（可达性）</strong>： 测试用例必须能够到达程序包含fault的地方</li><li><strong>Infection（感染性）</strong>：必须导致内部状态错误出现</li><li><strong>Propagation（传播性）</strong>：错误的内部状态必须导致外部或者最终程序状态错误</li><li><strong>Revealability（可观测）</strong>：断言是否与错误的结果有交集？测试者必须能够观察到不正确的状态</li></ol></li><li><p>实际代码示例：</p></li></ul><p><img src="https://s2.loli.net/2022/03/07/O83246Qw5eDc9Wk.png" alt="" /></p><p><img src="https://s2.loli.net/2022/03/07/3WGscdEpnqjR8tK.png" alt="" /></p><hr /><ul><li><p>规范/规格说明书 (Product Specification)</p><ul><li>是软件开发团队之间的协议</li><li>它定义了他们正在创建的产品，详细说明<code>它将是什么，它将如何发挥作用，它将做什么以及不会做什么</code></li></ul><blockquote><p>what it will be, how it will act, what it will do, and what it won’t do.</p></blockquote></li><li><p>Bug 的正式定义：当以下五个规则中的一个或多个为真时，就会发生软件错误</p><ul><li>没有做产品规范规定的应该做的事情。</li><li>做了产品规格上不应该做的事情。</li><li>做了一些产品规范没有提到的事情。</li><li>没有做产品规范没有提到但应该做的事情。</li><li>软件难懂、难用、速度慢，或者在软件测试人员的眼里，最终用户会认为是完全不对的。<br /><img src="https://s2.loli.net/2022/03/07/IKYErVSGDbeJUCW.png" alt="" /></li></ul></li><li><p><strong>Validation &amp; Verification (IEEE)</strong></p><ul><li><strong>验证</strong>(Verification)：在软件开发<code>过程</code>中，决定一个阶段的<code>产品是否满足前一阶段需求</code>的过程</li><li><strong>确认</strong>(Validation)：在软件开发的<code>最终阶段</code>，评价软件是否和预期用途相一致的过程</li><li>缩写 <code>&quot;IV&amp;V&quot;</code> 指代的是“独立验证和确认”</li></ul></li><li><p>基于测试过程成熟度的测试目标</p></li></ul><p><img src="https://s2.loli.net/2022/03/07/adfLNCB2R71HEtz.png" alt="" /></p><blockquote><p>对于 Level 3，<strong>测试只能说明 failure 存在，而不能说明其不存在</strong></p></blockquote><ul><li><strong>不</strong>测试的代价<ul><li>测试是软件开发中最耗时和最昂贵的部分</li><li>不测试更贵<br /><img src="https://s2.loli.net/2022/03/07/7GT8YQqDClXUbJe.png" alt="" /></li></ul></li></ul><hr /><h3 id="测试活动和模型驱动测试设计"><a class="markdownIt-Anchor" href="#测试活动和模型驱动测试设计"></a> 测试活动和模型驱动测试设计</h3><blockquote><p>Test Activities &amp; Model-Driven Test Design</p></blockquote><h4 id="软件测试基础"><a class="markdownIt-Anchor" href="#软件测试基础"></a> 软件测试基础</h4><ul><li><p>测试只能说明 failure 存在⽽⾮不存在</p></li><li><p>区分测试和调试</p><ul><li><strong>测试(Testing)</strong>：通过观察软件的执行以评估软件</li><li><strong>测试失败(Test Failure)</strong>：执行一个测试用例后给出软件失败(failure)的结果</li><li><strong>调试(Debugging)</strong>：在<code>软件失败的前提</code>下找故障的过程</li></ul></li><li><p>Fault &amp; Failure Model (RIPR)</p><ul><li>观察失败的四个必要条件</li></ul><ol><li><strong>Reachability（可达性）</strong>： 测试用例必须能够到达程序包含 fault 的地方</li><li><strong>Infection（感染性）</strong>：程序的 fault 被执行后造成不正确的程序状态</li><li><strong>Propagation（传播性）</strong>：错误的内部状态必须导致外部或者最终程序状态错误</li><li><strong>Revealability（可观测）</strong>：断言是否与错误的结果有交集？测试者必须能够观察到不正确的状态<br /><img src="https://s2.loli.net/2022/03/07/WBCnd4SyYUFZXbN.png" alt="" /></li></ol></li></ul><h4 id="软件测试活动"><a class="markdownIt-Anchor" href="#软件测试活动"></a> 软件测试活动</h4><ul><li>测试工程师(Test Engineer)：负责一项或多项技术测试活动的 IT 专业人员</li><li>测试经理(Test Manager)：管理一名或多名测试工程师</li></ul><p><img src="https://s2.loli.net/2022/03/07/XrH6GRSKDcxvj5C.png" alt="" /></p><h4 id="基于软件活动的测试等级"><a class="markdownIt-Anchor" href="#基于软件活动的测试等级"></a> 基于软件活动的测试等级</h4><ul><li><p>传统测试等级</p><ul><li>验收测试(Acceptance testing)：根据需求和用户需要来评估软件</li><li>系统测试(System testing)：根据体系结构的设计和系统整体的行为来评估软件</li><li>集成测试(Integration testing)：测试模块如何相互交互</li><li>模块测试(Module testing)：测试每个类、文件、模块、组件</li><li>单元测试(Unit testing)：单独测试每个单元（方法）<br /><img src="https://s2.loli.net/2022/03/07/EN4M9xZDSwbYCKO.png" alt="" /></li></ul></li><li><p>面向对象测试等级(Object-Oriented Testing Levels)<br /><img src="https://s2.loli.net/2022/03/07/M7OEviGkN2cUaFw.png" alt="" /></p></li></ul><hr /><h4 id="覆盖标准coverage-criteria"><a class="markdownIt-Anchor" href="#覆盖标准coverage-criteria"></a> 覆盖标准(Coverage Criteria)</h4><ul><li><p>软件测试的两个问题</p><ul><li>大量的测试用例输入</li><li>巨大的输入空间</li></ul></li><li><p>目的：试图用最少的输入，找到最多的问题</p></li><li><p><strong>覆盖标准</strong>提供结构化、实用的方法来搜索输入空间</p><ul><li>彻底<code>搜索</code>输入空间</li><li>测试用例之间只有很小的<code>重叠</code></li></ul></li><li><p>覆盖标准在<code>提高质量</code>和<code>减少测试数据生成成本</code>方面有很大的优势</p><ul><li>覆盖标准能够最大化“<code>投入产出</code>”</li><li>提供从软件工件到测试的<code>可追溯性</code><ul><li>工件如源代码、设计模型、需求和输入空间描述</li></ul></li><li>使得<code>回归测试</code>（regression testing，修改代码之后再用原测试集评估）更简单</li><li>为测试人员提供“<code>停止原则</code>”(stopping rule)</li></ul></li><li><p>测试要求和标准</p><ul><li><strong>测试标准(Test Criterion)</strong>：定义测试要求的规则和过程的集合<ul><li>覆盖每一个语句</li><li>覆盖所有功能需求</li></ul></li><li><strong>测试要求(Test Requirements)</strong>：在测试期间必须满足或涵盖的特定事物<ul><li>每个语句可能是一个测试要求</li><li>每个功能需求都可能是一个测试需求</li></ul></li></ul></li></ul><blockquote><p>测试研究人员已经定义了几十个标准，但它们实际上都只是针对四种结构的几个标准：<br />输入空间(Input domains，黑盒的)、图(Graphs)、逻辑表达式(Logic expressions)、语法规则(Syntax descriptions)</p></blockquote><ul><li>旧观点：彩盒<ul><li><strong>黑盒测试(Black-box testing)</strong>：从软件的外部描述中派生测试，包括规范、需求和设计（与现实无关，<code>从需求出发</code>）</li><li><strong>白盒测试(White-box testing)</strong>：从软件的源代码内部派生测试，具体包括分支、单个条件和语句 （需要<code>了解源码</code>实现细节）</li><li><strong>基于模型的测试(Model-based testing)</strong>：从软件模型（例如 UML 图）派生测试</li></ul></li></ul><hr /><h4 id="模型驱动测试设计过程model-driven-test-design-mdtd"><a class="markdownIt-Anchor" href="#模型驱动测试设计过程model-driven-test-design-mdtd"></a> 模型驱动测试设计过程(Model-Driven Test Design, MDTD)</h4><ul><li>目的：<ul><li>使用抽象概念 <code>model(模型)</code> 来管理复杂性</li><li>模型本身是一个<code>抽象架构</code></li></ul></li><li><strong>测试设计(Test Design)</strong> 是设计将有效测试软件的输入值的过程</li><li>测试活动的类型：<ul><li>测试设计(Test Design)<ul><li>基于标准(Criteria-based)<ul><li>设计测试值以满足覆盖标准或其他工程目标</li></ul></li><li>基于人/经验(Human-based)<ul><li>根据程序的领域知识和人类的测试知识设计测试值</li></ul></li></ul></li><li>测试自动化(Test Automation)<ul><li>将测试值嵌入可执行脚本</li></ul></li><li>测试执行(Test Execution)<ul><li>在软件上运行测试并记录结果</li></ul></li><li>测试评估(Test Evaluation)<ul><li>评估测试结果，向开发人员报告</li></ul></li></ul></li><li>其他测试活动<ul><li>测试管理(Test management)<ul><li>设置策略，组织团队，与开发接口，选择标准，决定需要多少自动化，…</li></ul></li><li>测试维护(Test maintenance)<ul><li>随着软件的发展，保存测试以供重用</li></ul></li><li>测试文档(Test documentation)<ul><li>每个测试都必须记录“为什么” —— 标准和测试要求</li></ul></li></ul></li></ul><blockquote><p>一个成熟的测试组织只需要一个测试设计者就可以与多个测试自动化者、执行者和评估者一起工作改进的自动化将减少测试执行者的数量</p></blockquote><hr /><ul><li>在实践中使用 MDTD<ul><li>让一个测试设计师做数学。然后传统的测试人员和程序员可以做他们的部分</li><li>MDTD 让测试设计师“<code>提升了抽象的级别</code>”</li></ul></li></ul><p><img src="10.png" alt="" /></p><p><img src="https://s2.loli.net/2022/03/07/W6Apihb9XZSCdaB.png" alt="" /></p><ul><li>一个小示例<br /><img src="https://s2.loli.net/2022/03/07/7CWa8gBlqQJKeZ6.png" alt="" /><ul><li>标准的控制流的初始节点用<code>带点的圆圈</code>表示</li><li>终止节点用<code>两个圆圈</code>表示</li></ul></li></ul><hr /><h3 id="术语"><a class="markdownIt-Anchor" href="#术语"></a> 术语</h3><h4 id="软件可测性software-testability"><a class="markdownIt-Anchor" href="#软件可测性software-testability"></a> 软件可测性(Software Testability)</h4><ul><li><p><strong>软件可测性(Software Testability)</strong>：为了评判测试准则是否达标，系统或组件在测试准则建立和测试用例性能提升方面所能提供的便利程度</p><ul><li>说白了—— 在软件中找出故障有多难</li></ul></li><li><p>可测试性由两个实际问题主导</p><ul><li>如何向软件提供测试值</li><li>如何观察测试执行的结果</li></ul></li><li><p><strong>软件可观察性(Software Observability)</strong>：观察程序行为的难易程度。程序行为包括输出、对环境的影响以及其他硬件和软件组件</p><ul><li>影响硬件设备、数据库或远程文件的软件具有低可观察性</li></ul></li><li><p><strong>软件可控性(Software Controllability)</strong>：向程序提供所需输入的难易程度。程序输入包括数据值、操作和行为</p></li></ul><blockquote><p>数据抽象降低了可控性和可观察性</p></blockquote><hr /><h4 id="测试用例的构成components-of-a-test-case"><a class="markdownIt-Anchor" href="#测试用例的构成components-of-a-test-case"></a> 测试用例的构成(Components of a Test Case)</h4><ul><li>测试用例是具有明确结构的<code>多部分工件</code></li><li><strong>测试用例值(Test case values)</strong>：在待测软件上完成测试执行所需的输入值</li><li><strong>预期结果(Expected results)</strong>：当软件的行为符合预期时，软件在测试用例中应产生的结果</li></ul><hr /><ul><li>Affecting Controllability and Observability（影响可控性和可观察性 ）<ul><li><strong>前缀值(Prefix values)</strong>：将待测软件置于合适状态以接收测试用例的必要输入</li><li><strong>后缀值(Postfix values)</strong>：测试用例值发送之后，待测软件仍然需要的输入<ul><li>后缀值可以分为两类<ul><li><strong>验证值(Verification Values)</strong>：查看测试用例值结果所需的值</li><li><strong>退出值( Exit Values)</strong>：终止程序或使程序回到一个稳定状态所需的值或命令行输入</li></ul></li></ul></li></ul></li></ul><hr /><ul><li><strong>测试用例(Test case)</strong>：测试用例包括必要的测试用例值、前缀值、后缀值和预期结果，以便完整地执行和评估待测软件</li><li><strong>测试集(Test set)</strong>：测试用例的集合</li><li><strong>可执行的测试脚本(Executable test script)</strong>：处于一种可以在待测软件上自动运行和生成报告的形式的测试用例</li></ul><hr /><h4 id="测试自动化框架"><a class="markdownIt-Anchor" href="#测试自动化框架"></a> 测试自动化框架</h4><ul><li><strong>测试自动化</strong>：使用软件来控制测试的<strong>执行</strong>、实际结果与预测结果的<strong>比较</strong>、测试前提条件的<strong>设置</strong>以及其他测试<strong>控制</strong>和测试<strong>报告</strong>功能</li><li><strong>测试自动化框架(Test Automation Framework)</strong>：一组支持测试自动化的假设、概念和工具</li><li>测试框架为测试脚本提供了标准的设计，包括对测试驱动的支持<ul><li><strong>测试驱动(Test driver)</strong>：<ul><li>可以在软件上反复运行测试集合中的每一个测试用例。</li><li>如果待测软件不是独立运行的（即方法、类或其他组件），则提供运行软件的“主(main)”方法</li><li>将执行结果与预期结果（来自测试用例）进行比较，并将结果报告给测试人员</li></ul></li></ul></li><li>绝大多数的测试自动化框架都支持：<ul><li>评估预期结果的<code>断言(Assertions)</code></li><li>在测试用例间分享共同的测试数据</li><li>方便组织测试集合和运行测试用例</li><li>从命令行或图形界面运行测试</li></ul></li></ul><blockquote><p>大多数测试自动化框架都是为单元测试和集成测试而设计的，尽管有些专门支持系统测试，有些是为支持 Web 测试而构建的</p></blockquote><ul><li>自动化测试框架的例子：JUnit, HttpUnit, HtmlUnit, JWebUnit, Selenium, unittest, Jasmine, PHPUnit, Robotium</li></ul><hr /><h4 id="做与不做"><a class="markdownIt-Anchor" href="#做与不做"></a> 做与不做</h4><ol><li>测试一件事（目的，可追溯）<ul><li>每个测试应该有一个断言</li></ul></li><li>清晰、易懂、准确、简洁</li><li>保持小（更多的小测试比几个大的测试更好）<ul><li>测试运行多次，保持小而快</li></ul></li><li>将重复代码移动到夹具或共享方法中</li><li>独立（测试框架不保证执行顺序）</li><li>可重复</li><li>避免测试中复杂的控制流程</li><li>记得重构测试代码</li><li>测试预言机应该检查正确的地方（不需要检查整个输出状态）——认真思考应该检查什么</li><li>使用正确的断言类型</li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>专业课</category>
      
      <category>智能软件测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>体系结构｜MIPS 与 Verilog HDL</title>
    <link href="/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/longxin/"/>
    <url>/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/longxin/</url>
    
    <content type="html"><![CDATA[<h1 id="资料学习"><a class="markdownIt-Anchor" href="#资料学习"></a> 资料学习</h1><h2 id="自己动手写cpu"><a class="markdownIt-Anchor" href="#自己动手写cpu"></a> 《自己动手写CPU》</h2><h3 id="处理器与mips"><a class="markdownIt-Anchor" href="#处理器与mips"></a> 处理器与MIPS</h3><blockquote><p>本处内容大多在《计算机组成原理》课上学习过，此处仅作为回顾</p></blockquote><!--more--><h4 id="计算机的简单模型"><a class="markdownIt-Anchor" href="#计算机的简单模型"></a> 计算机的简单模型</h4><p><img src="1.png" alt="" /><br /><img src="2.png" alt="" /></p><hr /><h4 id="mips32-指令集架构"><a class="markdownIt-Anchor" href="#mips32-指令集架构"></a> MIPS32 指令集架构</h4><ul><li>CISC：复杂指令集计算机，每条指令对应编码串长度不一</li><li>RISC：精简指令集计算机，每条指令对应编码串长度固定</li></ul><hr /><ul><li>数据类型<ul><li>位(b)：1 bit</li><li>字节(Byte)：8 bit</li><li>半字(Half Word)：16 bit</li><li>字(Word)：32 bit</li><li>双字(Double Word)：64 bit</li></ul></li></ul><hr /><ul><li>寄存器<ul><li>MIPS32 的指令除了加载/存储指令外，都是<code>使用寄存器或立即数作为操作数</code></li><li>MIPS32 的寄存器分为两类：通用寄存器和特殊寄存器<ul><li>通用寄存器：<br /><img src="3.png" alt="" /><br /><img src="4.png" alt="" /></li><li>特殊寄存器：MIPS32 架构中定义的特殊寄存器有三个：<ul><li>PC：程序计数器</li><li>HI：乘除结果高位寄存器（高32位）</li><li>LO：乘除结果低位寄存器（低32位）</li></ul></li><li>字节次序<ul><li>大端模式：数据<code>高位保存在存储器的低地址</code>中，低位保存在高地址中</li><li>小端格式则相反<br /><img src="5.png" alt="" /></li></ul></li></ul></li></ul></li></ul><hr /><ul><li>指令格式<ul><li><p>MIPS32 架构中的所有指令都是32位，有三种格式，其中 op 是指令码、func 是功能码<br /><img src="6.png" alt="" /></p></li><li><p>指令集</p><ul><li>逻辑操作指令：实现逻辑与、或、异或、或非等运算</li><li>移位操作指令：实现逻辑左移、右移、算数右移等</li><li>移动操作指令：用于通用寄存器之间以及通用寄存器与HI、LO寄存器之间的数据移动</li><li>算术操作指令：实现加、减、比较、乘累加、除法等运算</li><li>转移指令：包括无条件转移和条件转移，用于程序转移到另一个地方执行</li><li>加载存储指令：用于从存储器中读取数据，或者向存储器中保存数据</li><li>协处理器访问指令：用于读取协处理器CP0中某个寄存器的值，或者将数据保存到协处理器CP0中的某个寄存器</li><li>异常相关指令：包括自陷指令、系统调用指令、异常返回指令</li><li>其余指令：nop, ssnop, sync, pref</li></ul></li></ul></li></ul><hr /><ul><li>寻址方式<ul><li>寄存器相对寻址：主要用于加载/存储指令，其将一个 <code>16 位的立即数做符号扩展</code>，然后与指定通用寄存器的值相加，从而得到一个有效地址<br /><img src="7.png" alt="" /></li><li>PC 相对寻址：主要用于转移指令，在转移指令中有一个 16 位的立即数，将其左移两位并作符号扩展，然后与 PC 值相加，从而获得有效地址<br /><img src="8.png" alt="" /></li></ul></li></ul><hr /><ul><li>协处理器 CP0<ul><li>协处理器通常表示处理器的一个可选部件，负责处理指令集的某个扩展，拥有与处理器相独立的寄存器。</li><li>协处理器 CP0 的具体作用有：配置 CPU 工作状态、高速缓存控制、异常控制、存储管理单元控制等。</li></ul></li></ul><hr /><h3 id="可编程逻辑器件与-verilog-hdl"><a class="markdownIt-Anchor" href="#可编程逻辑器件与-verilog-hdl"></a> 可编程逻辑器件与 Verilog HDL</h3><h4 id="可编程逻辑器件pld概述"><a class="markdownIt-Anchor" href="#可编程逻辑器件pld概述"></a> 可编程逻辑器件(PLD)概述</h4><ul><li><p>PLD 是上世纪 70 年代发展起来的一种新型器件，它的应用和发展不仅简化了电路设计，降低了开发成本，提高了系统可靠性，而且给数字系统的设计方法带来了革命性的变化</p></li><li><p>按照不同的内部结构可以将 PLD 器件分为以下两类：</p><ul><li>基于乘积项(Product-Term)结构的PLD器件<br /><img src="9.png" alt="" /></li><li>基于查找表(Look-Up Table, LUT)结构的PLD器件<br /><img src="10.png" alt="" /></li></ul></li><li><p>基于 PLD 的数字系统设计流程</p></li></ul><p><img src="11.png" alt="" /></p><hr /><h4 id="verilog-hdl-中模块的结构"><a class="markdownIt-Anchor" href="#verilog-hdl-中模块的结构"></a> Verilog HDL 中模块的结构</h4><ul><li>Verilog 程序的基本设计单位是“模块”(Module)，一个模块有其特定的结构。</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span>&lt;模块名&gt;(<br>  &lt;端口&gt;<br>  &lt;端口&gt;<br>  .....<br>);<br><br>  &lt;端口定义&gt;<br>  &lt;数据类型说明&gt;<br>  &lt;逻辑功能描述&gt;<br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><ul><li>Verilog 的模块完全定义在 module 和 endmodule 关键字之间。</li><li>考虑以下代码，其实现 32 位加法器模块，有两个输入信号 in1、in2，两者相加的结果通过 out 输出</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> adder (in1, in2, out);  <span class="hljs-comment">//模块声明</span><br><br>  <span class="hljs-keyword">input</span> in1, in2;  <span class="hljs-comment">//端口定义，此处是输入端口</span><br>  <span class="hljs-keyword">output</span> out;  <span class="hljs-comment">//端口定义，此处是输出端口</span><br><br>  <span class="hljs-keyword">wire</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] in1, in2, out;  <span class="hljs-comment">//数据类型说明，此处都是 wire 型</span><br><br>  <span class="hljs-keyword">assign</span> out = in1 + in2;  <span class="hljs-comment">//逻辑功能描述</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><ol><li>模块声明：包括模块名字，以及输入、输出端口列表，格式如下：</li></ol><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> 模块名(端口<span class="hljs-number">1</span>, 端口<span class="hljs-number">2</span>, 端口<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><ol start="2"><li>端口定义：明确说明模块端口的方向，格式如下：</li></ol><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">input</span> 端口<span class="hljs-number">1</span>, 端口<span class="hljs-number">2</span>, 端口<span class="hljs-number">3</span>; <span class="hljs-comment">//输入端口</span><br><span class="hljs-keyword">output</span> 端口<span class="hljs-number">1</span>, 端口<span class="hljs-number">2</span>, 端口<span class="hljs-number">3</span>;  <span class="hljs-comment">//输出端口</span><br><span class="hljs-keyword">inout</span> 端口<span class="hljs-number">1</span>, 端口<span class="hljs-number">2</span>, 端口<span class="hljs-number">3</span>;  <span class="hljs-comment">//双向端口</span><br></code></pre></td></tr></table></figure><ol start="3"><li>数据类型说明：对模块中所有用到的信号（包括端口信号、节点信号等）都必须进行数据类型的定义。</li></ol><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">reg</span> a;  <span class="hljs-comment">//定义信号a的数据类型为reg型</span><br><span class="hljs-keyword">wire</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] out;  <span class="hljs-comment">// 定义信号out的数据类型为32位wire型</span><br></code></pre></td></tr></table></figure><ul><li>对于端口，可以将端口定义、数据类型说明都放在模块声明中，于是上文的 32 位加法器可以改为如下形式：</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> adder (<span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] in1,<br>              <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] in2,<br>              <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] out);  <br><br>  <span class="hljs-keyword">assign</span> out = in1 + in2;  <br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><ol start="4"><li>逻辑功能描述<ol><li>用 assign 持续赋值语句定义</li><li>用 always 过程块定义</li><li>调用元件（也称为元件例化）</li></ol></li></ol><hr /><h4 id="verilog-hdl-基本要素"><a class="markdownIt-Anchor" href="#verilog-hdl-基本要素"></a> Verilog HDL 基本要素</h4><h5 id="常量"><a class="markdownIt-Anchor" href="#常量"></a> 常量</h5><ul><li>Verilog 中的常量(Constant)有三种：整数、实数、字符串。<br /><img src="12.png" alt="" /><br /><img src="13.png" alt="" /></li></ul><hr /><h5 id="变量声明与数据类型"><a class="markdownIt-Anchor" href="#变量声明与数据类型"></a> 变量声明与数据类型</h5><ul><li>变量声明的格式如下所示：<br /><img src="14.png" alt="" /><ul><li>只有数据类型、变量名是必要的，其他部分都可以省略</li><li>如果省略符号和位宽，那么根据数据类型设置为默认值；如果省略元素数，那么默认声明为 1</li></ul></li><li>数据类型介绍如下：<ul><li>net 型变量<ul><li>net 型相当于硬件电路中各种物理连接</li><li>其特点是输出的值紧跟输入值的变化而变化。<br /><img src="15.png" alt="" /></li><li>wire 是最常用的 net 型变量<ul><li>输入、输出信号没有明确指定数据类型时，都被默认为 wire 型</li><li>wire 型信号可以用作任何表达式的输入，也可以用作 assign 语句和实例元件的输出</li><li>对于综合器而言，wire 型变量的取值可为 0, 1, X, Z<ul><li>其中 0 代表低电平、逻辑0</li><li>1 代表高电平、逻辑1</li><li>X 代表不确定或未知的逻辑状态</li><li>Z 代表高阻态</li><li>如果没有赋值，默认为高阻态 Z</li></ul></li></ul></li></ul></li><li>variable 型变量<ul><li>variable 型变量可以保存上次写入数据，一般对应硬件上的一个触发器或锁存器等存储元件，但不绝对</li><li>variable 型变量必须在过程语句（initial 或 always）中实现赋值，这种赋值方式称为过程赋值<br /><img src="16.png" alt="" /></li></ul></li><li>向量<ul><li>变量声明时如果位宽为 1，那么对应的变量为标量；如果不为 1，那么对应的变量为向量。默认为标量</li><li>向量的位宽的定义形式为 <code>[MSB : LSB]</code><ul><li>冒号左边的数字表示向量的最高有效位(MSB)，冒号右边的数字表示向量的最低有效位 LSB</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] bus;  <span class="hljs-comment">//4 位的 wire 型向量 bus，其中 bus[3] 是最高位，bus[0] 是最低位</span><br><span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">5</span>] ra;  <span class="hljs-comment">//27 位的 reg 型向量 ra，其中 ra[31] 是最高位，ra[5] 是最低位</span><br></code></pre></td></tr></table></figure></li><li>向量有两种，一种是向量类向量，另一种是标量类向量，可以使用关键字区分，如果没有明确指出，那么默认是标量类向量</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> <span class="hljs-keyword">vectored</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] databus;  <span class="hljs-comment">//使用关键字 vectored，表示向量类向量</span><br><span class="hljs-keyword">reg</span> <span class="hljs-keyword">scalared</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] rega;  <span class="hljs-comment">//使用关键字 scalared，表示是标量类向量</span><br></code></pre></td></tr></table></figure><ul><li>标量类向量可以任意选中其中一位或相邻几位，分别称为位选择(bit-select)和域选择(part-select)</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog">A = rega[<span class="hljs-number">6</span>]  <span class="hljs-comment">//位选择，讲向量 rega 的其中一位赋值给变量A</span><br>B = rega[<span class="hljs-number">5</span>:<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>体系结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>体系结构</tag>
      
      <tag>MIPS</tag>
      
      <tag>Verilog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>当我在写 i++ 我在写什么</title>
    <link href="/%E6%97%A5%E5%B8%B8/%E6%B1%87%E7%BC%96/"/>
    <url>/%E6%97%A5%E5%B8%B8/%E6%B1%87%E7%BC%96/</url>
    
    <content type="html"><![CDATA[<blockquote><p>笔者按：我本来是不愿纠结 i++ 和 ++i 这种谭浩强式的牛角尖，但是</p></blockquote><p>今天发现了这样一段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;<br>  i += i + i + i++;<br>  j += j + j++;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,i,j);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">5</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>这令笔者感到非常奇怪，本人的 C 语言学得非常之烂，堪称 C loser，这个问题想了一会儿想不明白，于是决定到汇编里面找答案。</p><!--more--><p>首先写这样一段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<br>  i += i + i++;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,i);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>得到其汇编代码：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.file</span><span class="hljs-string">&quot;a.c&quot;</span><br><span class="hljs-meta">.text</span><br><span class="hljs-meta">.def</span>__main<span class="hljs-comment">;.scl2;.type32;.endef</span><br><span class="hljs-meta">.section</span> .rdata,<span class="hljs-string">&quot;dr&quot;</span><br><span class="hljs-symbol">.LC0:</span><br><span class="hljs-meta">.ascii</span> <span class="hljs-string">&quot;%d\0&quot;</span><br><span class="hljs-meta">.text</span><br><span class="hljs-meta">.globl</span>main<br><span class="hljs-meta">.def</span>main<span class="hljs-comment">;.scl2;.type32;.endef</span><br><span class="hljs-meta">.seh_proc</span>main<br><span class="hljs-symbol">main:</span><br>pushq%rbp  # 将调用这个函数的函数的栈帧的底部栈指针存进本函数栈帧。<br><span class="hljs-meta">.seh_pushreg</span>%rbp<br><span class="hljs-keyword">movq</span>%rsp, %rbp   # 将栈顶指针数据赋值给栈底指针。<br><span class="hljs-meta">.seh_setframe</span>%rbp, <span class="hljs-number">0</span><br>subq<span class="hljs-number">$48</span>, %rsp  # 申请<span class="hljs-number">48</span>个字节的栈空间<br><span class="hljs-meta">.seh_stackalloc</span><span class="hljs-number">48</span>  <br><span class="hljs-meta">.seh_endprologue</span><br><span class="hljs-keyword">call</span>__main  <br>movl<span class="hljs-number">$1</span>, -<span class="hljs-number">4</span>(%rbp)  # i 存放在 -<span class="hljs-number">4</span>(%rbp)<br>movl-<span class="hljs-number">4</span>(%rbp), %eax  # i 放入寄存器 %eax<br>leal<span class="hljs-number">1</span>(%rax), %edx   # %edx 中存放 i+<span class="hljs-number">1</span><br>movl%edx, -<span class="hljs-number">4</span>(%rbp)  # 将 %edx 中存放的 i+<span class="hljs-number">1</span> 放回到栈中 i 的位置，即-<span class="hljs-number">4</span>(%rbp)<br>movl-<span class="hljs-number">4</span>(%rbp), %edx  # 将 栈中的 i+<span class="hljs-number">1</span> 赋给寄存器 %edx<br>addl%edx, %eax  # %eax 中此时存放 (i+<span class="hljs-number">1</span>)+i<br>addl%eax, -<span class="hljs-number">4</span>(%rbp)  # 栈中 i 的位置此时存放 (i+<span class="hljs-number">1</span>)+i+(i+<span class="hljs-number">1</span>)<br>movl-<span class="hljs-number">4</span>(%rbp), %eax <br>movl%eax, %edx  # 传递参数准备 print<br>leaq.LC0(%rip), %rcx<br><span class="hljs-keyword">call</span>printf<br>movl<span class="hljs-number">$0</span>, %eax<br>addq<span class="hljs-number">$48</span>, %rsp<br>popq%rbp<br><span class="hljs-keyword">ret</span><br><span class="hljs-meta">.seh_endproc</span><br><span class="hljs-meta">.ident</span><span class="hljs-string">&quot;GCC: (x86_64-win32-seh-rev0, Built by MinGW-W64 project) 8.1.0&quot;</span><br><span class="hljs-meta">.def</span>printf<span class="hljs-comment">;.scl2;.type32;.endef</span><br><br></code></pre></td></tr></table></figure><p>相关的注释写在了代码里。可以清楚看到编译器首先在寄存器中保留了一个 i 的初值，之后把栈中的 i 改为了 i+1，之后涉及到 i 的运算也就是 i+1，因此这个式子的答案是 2+2+1=5</p><p>再考虑如下 C 代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<br>  i += i + i + i++;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,i);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>得到其汇编代码：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.file</span><span class="hljs-string">&quot;a.c&quot;</span><br><span class="hljs-meta">.text</span><br><span class="hljs-meta">.def</span>__main<span class="hljs-comment">;.scl2;.type32;.endef</span><br><span class="hljs-meta">.section</span> .rdata,<span class="hljs-string">&quot;dr&quot;</span><br><span class="hljs-symbol">.LC0:</span><br><span class="hljs-meta">.ascii</span> <span class="hljs-string">&quot;%d\0&quot;</span><br><span class="hljs-meta">.text</span><br><span class="hljs-meta">.globl</span>main<br><span class="hljs-meta">.def</span>main<span class="hljs-comment">;.scl2;.type32;.endef</span><br><span class="hljs-meta">.seh_proc</span>main<br><span class="hljs-symbol">main:</span><br>pushq%rbp<br><span class="hljs-meta">.seh_pushreg</span>%rbp<br><span class="hljs-keyword">movq</span>%rsp, %rbp<br><span class="hljs-meta">.seh_setframe</span>%rbp, <span class="hljs-number">0</span><br>subq<span class="hljs-number">$48</span>, %rsp<br><span class="hljs-meta">.seh_stackalloc</span><span class="hljs-number">48</span><br><span class="hljs-meta">.seh_endprologue</span><br><span class="hljs-keyword">call</span>__main<br>movl<span class="hljs-number">$1</span>, -<span class="hljs-number">4</span>(%rbp)  # i 存放在 -<span class="hljs-number">4</span>(%rbp)<br>movl-<span class="hljs-number">4</span>(%rbp), %eax  # i 放入寄存器 %eax<br>leal(%rax,%rax), %ecx  # %ecx 中存放 i + i<br>movl-<span class="hljs-number">4</span>(%rbp), %eax  # i 放入寄存器 %eax<br>leal<span class="hljs-number">1</span>(%rax), %edx  # %edx 中存放 i+i<br>movl%edx, -<span class="hljs-number">4</span>(%rbp)  # 将 %edx 中存放的 i+<span class="hljs-number">1</span> 放回到栈中 i 的位置，即-<span class="hljs-number">4</span>(%rbp)<br>addl%ecx, %eax  # %eax 中此时存放 (i+i)+i<br>addl%eax, -<span class="hljs-number">4</span>(%rbp)  # 栈中 i 的位置此时存放 (i+i)+i+(i+<span class="hljs-number">1</span>)<br>movl-<span class="hljs-number">4</span>(%rbp), %eax<br>movl%eax, %edx  # 传递参数准备 print<br>leaq.LC0(%rip), %rcx<br><span class="hljs-keyword">call</span>printf<br>movl<span class="hljs-number">$0</span>, %eax<br>addq<span class="hljs-number">$48</span>, %rsp<br>popq%rbp<br><span class="hljs-keyword">ret</span><br><span class="hljs-meta">.seh_endproc</span><br><span class="hljs-meta">.ident</span><span class="hljs-string">&quot;GCC: (x86_64-win32-seh-rev0, Built by MinGW-W64 project) 8.1.0&quot;</span><br><span class="hljs-meta">.def</span>printf<span class="hljs-comment">;.scl2;.type32;.endef</span><br></code></pre></td></tr></table></figure><p>此处和之前的尝试截然不同，此处先将 += 符号右边的两个 i 以初值相加，再加上 i++ 的返回值 i，最后加上栈中保留的原值 i+1，此时式子则变成了 (1+1)+1+2 = 5，运算方式和之前完全不同</p><p>考虑是编译器的问题，夜深了没空看编译器源码，妈的，纠结这种问题是没有意义的</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译器</tag>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理｜概述</title>
    <link href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/compile-1/"/>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/compile-1/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是编译"><a class="markdownIt-Anchor" href="#什么是编译"></a> 什么是编译</h2><ul><li>编译：将<code>高级语言</code>翻译成<code>汇编语言</code>或<code>机器语言</code>的过程</li><li>编译器在语言处理系统中的位置<br /><img src="1.png" alt="" /></li></ul><hr /><h2 id="编译系统的结构"><a class="markdownIt-Anchor" href="#编译系统的结构"></a> 编译系统的结构</h2><ul><li>编译器的阶段<br /><img src="2.png" alt="" /></li></ul><hr /><h2 id="词法分析概述"><a class="markdownIt-Anchor" href="#词法分析概述"></a> 词法分析概述</h2><ul><li>词法分析的主要任务<ul><li>从左向右逐行扫描源程序的字符，识别出各个单词，确定<code>单词类型</code></li><li>将识别出的单词转换成统一的<code>机内表示</code>——词法单元(token)形式<ul><li><strong>token</strong>：&lt; 种别码，属性值 &gt;<br /><img src="3.png" alt="" /></li></ul></li></ul></li></ul><hr /><h2 id="语法分析概述"><a class="markdownIt-Anchor" href="#语法分析概述"></a> 语法分析概述</h2><ul><li><strong>语法分析器(parser)</strong> 从词法分析器输出的 token 序列中<code>识别出各类短语</code>，并<code>构造语法分析树</code>(parse tree)<ul><li>语法分析树描述了句子的语法结构</li></ul></li></ul><hr /><h2 id="语义分析概述"><a class="markdownIt-Anchor" href="#语义分析概述"></a> 语义分析概述</h2><ul><li>语义分析的主要任务<ul><li>收集标识符的属性信息<ul><li>种属(Kind)<ul><li>简单变量、复合变量（数组、记录、…）、过程、…</li></ul></li><li>类型(Type)<ul><li>整型、实型、字符型、布尔型、指针型、…</li></ul></li><li>存储位置、长度</li><li>值</li><li>作用域</li><li>参数和返回值信息<ul><li>参数个数、参数类型、参数传递方式、返回值类型、…<br /><img src="4.png" alt="" /></li></ul></li></ul></li><li>语义检查<ul><li>变量或过程<code>未经声明就使用</code></li><li>变量或过程名<code>重复声明</code></li><li><code>运算分量</code>类型不匹配</li><li><code>操作符</code>与<code>操作数</code>之间的类型不匹配<ul><li>数组下标不是整数</li><li>对非数组变量使用数组访问操作符</li><li>对非过程名使用过程调用操作符</li><li>过程调用的参数类型或数目不匹配</li><li>函数返回类型有误</li></ul></li></ul></li></ul></li></ul><hr /><h2 id="中间代码生成及编译器后端概述"><a class="markdownIt-Anchor" href="#中间代码生成及编译器后端概述"></a> 中间代码生成及编译器后端概述</h2><ul><li>常见的中间表示形式<ul><li>三地址码 (Three-address Code)<ul><li>三地址码由<code>类似于汇编语言</code>的指令序列组成，</li><li>每个指令<code>最多有三个操作数</code>(operand)</li></ul></li><li>语法结构树/语法树 (Syntax Trees)</li></ul></li><li>常用三地址指令<br /><img src="./pic/5.png" alt="pic" /><ul><li><code>地址</code>可以具有如下形式之一<ul><li>源程序中的<code>名字</code>(name)</li><li><code>常量</code>(constant)</li><li>编译器生成的<code>临时变量</code>(temporary)</li></ul></li></ul></li><li>三地址指令的表示<ul><li>四元式 (Quadruples)<ul><li>(op, y, z, x)<br /><img src="./pic/6.png" alt="pic" /></li></ul></li><li>三元式 (Triples)</li><li>间接三元式 (Indirect triples)</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>专业课</category>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络｜期末复习</title>
    <link href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/computer-network/"/>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/computer-network/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络概述"><a class="markdownIt-Anchor" href="#计算机网络概述"></a> 计算机网络概述</h1><p><img src="https://img-blog.csdnimg.cn/20210120163906240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><h2 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h2><p>一般认为，计算机网络是一个将<code>分散的</code>、具有<code>独立</code>功能的计算机系统，通过<code>通信设备</code>(路由等)与<code>线路</code>(光纤等)连接起来，由功能完善的<code>软件</code>实现<code>资源共享</code>和<code>信息传递</code>的系统。是一些<code>互联的、自治的计算机系统的集合</code><br /><img src="https://img-blog.csdnimg.cn/2021012016215332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><h2 id="组成"><a class="markdownIt-Anchor" href="#组成"></a> 组成</h2><h3 id="从组成部分上看"><a class="markdownIt-Anchor" href="#从组成部分上看"></a> 从组成部分上看</h3><p>一个完整的计算机网络主要由<code>硬件、软件和协议</code>三大部分组成，缺一不可。</p><ol><li>硬件主要由<code>主机</code>（也称端系统），<code>通信链路</code>（如双绞线、光纤）、<code>交换设备</code>（如路由、交换机等）和<code>通信处理机</code>（如网卡）等组成</li><li>软件主要包括各种实现资源共享的软件和方便用户使用的各种工具软件（如网络操作系统、邮件收发程序、FTP程序、聊天程序等）。</li><li>协议是计算机网络的核心，<code>规定了网络传输数据时所遵循的规范</code>。</li></ol><h3 id="从工作方式上看"><a class="markdownIt-Anchor" href="#从工作方式上看"></a> 从工作方式上看</h3><p>计算机网络（主要指Internet）可分为边缘部分和核心部分。</p><ol><li>边缘部分由所有连接到因特网上、<code>供用户直接使用</code>的主机组成，用来进行通信（如传输数据、音频或视频）和资源共享。</li><li>核心部分由大量的网络和连接这些网络的路由器组成，它为边缘部分提供连通性和交换服务。</li></ol><p><img src="https://img-blog.csdnimg.cn/20210120163120514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><h3 id="从功能组成来看"><a class="markdownIt-Anchor" href="#从功能组成来看"></a> 从功能组成来看</h3><p>计算机网络由<code>通信子网和资源子网</code>组成</p><ol><li>通信子网由各种传输介质、通信设备和相应的网络协议组成，它使网络具有数据传输、交换、控制和存储的能力，<code>实现计算机之间的数据通信</code></li><li>资源子网是<code>实现资源共享功能</code>的设备及其软件的集合，向网络用户提供共享其他计算机上的硬件资源、软件资源和数据资源的服务<br /><img src="https://img-blog.csdnimg.cn/20210120163309132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></li></ol><h2 id="功能"><a class="markdownIt-Anchor" href="#功能"></a> 功能</h2><h3 id="数据通信"><a class="markdownIt-Anchor" href="#数据通信"></a> 数据通信</h3><ul><li>数据通信是计算机网络<code>最基本和最重要</code>的功能，实现联网计算机之间的各种信息传输，并将分散在不同地理位置的计算机联系起来，进行统一的调配、控制和管理</li></ul><h3 id="资源共享"><a class="markdownIt-Anchor" href="#资源共享"></a> 资源共享</h3><ul><li>资源共享可以是软件共享、数据共享和硬件共享</li><li>使计算机网络中的资源互通有无，分工协作，从而极大地提高硬件资源、软件资源和数据资源的利用率</li></ul><h3 id="分布式处理"><a class="markdownIt-Anchor" href="#分布式处理"></a> 分布式处理</h3><ul><li>当计算机网络中的某个计算机系统负荷过重时，可以将其处理的某个复杂任务分配给网络中的其它计算机系统，从而利用空闲计算机资源以提高整个系统的利用率</li></ul><h3 id="提高可靠性"><a class="markdownIt-Anchor" href="#提高可靠性"></a> 提高可靠性</h3><ul><li>计算机网络中的各台计算机可以通过网络互为替代机</li></ul><h3 id="负载均衡"><a class="markdownIt-Anchor" href="#负载均衡"></a> 负载均衡</h3><ul><li>将工作任务均衡的分配给计算机网络中的各台计算机</li></ul><h2 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h2><h3 id="按分布范围分类"><a class="markdownIt-Anchor" href="#按分布范围分类"></a> 按分布范围分类</h3><ul><li>广域网（WAN）。也称远程网。关于网提供长距离通信，通常是<code>几十千米到几千千米</code>的区域，比如跨国通信。连接关于网的各结点交换机的链路一般都是高速链路，具有较大的通信容量。</li><li>城域网（MAN）。覆盖范围跨越几个街区甚至整个城市，覆盖范围约<code>5~50km</code>，城域网大多采用以太网技术，因此有时也常并入局域网的范围进行讨论。</li><li>局域网（LAN）。范围<code>几十米到几千米</code>的区域。一般用微机或工作站通过高速线路相连。传统上，<code>局域网使用广播技术，而广域网使用交换技术</code>。</li><li>个人区域网（PAN）。覆盖范围大约<code>十米</code>左右。指在个人工作的地方将消费电子设备（如平板电脑、智能手机等）用无线技术连接起来的网络，也常称为无线个人区域网（WPAN）<br /><img src="https://img-blog.csdnimg.cn/20210120164111607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></li></ul><h3 id="按传输技术分类"><a class="markdownIt-Anchor" href="#按传输技术分类"></a> 按传输技术分类</h3><ul><li>广播（boradcasting）式网络。<code>所有联网计算机都共享一个公共通信信道</code>。当一台计算机利用共享通信信道发送报文分组时，所有其他计算机都会收听到这个分组。接受到该分组的计算机将通过检查目的地之来决定是否接受该分组。</li><li>有些广播系统还支持给一组机器发送数据包的模式，这种传输模式称为组播（multicasting）。</li><li>点到点（point-to-point）链路<code>将一对单独的机器连接起来</code>。在一个由点到点链路组成的网络中，为了从源端到达接收方，短消息必须首先访问一个或多个中间机器，这种短消息在某些情况下称为数据包或包（packet）。</li><li>点-点传输只有一个发送方和一个接收方，有时候也称为单播（unicasting）。</li></ul><h3 id="按拓扑结构分类"><a class="markdownIt-Anchor" href="#按拓扑结构分类"></a> 按拓扑结构分类</h3><ul><li>网络拓扑结构是指网络总的结点（路由器、主机等）于通信线路（网线）之间的几何关系（如总线形、环形）表示的网路结构，主要指通信子网的拓扑结构。</li><li>分为四类：<code>总线形、星形、环形、网状形</code></li><li>总线形：用单根传输线把计算机连接起来。<ul><li>优点是建网容易、 增减节点方便、节省线路。</li><li>缺点是重负载时通信效率不高、总线任意一处对故障敏感。</li></ul></li><li>星形：每个终端或计算机都以单独的线路和中央设备相连<ul><li>星形网络便于集中控制和管理，因为端用户之间的通信必须经过中央设备</li><li>缺点是成本高、中心结点对故障敏感。</li></ul></li><li>环形：所有计算机接口设备连接成一个环</li><li>网状形：一般情况下，每个结点至少有两条路径与其他结点相连，<code>多用于广域网</code><br /><img src="https://img-blog.csdnimg.cn/20210120164958156.png" alt="" /></li></ul><h3 id="按使用者分"><a class="markdownIt-Anchor" href="#按使用者分"></a> 按使用者分</h3><ul><li>公用网（Public Network）。也称公众网。指电信公司出资建造的大型网络。</li><li>专用网（Private Network）。指某个部门为满足本单位特殊业务需要而建造的网络。这种网络不向本单位以外人提供服务。如铁路、典礼、军队等部门专用网络。</li></ul><h3 id="按交换技术分类"><a class="markdownIt-Anchor" href="#按交换技术分类"></a> 按交换技术分类</h3><ul><li><code>电路交换网络</code>。在源结点和目的结点之间建立起一条专用的通路用于传输数据，包括建立连接（占用通信资源）、传输数据（一直占用通信资源）和断开连接（释放通信资源）三个阶段。最典型的电路交换网是传统电话网络。</li><li>该类网络的特点是整个报文的比特流<code>连续的从源点直达终点</code>，好像在一条管道中传送。</li><li>电路交换的优点主要包括以下几个方面：<ul><li>通信时延小。通信双方通过专用线路进行通信，数据可以直达。当数据传输量较大时，优点将十分显著。</li><li>线路独占，没有冲突。</li><li>实时性强。一旦通信线路建立，双方可以实时通信。</li></ul></li><li>电路交换的缺点主要包括以下几个方面：<ul><li>线路独占，利用率太低。</li><li>连接建立时间过长。</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20210120170107891.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><ul><li><code>报文交换网络</code>。也称<code>存储-转发网络</code>。用户数据加上源地址、目的地址、校验码等辅助信息，然后封装成报文、这个报文传送到相邻结点，全部存储后，再转发给下一个结点，重复这一过程直到到达目的结点，每个报文可以单独选择到达目的结点的路径。</li><li>报文交换的优点主要包括以下几个方面：<ul><li>无需建立连接。</li><li>动态分配线路。</li><li>线路利用率高。</li></ul></li><li>报文交换的缺点主要包括以下几个方面：<ul><li>报文交换对报文的大小没有限制，需要网络节点有足够的缓存空间。</li><li>报文交换在节点处要经历存储、转发等操作，从而引起一定时延。</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20210120170514151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><ul><li><code>分组交换网络</code>。也称<code>包交换网络</code>。其原理是将数据分成较短的固定长度的数据块，在每个数据块中加上目的地址、源地址等辅助信息组成分组（包），以<code>储存-转发</code>方式传输。</li><li>分组交换的优点主要包括以下几个方面：<ul><li>无需建立连接。</li><li>线路利用率高。</li><li>相对报文交换，分组长度固定，缓冲区容易管理。</li><li>分组比报文小，因此传输时间更短。</li></ul></li><li>分组交换的缺点主要包括以下几个方面：<ul><li>仍然存在时延。</li><li>需要传输包括源地址、目的地址、分组编号等额外信息。</li><li>分组可能遇到失序、丢失、重复等问题。<br /><img src="https://img-blog.csdnimg.cn/20210120170640121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /><br /><img src="https://img-blog.csdnimg.cn/20210120170734581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></li></ul></li><li>存储转发<br />报文交换与分组交换均采用存储-转发交换方式，区别是：<ul><li>报文交换以完整报文进行“存储-转发”</li><li>分组交换以较小的分组进行“存储-转发</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20210120170557835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><h3 id="按传输介质分类"><a class="markdownIt-Anchor" href="#按传输介质分类"></a> 按传输介质分类</h3><ul><li>传输介质可分为有线和无线两大类</li><li>有线网络可分为双绞线网络、同轴电缆网络等</li><li>无线网络可分为蓝牙、微波、无线电等类型</li></ul><h2 id="性能指标"><a class="markdownIt-Anchor" href="#性能指标"></a> 性能指标</h2><p>性能指标从不同的方面来度量计算机网络的性能<br /><img src="https://img-blog.csdnimg.cn/20210120172154989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><h3 id="速率speed"><a class="markdownIt-Anchor" href="#速率speed"></a> 速率（Speed）</h3><ul><li>速率是指连接在计算机网络上的主机在数字信道上<code>传送数据的速率</code>。是计算机网络中最重要的一个性能指标。</li><li>又称为数据率(data rate)或比特率(bit rate) ，速率的单位是bit/s(比特每秒，有时也写作bps）。</li><li>Bit 来源于 binary digit，意思是一个“二进制数字”，因此<code>一个比特就是二进制数字中的一个 1 或 0</code>。</li><li>当数据率较高时，可以使用kb/s(k=10<sup>3</sup>=千)、Mb/s(M=10<sup>6</sup>=兆)、Gb/s(G=10<sup>9</sup>=吉)或者Tb/s(T=10<sup>12</sup>=太)</li></ul><h3 id="带宽bandwidth"><a class="markdownIt-Anchor" href="#带宽bandwidth"></a> 带宽（Bandwidth）</h3><ul><li>在计算机网络中，带宽用来表示网络的通信线路传送数据的能力，通常指单位时间内从网络中的某一个点到另外一个点所能通过的<code>最高数据率</code>（网络设备所支持的最高速度）,带宽的单位为bit/s。<br /><img src="https://img-blog.csdnimg.cn/20210120172803637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></li></ul><h3 id="吞吐量throughput"><a class="markdownIt-Anchor" href="#吞吐量throughput"></a> 吞吐量（Throughput）</h3><ul><li>吞吐量表示<code>单位时间</code>内通过某个网络（通信线路、接口）的实际的数据量。单位b/s，kb/s，Mb/s等。</li><li>吞吐量受到网络的带宽或网络的额定速率的限制。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210120173451811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><blockquote><p>例如，PC机和交换机链路带宽100Mb/s，每秒最多传输100Mb的数据。因为两个服务器速率很慢，所以服务器传输数据给交换机，交换机然后传输数据给PC机一秒钟传输数据最大只能是30Mb/s。</p></blockquote><h3 id="时延delay"><a class="markdownIt-Anchor" href="#时延delay"></a> 时延（Delay）</h3><ul><li>指数据（一个报文或分组）从网络（或链路）的一端传送到另一端所需要的总时间，它由4部分构成：<code>发送时延、传播时延、处理时延、排队时延</code>。</li><li><code>总时延=发送时延+传播时延+处理时延+排队时延</code></li></ul><h4 id="发送时延"><a class="markdownIt-Anchor" href="#发送时延"></a> 发送时延</h4><ul><li>发送时延是主机或路由器发送数据帧所需要的时间，也就是<code>从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕</code>所需时间。发送时延也可以称为传输时延。</li><li>发送时延=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle displaystyle="true" scriptlevel="0"><mfrac><mrow><mi mathvariant="normal">数</mi><mi mathvariant="normal">据</mi><mi mathvariant="normal">长</mi><mi mathvariant="normal">度</mi><mo stretchy="false">(</mo><mi>b</mi><mi>i</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><mrow><mi mathvariant="normal">信</mi><mi mathvariant="normal">道</mi><mi mathvariant="normal">带</mi><mi mathvariant="normal">宽</mi><mo stretchy="false">(</mo><mi>b</mi><mi>i</mi><mi>t</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo stretchy="false">)</mo></mrow></mfrac></mstyle></mrow><annotation encoding="application/x-tex">\dfrac{数据长度(bit)}{信道带宽(bit/s)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">信</span><span class="mord cjk_fallback">道</span><span class="mord cjk_fallback">带</span><span class="mord cjk_fallback">宽</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord">/</span><span class="mord mathdefault">s</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">据</span><span class="mord cjk_fallback">长</span><span class="mord cjk_fallback">度</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。<br /><img src="https://img-blog.csdnimg.cn/20210120174330514.png" alt="" /></li><li><code>发送时延发生在机器内部的发送器中，与传输信道的长度（或信号传送的距离）没有任何关系。</code></li></ul><h4 id="传播时延"><a class="markdownIt-Anchor" href="#传播时延"></a> 传播时延</h4><ul><li>电磁波在信道中传播一定的距离需要花费的时间。取决于<strong>电磁波传播速度</strong>和<strong>链路长度</strong>。</li><li>传播时延=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle displaystyle="true" scriptlevel="0"><mfrac><mrow><mi mathvariant="normal">信</mi><mi mathvariant="normal">道</mi><mi mathvariant="normal">长</mi><mi mathvariant="normal">度</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><mrow><mi mathvariant="normal">电</mi><mi mathvariant="normal">磁</mi><mi mathvariant="normal">波</mi><mi mathvariant="normal">传</mi><mi mathvariant="normal">播</mi><mi mathvariant="normal">速</mi><mi mathvariant="normal">度</mi><mo stretchy="false">(</mo><mi>m</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo stretchy="false">)</mo></mrow></mfrac></mstyle></mrow><annotation encoding="application/x-tex">\dfrac{信道长度(m)}{电磁波传播速度(m/s)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">电</span><span class="mord cjk_fallback">磁</span><span class="mord cjk_fallback">波</span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">播</span><span class="mord cjk_fallback">速</span><span class="mord cjk_fallback">度</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord">/</span><span class="mord mathdefault">s</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">信</span><span class="mord cjk_fallback">道</span><span class="mord cjk_fallback">长</span><span class="mord cjk_fallback">度</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。</li><li><code>传播时延发生在机器外部的传输信道媒体上，与信号的发送速率无关</code>，信号传送的距离越远，传播时延就越大。</li><li>对于高速网络链路，提高的仅仅是数据的发送数率而不是比特在链路上的传播速率。</li></ul><h4 id="处理时延"><a class="markdownIt-Anchor" href="#处理时延"></a> 处理时延</h4><ul><li>主机或路由器在收到分组时需要花费一定的时间处理，分析分组首部、从分组中提取数据部分、进行差错检验、查到适当路由等</li></ul><h4 id="排队时延"><a class="markdownIt-Anchor" href="#排队时延"></a> 排队时延</h4><ul><li>分组在经过网络传输时，要经过许多的路由器。但分组在进入路由器后要先在输入队列中排队等待处理。在路由器确定了转发接口后，还要在输出队列中排队等待转发。</li><li>排队延时通常取决于网络当时的通信量。</li></ul><h3 id="时延带宽积"><a class="markdownIt-Anchor" href="#时延带宽积"></a> 时延带宽积</h3><ul><li>指发送端发送的第一个比特即将到达终点时，发送端已经发出了多少个比特。</li><li>时延带宽积又称为以比特为单位的链路长度，即“某段链路现在有多少比特”。</li><li>时延带宽积(bit) = 传播时延(s) <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> 带宽(bit/s)</li></ul><p><img src="https://img-blog.csdnimg.cn/2021012017512582.png" alt="" /></p><h3 id="往返时延round-trip-timertt"><a class="markdownIt-Anchor" href="#往返时延round-trip-timertt"></a> 往返时延（Round-Trip Time，RTT）</h3><ul><li>表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后立即发送确认），总共经历的时延。</li><li>它包括往返传播时延和末端处理时间等</li><li><code>RTT越大，在收到确认之前，可以发送的数据越多。</code></li></ul><h3 id="信道利用率"><a class="markdownIt-Anchor" href="#信道利用率"></a> 信道利用率</h3><p>利用率分为信道利用率和网络利用率。</p><ul><li><code>信道利用率</code>：信道有百分之几的时间是被利用的（有数据通过），空闲信道的利用率为零。</li><li>信道利用率 = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle displaystyle="true" scriptlevel="0"><mfrac><mrow><mi mathvariant="normal">有</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">据</mi><mi mathvariant="normal">通</mi><mi mathvariant="normal">过</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi></mrow><mrow><mi mathvariant="normal">（</mi><mi mathvariant="normal">有</mi><mo>+</mo><mi mathvariant="normal">无</mi><mi mathvariant="normal">）</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">据</mi><mi mathvariant="normal">通</mi><mi mathvariant="normal">过</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi></mrow></mfrac></mstyle></mrow><annotation encoding="application/x-tex">\dfrac{有数据通过时间}{（有+无）数据通过时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4463300000000001em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.677em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">（</span><span class="mord cjk_fallback">有</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord cjk_fallback">无</span><span class="mord cjk_fallback">）</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">据</span><span class="mord cjk_fallback">通</span><span class="mord cjk_fallback">过</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">据</span><span class="mord cjk_fallback">通</span><span class="mord cjk_fallback">过</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li><li><code>网络利用率</code>：全网络的信道利用率的加权平均值。</li></ul><blockquote><p><code>信道利用率并非是越高越好</code>，根据排队论的理论，当某信道的利用率增大时，该信道引起的时延也就迅速增加。当网络的利用率接近最大值1时，网络的时延就趋近于无穷大。<br /><img src="https://img-blog.csdnimg.cn/20210120175629995.png" alt="" /></p></blockquote><h1 id="计算机网络体系结构"><a class="markdownIt-Anchor" href="#计算机网络体系结构"></a> 计算机网络体系结构</h1><p>为了<code>降低网络设计的复杂性</code>，绝大多数网络都组织成一个层次栈（a stack of layer）或分级栈（a stack of level），每一层都建立在其下一层的基础之上。<br /><img src="https://img-blog.csdnimg.cn/20210120194807258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><h2 id="层次结构的要点"><a class="markdownIt-Anchor" href="#层次结构的要点"></a> 层次结构的要点</h2><ul><li>除了在物理媒体上进行的是实通信之外，其余各对等实体间进行的都是虚通信。</li><li>对等层的虚通信必须遵循该层的协议。</li><li>n层的虚通信是通过n/n-1层间接口处n-1层提供的服务以及n-1层的通信（通常也是虚通信）来实现的。</li></ul><h2 id="层次结构划分的原则"><a class="markdownIt-Anchor" href="#层次结构划分的原则"></a> 层次结构划分的原则</h2><ul><li>以功能作为划分层次的基础</li><li>各层之间相互独立，每层只能实现一种相对独立的功能</li><li>每层之间界面自然清晰，易于理解，相互交流少</li><li>结构上可分割开，每层都采用最合适的技术来实现</li><li>保持下层对上层的独立性，上层单层使用下层提供的服务</li><li>层数应适中。若层数太少，则造成每一层的协议太复杂；若层数太多，则体系结构过于复杂，使描述和实现各层功能变得困难。</li><li>整个分层结构应能促进标准化工作</li></ul><h2 id="分层结构中的相关概念"><a class="markdownIt-Anchor" href="#分层结构中的相关概念"></a> 分层结构中的相关概念</h2><h3 id="实体"><a class="markdownIt-Anchor" href="#实体"></a> 实体</h3><ul><li>第n层中的活动元素称为n层实体。同一层的实体称为<code>对等实体(peer)</code>。这些对等体可能是软件过程、硬件设备，或者甚至是人类。换句话说，正是这些对等体为了实现彼此沟通才使用协议来进行通信。</li></ul><h3 id="协议protocol"><a class="markdownIt-Anchor" href="#协议protocol"></a> 协议(protocol)</h3><ul><li>一台机器上的第 n 层与另一台机器上的第 n 层进行对话，该对话中使用的规则和约定统称为第 n 层协议。基本上，所谓协议是指通信双方就如何进行通信的一种约定。</li><li>为进行网络中的对等实体数据交换而建立的规则，标准或者约定称为网络协议。</li><li>协议是水平的,不对等实体之间不存在协议</li><li>协议由<code>语法、语义、同步</code>三部分组成<ul><li>语法(Syntax)：规定传输数据与控制信息的结构或格式</li><li>语义(Semantics)：规定需要发出何种控制信息,完成何种动作或做出何种响应</li><li>同步(Timing)：规定事件实现顺序的详细说明</li></ul></li><li>一个特定的系统所使用的一组协议，即每一层一个协议，称为协议栈（protocol stack）。</li></ul><h3 id="接口interface"><a class="markdownIt-Anchor" href="#接口interface"></a> 接口（interface）</h3><ul><li>接口定义了下层向上层提供哪些原语操作和服务,是上层使用下层服务的入口。</li><li>每层只能为紧邻的层次之间定义接口,不能跨层定义接口。</li></ul><h3 id="服务"><a class="markdownIt-Anchor" href="#服务"></a> 服务</h3><ul><li>服务指下层为紧邻的上层提供的功能调用,它是垂直的。本层能为上一层服务,但要实现本层协议还需要下一层所提供的服务。</li><li>服务定义了该层准备代表其用户执行哪些操作，但是它并不涉及如何实现这些操作。服务与两层之间的接口有关，<code>低层是服务提供者，而上层是服务用户</code>。</li><li>注意：<code>在一层内完成的全部功能并非都称之为服务，只有那些能够被高一层实体“看得见”的功能才能称为服务</code>。</li></ul><h4 id="服务原语service-primitiv"><a class="markdownIt-Anchor" href="#服务原语service-primitiv"></a> 服务原语(Service Primitiv)</h4><ul><li>上层使用下层所提供的服务必须与下层交换一些指令，这些指令在OSI中被称为服务原语。</li><li>一个服务由一组原语（primitive）正式说明，用户进程通过这些原语（操作）来访问该服务。</li><li><code>与协议不同的是，服务原语用于服务提供者与服务用户，而协议是用于服务用户之间的通信</code>。</li><li>OSI将原语划分为4类：</li></ul><table><thead><tr><th style="text-align:left">原语</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">请求(Request)</td><td style="text-align:left">由服务用户发往服务提供者，请求它完成某项工作</td></tr><tr><td style="text-align:left">指示(Indication)</td><td style="text-align:left">由服务提供者发往服务用户，指示发生了某些事件</td></tr><tr><td style="text-align:left">响应(Response)</td><td style="text-align:left">由服务用户发往服务提供者，对前面发生的指示的响应</td></tr><tr><td style="text-align:left">证实(Confirmation)</td><td style="text-align:left">由服务提供者发往服务用户，对前面发生的请求的证实</td></tr></tbody></table><ul><li>Request与Confirm是一对原语，用于上层向本层发起的服务请求；Indication与Response是一对原语，用于本层向上层发起的事件指示。</li><li>有应答服务包括全部4种原语，无应答服务则只有请求和指示。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210121120154633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><p><img src="https://img-blog.csdnimg.cn/20210120203249547.png" alt="" /></p><h4 id="服务与协议的关系"><a class="markdownIt-Anchor" href="#服务与协议的关系"></a> 服务与协议的关系</h4><ul><li>服务是各层向它上层提供的一组原语，定义了两层之间的接口。</li><li>协议是同层对等实体之间交换数据帧、分组和报文的格式及意义等信息的一组规则。</li><li>服务确定了能为上一层提供的操作。</li><li>协议实现为上一层提供服务的具体方法。</li><li>对等实体利用协议来实现它们的服务定义，它们可以自由地改变协议，只要不改变呈现给它们用户的服务即可。</li><li>只有本层协议的实现才能保证向上一层提供服务，本层的服务用户只能看见服务而无法看见下面的协议，即<code>下面的协议对上层的服务用户是透明的</code>。<br /><img src="https://img-blog.csdnimg.cn/20210120223443885.png" alt="" /></li></ul><h3 id="网络体系结构network-architecture"><a class="markdownIt-Anchor" href="#网络体系结构network-architecture"></a> 网络体系结构（network architecture）</h3><ul><li>层和协议的集合称为网络体系结构<br /><img src="https://img-blog.csdnimg.cn/20210120203619190.png" alt="" /><br /><img src="https://img-blog.csdnimg.cn/20210120203922893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="##" /></li></ul><h2 id="网络体系结构的特点"><a class="markdownIt-Anchor" href="#网络体系结构的特点"></a> 网络体系结构的特点</h2><ul><li>以功能作为划分层次的基础。</li><li>n层的实体在实现自身定义的功能时，只能使用第n-1层提供的服务。</li><li>第n层在向第n+1层提供的服务时，此服务不仅包含第n层本身的功能，还包含由下层服务提供的功能。</li><li>仅在相邻层间有接口，且所提供服务的具体实现细节对上一层完全屏蔽。</li></ul><h2 id="封装"><a class="markdownIt-Anchor" href="#封装"></a> 封装</h2><ul><li>各个层次中数据单位都分为两部分，一是数据部分，即SDU；二是控制信息部分，即PCI，它们共同组成PDU</li><li>SDU服务数据单元：为完成用户所要求的功能而应传送的数据</li><li>PCI协议控制信息：控制协议操作的信息</li><li>PDU协议数据单元:对等层次之间传送的数据单位</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mi>S</mi><mi>D</mi><mi>U</mi><mo>+</mo><mi>n</mi><mo>−</mo><mi>P</mi><mi>C</mi><mi>I</mi><mo>=</mo><mi>n</mi><mo>−</mo><mi>P</mi><mi>D</mi><mi>U</mi><mo>=</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>−</mo><mi>S</mi><mi>D</mi><mi>U</mi></mrow><annotation encoding="application/x-tex">n-SDU + n-PCI = n-PDU = ( n - 1 )-SDU</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span><br /><img src="https://img-blog.csdnimg.cn/20210120204834696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></li></ul><blockquote><p>发送端就是对应用层数据一层一层加头的过程，到接收端后，接收端再一层一层去掉头部信息，然后交给对应的应用程序</p></blockquote><h2 id="层次设计问题"><a class="markdownIt-Anchor" href="#层次设计问题"></a> 层次设计问题</h2><h3 id="检错与纠错"><a class="markdownIt-Anchor" href="#检错与纠错"></a> 检错与纠错</h3><ul><li>由于存在电气噪声、随机无线信号、硬件缺陷、<br />软件错误等原因，其中的某些比特到达接收端时已经遭到了损坏（即被逆转了）</li><li>从接收到的信息中发现错误所用的一种机制是<strong>检错</strong>（error detection）编码；然后重新传输接收到的不正确信息，直到它被正确接收为止</li><li>更强大的编码不仅能检错，还能<strong>纠错</strong>（error correction），即从最初收到的可能不正确的比特中恢复正确的消息。</li><li>这两种机制的工作都需要在被传的信息中添加冗余信息。这些冗余信息被较低层次用来保障数据包在个别链路上的正确传输，也可被较高层次用来检测接收到的数据包是否包含了正确的内容。</li></ul><h3 id="路由routing"><a class="markdownIt-Anchor" href="#路由routing"></a> 路由（routing）</h3><ul><li>另一个可靠性问题是找到通过网络的工作路径。在源和目的地之间经常存在多条路径，而且在一个大型网络中可能有一些链路或路由器偶尔发生故障。</li><li>网络应该能自动做出这种路由决策。这个主题就是所谓的路由（routing）。</li></ul><h2 id="面向连接与无连接服务"><a class="markdownIt-Anchor" href="#面向连接与无连接服务"></a> 面向连接与无连接服务</h2><h3 id="面向连接的服务connection-oriented-service"><a class="markdownIt-Anchor" href="#面向连接的服务connection-oriented-service"></a> 面向连接的服务（connection-oriented service）</h3><ul><li>为了使用面向连接的网络服务，服务用户首先必须建立一个连接，然后使用该连接传输数据，最后释放该连接。</li><li><strong>特点</strong><ul><li>静态地分配资源，传输前需要建立连接，<code>适用于在一段时间内向一个目的地址发送大量的数据</code></li><li>在绝大多数情况下，数据位保持原来的顺序，所以数据位都会按照发送的顺序到达</li></ul></li><li><strong>参考模型</strong>：电话系统</li></ul><h3 id="无连接服务conncetionless-service"><a class="markdownIt-Anchor" href="#无连接服务conncetionless-service"></a> 无连接服务（conncetionless service）</h3><ul><li>不需要建立连接直接进行数据的传输，报文之间相互独立，每个报文（信件）都携带了完整的目标地址，每个报文都由系统中的中间节点路由，而且路由独立于后续报文。</li><li>报文（message）在不同的上下文中有不同的称呼；数据包/包（packet）是网络层的报文。</li><li><strong>存储-转发交换（store-and-forward switching）</strong>：中间节点只能在收到报文的全部内容之后再将该报文发送给下一个节点的处理方式</li><li><strong>直通式交换（cut-through switching）</strong>：在报文还没有被全部接收完毕之前就向下一个节点传输的处理方式</li><li>可能发生先发送的报文被延迟，因而后发送的报文比它先到达的情况。</li><li><strong>参考模型</strong>：邮政系统</li></ul><h3 id="服务质量quality-of-service"><a class="markdownIt-Anchor" href="#服务质量quality-of-service"></a> 服务质量（quality of service）</h3><ul><li>可靠与不可靠性是面向连接或者无连接服务的一种性质</li><li><strong>可靠服务</strong>：网络具有纠错、检错、应答机制，能保证数据正确、可靠地传送到目的地。</li><li>一般情况下，一个可靠服务是这样实现的：接收方向发送方确认收到的每个报文，因而发送方可以据此保证报文已经到达接收方。</li><li><strong>不可靠服务</strong>：尽量正确、可靠地传送，不能保证数据正确、可靠地传送到目的地。</li><li>对于不可靠服务，其网络的正确性、可靠性要靠用户或应用来保证</li></ul><h3 id="应答"><a class="markdownIt-Anchor" href="#应答"></a> 应答</h3><ul><li><strong>有应答服务</strong>是指接收方在收到数据后向发送方给出相相应的应答。</li><li>该应答由传输系统内部自动实现，所发送的应答既可以是肯定应答，也可以是否定应答，推收到的数据有错误时发送否定应答。</li><li>例如，文件传输服务就是种有应答服务。</li><li><strong>无应答服务</strong>是指接收方收到数据后不自动给出应答。若需要应答，则由高层实现。</li><li>例如，对于www服务，客户端收到服务器发送的页面文件后不给出应答。</li></ul><h3 id="面向连接服务的类型"><a class="markdownIt-Anchor" href="#面向连接服务的类型"></a> 面向连接服务的类型</h3><ul><li><strong>报文流</strong>：可靠的，报文的边界始终得到保持。</li><li><strong>字节流</strong>：可靠的，该连接只是一个字节流，没有任何报文边界。</li></ul><blockquote><p>对于报文流，发送两个 1024 字节的报文，收到的仍然是两个独立的长度为1024 字节的报文，而决不可能变成一个长度为 2048字节的报文。<br />而对于字节流，当 2048 个字节到达接收方时，接收方无法判断发送方发出的是一个长度为 2048 字节的报文，还是两个长度为1024 字节的报文，或者是 2048个长度只有 1 字节的报文。</p></blockquote><ul><li><strong>不可靠的面向连接服务</strong> ：对于有些应用，因确认而引入的传输延迟是不可接受的。比如说<strong>IP 语音（voice over IP）</strong></li></ul><h3 id="无连接服务的类型"><a class="markdownIt-Anchor" href="#无连接服务的类型"></a> 无连接服务的类型</h3><ul><li><strong>数据报服务（datagram service）</strong>：不可靠的无连接服务，一般不会给发送方反馈任何确认消息。</li><li><strong>有确认的数据报服务（acknowledged datagram service）</strong>：对每一个接收到的报文都响应一个确认。</li><li><strong>请求-应答服务（request-reply service）</strong>：发送方传输一个包含了某个请求的数据报；接受方以<code>一个包含了请求结果的应答数据报</code>作为反馈。</li></ul><blockquote><p>请求-应答服务通常用在客户机-服务器模型中：客户机发出一个请求，然后服务器对此做出响应。例如，一个手机客户向地图服务器发出一个请求，要求查询其当前位置的地图数据。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210122181039981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70," alt="" /></p><h1 id="osi-参考模型open-systems-interconnection"><a class="markdownIt-Anchor" href="#osi-参考模型open-systems-interconnection"></a> OSI 参考模型（Open Systems Interconnection）</h1><ul><li>该模型基于国际标准化组织（ISO，International Standards Organization）的提案，作为各层协议迈向国际标准化的第一步（Day 和 Zimmermann，1983），并且于 1995 年进行了修订（Day，1995）。</li><li>它涉及如何连接开放的系统——即那些为了与其他系统通信而开放的系统</li><li>OSI 模型有 7 层。适用于这 7 层的基本原则简要概括如下。<ul><li>应该在需要一个不同抽象体的地方创建一层。</li><li>每一层都应该执行一个明确定义的功能。</li><li>每一层功能的选择应该向定义国际标准化协议的目标看齐。</li><li>层与层边界的选择应该使跨越接口的信息流最小。</li><li>层数应该足够多，保证不同的功能不会被混杂在同一层中，但同时层数又不能太多，以免体系结构变得过于庞大。</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20210123233744274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /><br /><img src="https://img-blog.csdnimg.cn/20210128151057941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><h2 id="物理层physical-layer"><a class="markdownIt-Anchor" href="#物理层physical-layer"></a> 物理层（physical layer）</h2><ul><li>物理层关注在一条通信信道上传输原始比特。</li><li>物理层的设计主要涉及物理接口的机械电气功能和过程特性，以及物理层接口连接的传输介质等问题。</li><li>物理层的主要任务是在物理媒体上实现比特流的<code>透明传输</code>。物理层的传输单位是比特。</li></ul><blockquote><p>透明传输：指不管所传数据是什么样的比特组合，都应当能够在链路上传送。</p></blockquote><ul><li>物理层的功能<ul><li>定义接口特性</li><li>定义传输模式（单工、半双工、双工）</li><li>定义传输速率</li><li>比特同步</li><li>比特编码（用什么电压表示1，用什么电压表示0）</li></ul></li></ul><h2 id="数据链路层data-link-layer"><a class="markdownIt-Anchor" href="#数据链路层data-link-layer"></a> 数据链路层（data link layer）</h2><ul><li>数据链路层的主要任务是把网络层传下来的IP数据报组装成帧。数据链路层/链路层的传输单位是帧。</li><li>数据链路层的功能<ul><li>成帧（定义帧的开始和结束）</li><li>差错控制（帧错和位错）</li><li>流量控制（避免快速发送方用数据“淹没”慢速接收方）</li><li>访问/接入控制（控制对信道的访问）</li></ul></li><li>广播式网络的数据链路层还有另一个问题：如何控制对共享信道的访问。数据链路层的一个特殊子层，即<code>介质访问控制子层</code>，就是专门处理这个问题的。</li><li>典型的数据链路层协议有SDLC、HDLC、PPP、STP和帧中继等</li></ul><h2 id="网络层network-layer"><a class="markdownIt-Anchor" href="#网络层network-layer"></a> 网络层（network layer）</h2><ul><li>网络层的传输单位是数据报。它的主要任务是把<code>分组从源端传到目的端</code>，为分组交换网上的不同主机提供通信服务。</li><li>网络层的功能<ul><li>路由选择</li><li>流量控制</li><li>差错控制</li><li>拥塞控制</li><li>网际互连（允许异构网络相互连接成为互联网络）</li></ul></li><li>在广播式网络中，路由问题比较简单，所以网络层往往比较单薄，甚至根本不存在。</li><li>网络层的协议有IP、IPX、ICMP、IGMP、ARP、RARP和OSPF等</li></ul><h2 id="传输层transport-layer"><a class="markdownIt-Anchor" href="#传输层transport-layer"></a> 传输层（transport layer）</h2><ul><li>传输层也称运输层，传输单位是报文段或用户数据报，传输层负责主机中两个进程之间的通信，功能是<code>为端到端连接提供可靠的传输服务</code>，为端到端连接提供流量控制、差错控制、服务质量、数据传输管理等服务。</li><li>传输层的基本功能是接收来自上一层的数据，在必要的时候把这些数据分割成较小的单元，然后把这些数据单元传递给网络层，<code>并且确保这些数据单元正确地到达另一端</code>。</li><li>传输层是真正的<code>端-端</code>的层，它自始自终将数据从源端携带到接收方。换句话说，源机器上的一个程序利用报文头和控制信息与目标机器上的一个类似程序进行会话。</li><li><code>点到点</code>：可以理解为主机到主机之间的通信，一个点指一个硬件地址或IP地址，网络中参与通信的主机通过硬件地址或IP地址标识的；</li><li><code>端到端</code>：指运行在不同主机内的两个进程之间的通信，一个进程由一个端口号来标识，所以称端到端通信</li><li>第 1 层到第 3 层是链式连接的，而第 4层到第 7 层是端-端的</li></ul><h2 id="会话层session-layer"><a class="markdownIt-Anchor" href="#会话层session-layer"></a> 会话层（session layer）</h2><ul><li>会话层允许不同机器上的用户建立会话。</li><li>向表示层实体/用户进程（运行的程序）建立连接并在连接上有序地传输数据，称为会话，也是建立同步（SYN）。</li><li>会话层提供的服务<ul><li>对话控制（dialog control）（记录该由谁来传递数据）</li><li>令牌管理（token management）（禁止双方同时执行同一个关键操作）</li><li>同步功能（synchronization）（在一个长传输过程中设置一些断点，以便在系统崩溃之后还能恢复到崩溃前的状态继续运行）</li></ul></li><li>会话层利用传输层提供的<code>端到端</code>的服务，向表示层提供它的增值服务。</li></ul><h2 id="表示层presentation-layer"><a class="markdownIt-Anchor" href="#表示层presentation-layer"></a> 表示层（presentation layer）</h2><ul><li>表示层以下的各层最关注的是如何传递数据位，而表示层关注的是<code>所传递信息的语法和语义</code>。</li><li>不同机器采用的编码和表示方法不同，使用的数据结构不同。为了使不同的数据和信息之间能够互相交换，表示层采用抽象的标准方法定义数据结构</li><li>表示层管理这些抽象的数据结构，并允许定义和交<br />换更高层的数据结构。</li></ul><h2 id="应用层application-layer"><a class="markdownIt-Anchor" href="#应用层application-layer"></a> 应用层（application layer）</h2><ul><li>应用层包含了用户通常需要的各种各样的协议。</li><li>应用层为特定类型的网络应用提供访问OSI环境的手段。因为用户的实际应用多种多样，就要求应用层采用不同的协议来解决不同应用类型的需求。</li><li>典型的协议有：文件传输协议FTP、电子邮件协议SMTP、万维网HTTP等。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210128150820759.png" alt="" /></p><h1 id="tcpip-参考模型tcpip-reference-model"><a class="markdownIt-Anchor" href="#tcpip-参考模型tcpip-reference-model"></a> TCP/IP 参考模型（TCP/IP Reference Model）</h1><ul><li>该参考模型不仅被所有广域计算机网络的鼻祖 ARPANET 所采用，而且被其继任者——全球范围的 Internet 所使用。</li><li>该体系结构最初由（Cerf 和 Kahn，1974）描述，后来在（Leiner等，1989）中又被重新修订并得到 Internet 团体的标准化。TCP/IP 模型背后的设计思想在（Clark，1988）中进行了详细讨论。<br /><img src="https://img-blog.csdnimg.cn/2021012814564648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></li><li>设计目标<ul><li>以无缝的方式将多个网络连接起来</li><li>是即使在损失子网硬件的情况下网络还能够继续工作，原有的会话不能被打断</li><li>这些要求导致本参考模型选择了<code>数据包交换网络</code>，它以一个<code>可运行在不同网络之上的无连接网络层</code>为基础。</li></ul></li></ul><h2 id="链路层"><a class="markdownIt-Anchor" href="#链路层"></a> 链路层</h2><ul><li>该层描述了链路必须完成什么功能才能满足无连接的互联网络层的需求，比如串行线和经典以太网链路。</li><li><code>这不是真正意义上的一个层，而是主机与传输线路之间的一个接口。</code></li></ul><h2 id="互联网层internet-layer"><a class="markdownIt-Anchor" href="#互联网层internet-layer"></a> 互联网层（internet layer）</h2><ul><li>互联网层是将整个网络体系结构贯穿在一起的关键层。它大致对应于OSI 的网络层。</li><li>该层的任务是允许主机将数据包注入到任何网络，并且让这些数据包独立地到达接收方（接收方可能在不同的网络上）。</li><li>互联网层定义了官方的数据包格式和协议，该协议称为<code>因特网协议</code>（IP，Internet Protocol），与之相伴的还有一个辅助协议，称为<code>因特网控制报文协议</code>（ICMP，Internet Control Message Protocol）。</li><li>数据包的路由是该层最主要的问题，同时该层还要考虑拥塞控制问题。</li></ul><h2 id="传输层"><a class="markdownIt-Anchor" href="#传输层"></a> 传输层</h2><ul><li>它的设计目标是允许源主机和目标主机上的对等实体进行对话，犹如 OSI 的传输层一样。</li><li>这里定义了两个<code>端-端</code>的传输协议<ul><li><code>传输控制协议</code>（TCP，Transport Control Protocol）<ul><li>它是一个<code>可靠的、面向连接的协议</code>，允许从一台机器发出的字节流正确无误地交付到互联网上的另一台机器。</li><li>它把输入的字节流分割成离散的报文，并把每个报文传递给互联网层。</li><li>在目标机器，接收 TCP 进程把收到的报文重新装配到输出流中。</li><li>TCP 还负责处理流量控制。</li></ul></li><li><code>用户数据报协议</code>（UDP，User Datagram Protocol）<ul><li>它是一个<code>不可靠的、无连接协议</code>，适用于那些不想要 TCP 的有序性或流量控制功能，而宁可自己提供这些功能的应用程序。</li><li>UDP 被广泛应用于那些一次性的基于客户机-服务器类型的<code>“请求应答”查询应用</code>，以及那些<code>及时交付比精确交付更加重要</code>的应用，比如传输语音或者视频。</li></ul></li></ul></li></ul><h2 id="应用层"><a class="markdownIt-Anchor" href="#应用层"></a> 应用层</h2><ul><li>TCP/IP 模型并没有会话层和表示层，应用层简单包含了所需的任何会话和表示功能。</li><li>它包含了所有的高层协议。<ul><li>虚拟终端协议（TELNET）</li><li>文件传输协议（FTP）</li><li>电子邮件协议（SMTP）</li><li>将主机名字映射到它们网络地址的域名系统（DNS，Domain NameSystem）</li><li>用于获取万维网页面的 HTTP</li><li>用于传送诸如语音或者电影等实时媒体的<br />RTP</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20210128150935106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><h1 id="五层混合模型"><a class="markdownIt-Anchor" href="#五层混合模型"></a> 五层混合模型</h1><p><img src="https://img-blog.csdnimg.cn/20210128145907931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_11,color_FFFFFF,t_70" alt="" /><br /><img src="https://img-blog.csdnimg.cn/20210128151315178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><h2 id="模型结构"><a class="markdownIt-Anchor" href="#模型结构"></a> 模型结构</h2><ul><li>物理层规定了如何在不同的介质上以电气（或其他模拟）信号传输比特。</li><li>链路层关注的是如何在两台直接相连的计算机之间发送有限长度的消息，并具有指定级别的可靠性。以太网和 802.11是链路层协议的例子。</li><li>网络层主要处理如何把多条链路结合到网络中，以及如何把网络与网络联结成互联网络，以便使我们可以在两个相隔遥远的计算机之间发送数据包。<code>网络层的任务包括找到传递数据包所走的路径</code>。IP 是我们将要学习的网络层主要协议案例。</li><li>传输层增强了网络层的传递保证，通常具有更高的可靠性，而且提供了数据交付的抽象，比如满足不同应用需求的可靠字节流。TCP 是传输层协议的一个重要实例。</li><li>应用层包含了使用网络的应用程序。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210128151021347.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><h2 id="数据传输"><a class="markdownIt-Anchor" href="#数据传输"></a> 数据传输</h2><p><img src="https://img-blog.csdnimg.cn/20210128151245633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><h1 id="osi-参考模型与-tcpip-参考模型的比较"><a class="markdownIt-Anchor" href="#osi-参考模型与-tcpip-参考模型的比较"></a> OSI 参考模型与 TCP/IP 参考模型的比较</h1><p><img src="https://img-blog.csdnimg.cn/20210128160922339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><h2 id="相同点"><a class="markdownIt-Anchor" href="#相同点"></a> 相同点</h2><ul><li>两者都以协议栈概念为基础，并且协议栈中的协议彼此相互独立。</li><li>两个模型中各个层的功能也大致相似。例如，在两个模型中，<code>传输层以及传输层以上各层都为希望通信的进程提供了一种端-端的独立于网络的传输服务</code>。</li><li>在这两个模型中，传输层之上的各层都是传输服务的用户，并且是面向应用的。</li></ul><h2 id="不同点"><a class="markdownIt-Anchor" href="#不同点"></a> 不同点</h2><table><thead><tr><th style="text-align:left">OSI(Open System Interconnection)</th><th style="text-align:left">TCP/IP(Transmission Control Protocol / Internet Protocol)</th></tr></thead><tbody><tr><td style="text-align:left">OSI模型中清晰地定义了服务,接口和各种协议. OSI模型是协议独立的</td><td style="text-align:left">TCP/IP模型中定义的服务,接口和各种协议并不能明确地区分. TCP/IP模型是协议独立的</td></tr><tr><td style="text-align:left">OSI 参考模型在协议发明之前就已经产生，这意味着 OSI 模型不会偏向于任何一组特定的协议，这个事实使得 OSI 模型更具有通用性。</td><td style="text-align:left">协议先出现，TCP/IP 模型只是已有协议的一个描述，所以协议与模型高度吻合。但是TCP/IP 模型并不适合任何其他协议栈。</td></tr><tr><td style="text-align:left">OSI参考模型最初只考虑到用一种标准的公用数据网将各种不同的系统互联</td><td style="text-align:left">TCP/IP 模型在设计之初就考虑到了多种异构网的互联问题，并将网际协议（IP）作为一个单独的重要层次</td></tr><tr><td style="text-align:left">OSI 模型的网络层同时支持无连接和面向连接的通信，但是传输层只支持面向连接的通信</td><td style="text-align:left">TCP/IP 模型在网络层只支持一种模式（无连接），但是在传输层同时支持两种通信模式</td></tr></tbody></table><h1 id="osi-模型和协议的评判"><a class="markdownIt-Anchor" href="#osi-模型和协议的评判"></a> OSI 模型和协议的评判</h1><h2 id="糟糕的时机"><a class="markdownIt-Anchor" href="#糟糕的时机"></a> 糟糕的时机</h2><ul><li>一个标准在什么时候建立对于该标准的成功与否绝对非常重要的。MIT 的 David Clark 有一个关于标准的理论，他称之为两头大象的启示<br /><img src="https://img-blog.csdnimg.cn/20210128163916581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></li><li>当 OSI 协议出现的时候，与之竞争的 TCP/IP 协议已经被广泛地应用于大学和科研机构。虽然几十亿美元的投资热潮尚未开始，但是，学术市场足够大，使得许多厂商开始谨慎地提供 TCP/IP 产品。当 OSI 出现的时候，这些厂商并不想支持第二个协议栈，除非他们被迫这样做，因此 OSI 没有得到初始的投入。</li></ul><h2 id="糟糕的技术"><a class="markdownIt-Anchor" href="#糟糕的技术"></a> 糟糕的技术</h2><ul><li>之所以选择 7 层的原因很大程度上是出于政策上的考虑，而非技术因素所决定。其中的两层（会话层和表示层）几乎是空的，而另外两层（数据链路层和网络层）又包含了太多内容。</li><li>OSI 模型以及相应的服务定义和协议都极其复杂。它们难以实现，而且操作起来也很低效。</li></ul><h2 id="糟糕的实现"><a class="markdownIt-Anchor" href="#糟糕的实现"></a> 糟糕的实现</h2><ul><li>由于 OSI 模型和协议过于复杂，最初的那些实现不仅庞大，而且很笨拙，效率也很慢。</li><li>相反，TCP/IP 的早期实现之一是作为 Berkeley UNIX 的一部分，运行非常好（更不用说它是免费的）。很快，人们就开始使用它，进而形成了一个庞大的用户群，这进一步促进了它的提高和改进，然后又导致了更大的用户群。这是螺旋式上升而不是下降。</li></ul><h2 id="糟糕的政策"><a class="markdownIt-Anchor" href="#糟糕的政策"></a> 糟糕的政策</h2><ul><li>由于 TCP/IP 最初的实现，很多人（特别在学术界）都把 TCP/IP 看作是 UNIX 的一部分，而 UNIX 在 20 世纪 80 年代的学术圈中盛极一时，备受宠爱。</li><li>相反，OSI 则被认为是欧洲电信部门、欧共体以及后来的美国政府的产物。尽管这种观点部分是正确的，但是政府官僚们试图把技术上不足的标准强加给那些实际开发计算机网络的可怜的研究人员和程序员，而政府部门的强制性对 OSI 无济于事。</li></ul><h1 id="tcpip-参考模型的评判"><a class="markdownIt-Anchor" href="#tcpip-参考模型的评判"></a> TCP/IP 参考模型的评判</h1><ul><li>该模型并没有明确区分服务、接口和协议的概念。因此，在使用新技术来设计新网络时，TCP/IP 模型并不是一个很好的参照物。</li><li>TCP/IP 模型一点也不通用，它并不适合于用来描述TCP/IP 之外的任何其他协议栈。例如，试图使用TCP/IP 模型来描述蓝牙（Bluetooth）是完全不可能的。</li><li>在分层协议的上下文中，<code>链路层并不是通常意义上的一层。它是一个接口</code>（位于网络层和数据链路层之间），而接口和层的区别非常重要。</li><li><code>TCP/IP 模型并没有区分物理层和数据链路层</code>。这是两个完全不同的层。物理层必须要考虑铜线、光纤和无线通信的传输特征；而数据链路层的任务则是确定帧的开始和结束，并且按照所需的可靠程度把帧从一边发送到另一边。一个正确的模型应该包括这两个独立的层，TCP/IP 模型没有这样做。</li></ul><hr /><h1 id="物理层"><a class="markdownIt-Anchor" href="#物理层"></a> 物理层</h1><p><img src="https://s2.loli.net/2022/01/05/qUAa1tnOEdfN2rH.png" alt="" /></p><h2 id="基础概念"><a class="markdownIt-Anchor" href="#基础概念"></a> 基础概念</h2><ul><li>数据、信号、码元<ul><li><p>数据是值传送信息的实体。信号是数据的电气或电磁表现，是数据传输过程中的存在形式。</p></li><li><p>数据和信号都可以用“模拟的”或“数字的”修饰</p><ul><li><code>连续变化</code>的数据或信号成为模拟数据或信号</li><li>取值仅允许为<code>有限的几个离散数值</code>的数据或信号成为数字数据或信号</li></ul></li><li><p>数据的传输方式可以分为串行传输和并行传输</p><ul><li>串行传输指<code>一个个比特按照时间顺序传输</code></li><li>并行传输指<code>多个比特通过多条信道同时传输</code></li></ul></li><li><p>码元是指<code>用一个固定时长的信号波形（数字脉冲）表示一位k进制数字</code>，代表不同离散数值的基本波形。这个时长内的信号称为k进制码元，该时长称为<code>码元宽度</code>。</p><ul><li>1码元可以携带多个比特的信息量，例如，在使用二进制编码时，有两种不同的码元：0状态和1状态</li></ul><p><img src="https://s2.loli.net/2022/01/05/g6GY3WOS2Twu5hJ.png" alt="" /></p></li></ul></li></ul><hr /><ul><li><p>速率、波特、带宽</p><ul><li>速率也叫数据率，是指数据的<code>传输速率</code>，表示单位时间内传输的数据量。可以用<code>码元传输速率</code>和<code>信息传输速率</code>来表示<ul><li>码元传输速率/码元速率/波形速率/调制速率：表示单位时间内数字通信系统所传输的码元个数（也可称为<code>脉冲个数或信号变化的次数</code>），单位是<b>波特(Baud)</b>。<ul><li>1波特表示数字通信系统每秒传输一个码元，码元可以是多进制的。</li></ul></li></ul></li><li>信息传输速率/信息速率/比特率：表示单位时间内数字通信系统传输的<code>二进制码元</code>个数（即比特数），单位是b/s</li></ul><blockquote><p>若一个码元携带n bit的信息量，则M Baud的码元传输速率所对应的信息传输速率为 n * M bit/s<br><br />若一个码元为K进制码元，则M Baud的码元传输速率所对应的信息传输速率为 M * <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>K</mi></mrow><annotation encoding="application/x-tex">log_2K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> bit/s</p></blockquote><ul><li>带宽：表示单位时间内从网络中某一点到另一点所能通过的<code>最高数据率</code>，单位是b/s</li></ul><hr /></li><li><p>信源、信道、信宿</p><ul><li><p>信源时产生和发送数据的源头。信宿是接收数据的终点。</p></li><li><p>信道和电路不同，<code>信道是信号的传输媒介</code>。</p></li><li><p>模拟通信系统和数字通信系统</p><ul><li>普通的电话、广播、电视等都属于模拟通信系统</li></ul><p><img src="https://s2.loli.net/2022/01/05/qjtHuEV7S4InkRU.png" alt="" /></p><ul><li>计算机通信、数字电话以及数字电视都属于数字通信系统</li></ul><p><img src="https://s2.loli.net/2022/01/05/U3myY5c8pgHAzTR.png" alt="" /></p></li></ul></li></ul><hr /><ul><li>数据的同步技术<ul><li><p>异步传输</p><ul><li>没有时钟，用户可以随时发送信号</li></ul><p><img src="https://s2.loli.net/2022/01/05/bHzNT2R9ZmDV1Et.png" alt="" /></p><ul><li>异步通信实现容易，但每传输一个字符要多使用2~3位，适用于低速通信</li></ul></li><li><p>同步传输</p><ul><li>在线路中嵌入时钟，强制用户基于时钟通信</li><li>不需要附加起始位和停止位，<code>在发送一组字符或数据块之前要发送一个同步字符</code>，用于接收方同步检测</li></ul><p><img src="https://s2.loli.net/2022/01/05/UydIWNrQ1bn9mvP.png" alt="" /></p></li></ul></li></ul><hr /><ul><li><p>信道的通信方式</p><ul><li>单工通信</li></ul><p><img src="https://s2.loli.net/2022/01/05/mGzMEU3gjVZQNF5.png" alt="" /></p><ul><li>半双工通信</li></ul><p><img src="https://s2.loli.net/2022/01/05/kGhXliry3JpdxsK.png" alt="" /></p><ul><li>全双工通信</li></ul><p><img src="https://s2.loli.net/2022/01/05/x947mOE1Rq3pGw5.png" alt="" /></p></li></ul><hr /><ul><li>信号的传输方式<ul><li>基带传输<ul><li>数字信号是一个离散的方波，“0”代表低电平，“1”代表高电平，<code>这种方波固有的频带称为基带，方波信号称为基带信号</code></li><li><code>基带实际上就是数字信号所占用的基本频带</code></li><li>基带传输就是在信道直接传输数字信号。</li></ul></li><li>频带传输<ul><li>频带传输是指<code>将数字信号调制成音频信号再发送和传输，到达接收端时再把音频信号解调成原来的数字信号</code></li><li>利用频带传输，可以实现多路复用，提高信道利用率</li></ul></li><li>宽带传输<ul><li>宽带传输采用75 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Ω</mi></mrow><annotation encoding="application/x-tex">\Omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Ω</span></span></span></span> 的CATV电视同轴电缆或光纤作为传输媒体，带宽为300MHz。</li><li>使用时通常<code>将整个带宽划分为若干个子频带</code>，可以利用宽带传输实现声音、文字和图像的一体化传输。</li></ul></li></ul></li></ul><hr /><h2 id="数据通信的理论基础"><a class="markdownIt-Anchor" href="#数据通信的理论基础"></a> 数据通信的理论基础</h2><h3 id="傅里叶变换"><a class="markdownIt-Anchor" href="#傅里叶变换"></a> 傅里叶变换</h3><p><img src="https://s2.loli.net/2022/01/05/dbsiCLBOxA8u1Vy.png" alt="" /></p><ul><li>计算时，n取值越大（谐波数越大），计算值越接近真实值，但是谐波数越多，计算时间越长，信号传输越慢。</li></ul><hr /><h3 id="信道的最大数据速率"><a class="markdownIt-Anchor" href="#信道的最大数据速率"></a> 信道的最大数据速率</h3><ul><li>Nyquist’s theorem<ul><li>适用于无噪声信道</li><li>如果一个任意信号通过了一个带宽为B的低通滤波器，那么只要进行<code>每秒 2B 次（确切）采样（极限码元传输速率为2B Baud ）</code>，就可以完全重构出被过滤的信号。</li><li>如果信号包含了<code>V个离散等级</code>，则尼奎斯特的定理为：$$最大比特率,=,2B,log_2V,bits/sec$$</li></ul></li></ul><hr /><ul><li>Shannon’s theorem<ul><li>热噪声的数量可以用<code>信号功率与噪声功率的比值</code>来度量，这样的比值称为信噪比 <code>SNR, Signal-to-Noise Ratio ）</code></li><li>将信号功率记作S，噪声功率记作N，则信噪比为 S/N 。通常情况下为了适用很大的范围，该比率表示成对数形式<b> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>10</mn></msub><mi>S</mi><mi mathvariant="normal">/</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">10log_{10}S/N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> </b>，对数的取值单位称为分贝(dB, decibel)。</li><li>对于一条带宽为BHz 、噪声比是 S/N 的有噪声信道，其最大数据速率或者容量(capacity)是$$最大比特率,=,B,log_2(1+S/N) $$</li></ul></li></ul><p><img src="https://s2.loli.net/2022/01/05/7radiwyMJfNGbjU.png" alt="" /></p><hr /><h2 id="数据编码与调制"><a class="markdownIt-Anchor" href="#数据编码与调制"></a> 数据编码与调制</h2><ul><li><p>数据为了传输的目的都需要转变成信号。把数据变为模拟信号的过程称为<code>调制</code>，把数据变为数字信号的过程称为<code>编码</code></p></li><li><p>数字数据可以通过数字发送器转换为数字信号传输，也可以通过调制器转换成模拟信号传输；模拟数据可以通过PCM编码器转换成数字信号传输，也可以通过放大器调制器转换成模拟信号传输</p></li></ul><p><img src="https://s2.loli.net/2022/01/05/lXPnpWYDI6fvhC3.png" alt="" /></p><hr /><h3 id="数字数据编码为数字信号"><a class="markdownIt-Anchor" href="#数字数据编码为数字信号"></a> 数字数据编码为数字信号</h3><ul><li>数字信号<code>用于基带传输</code>，在基本不改变数字数据信号频率的情况下，直接传输数字信号。</li></ul><p><img src="https://s2.loli.net/2022/01/05/5f8TXgMBoZ6vq4G.png" alt="" /></p><ol><li><p>归零编码(RZ)</p><ul><li>高电平代表1、低电平代表0，<code>每个时钟周期的中间都跳到低电平</code></li><li>接收方根据跳变调整时钟基准，从而实现同步。</li><li>归零要占用一部分带宽，传输效率受影响。</li></ul></li><li><p>非归零编码(NRZ)</p><ul><li>和归零编码的区别是<code>不用归零</code>，一个周期都可以用来传输数据</li><li>但是无法传输时钟信号，难以同步。</li></ul></li><li><p>反向非归零编码(NRZI)</p><ul><li>用信号的<code>翻转代表0</code>、信号保持不变代表1.</li><li>反转本身可以作为通知机制，既能传输时钟信号，又不损失带宽</li><li>NRZI编码会遇到一个严重问题，当连续发送多位&quot;0&quot;或&quot;1&quot;信号，会造成数据信号长时间不翻转，时读取的时序发生错误，因此需要执行位填充。</li></ul></li></ol><p><img src="https://s2.loli.net/2022/01/05/UtlzH68mE3IjAuQ.png" alt="" /></p><ol start="4"><li><p>曼彻斯特编码(Manchester Encoding)</p><ul><li>将一个码元分成两个相等的间隔，<code>前一个间隔为高电平而后一个间隔为低电平代表码元1</code>；码元0则相反。</li><li>位中间的跳变既作为时钟信号，又作为数据信号，<code>但是它占用的频带带宽为原始基带带宽的两倍</code></li></ul></li><li><p>差分曼彻斯特编码</p><ul><li>码元为1，前半个码元的电平与上一码元的后半个码元电平相同；码元为0则相反。</li><li>每个码元中间有电平跳转，可实现自同步，抗干扰性好</li></ul></li></ol><p><img src="https://s2.loli.net/2022/01/05/SVi2rgNIBzkbequ.png" alt="" /></p><ol start="6"><li>4B/5B映射<ul><li>将要发送数据流的每4位作为一组，按照4B/5B编码规则转换为相应的5位码。</li></ul></li></ol><p><img src="https://s2.loli.net/2022/01/05/BPODYHfsw23Ap6j.png" alt="" /></p><div class="code-wrapper"><pre><code class="hljs"> - 5位码共32种组合，只采用其中16种对应4位码，其他的16种作为控制码或保留</code></pre></div><hr /><h3 id="数字数据调制为模拟信号"><a class="markdownIt-Anchor" href="#数字数据调制为模拟信号"></a> 数字数据调制为模拟信号</h3><ul><li>根据信道中传输的信号是否经过调制，将系统分为基带传输系统和<code>通带</code>传输系统。即经过调制的数字传输系统就是数字带通传输系统，未经过调制的传输系统就是数字基带传输系统。</li><li>数字调制可<code>借助通带传输完成</code>，即针对通带内的载波信号进行调节或调制。我们可以调制载波信号的<code>振幅、频率或相位。</code></li></ul><hr /><p><img src="https://s2.loli.net/2022/01/05/o5biT6xJ4ya8zOB.png" alt="" /></p><ol><li><p>幅移键控ASK</p><ul><li>通过改变载波信号的<code>振幅</code>来表示数字信号0和1</li><li>比较容易实现，但是抗干扰能力差</li></ul></li><li><p>频移键控FSK</p><ul><li>通过改变载波信号的<code>频率</code>来表示数字信号0和1</li><li>容易实现，抗干扰能力强，应用广泛</li></ul></li><li><p>相移键控PSK / 二进制相移键控BPSK</p><ul><li>通过改变载波信号的<code>相位</code>来表示数字信号0和1</li></ul></li></ol><hr /><ol start="4"><li><p>正交振幅调制QAM</p><ul><li>频率和相位有关，即<code>频率是相位随时间的变化率</code>，所以一次只能调制频率和相位两个中的一个。</li><li>通常情况下，<code>振幅和相位可以结合起来一起调制</code>。可以把这些调制模式结合起来综合使用，以便使每个符号传输更多的比特。</li><li>在频率相同的前提下，将ASK和PSK结合起来，形成叠加信号。设波特率为<code>B</code>，采用<code>m</code>个相位，每个相位有<code>n</code>种振幅，则QAM技术的数据传输率<code>R</code>为 $$R = Blog_2(mn),b/s$$</li></ul><p><img src="https://s2.loli.net/2022/01/05/Kx4aW9P76sLMGgN.png" alt="" /></p><ul><li>这种类型的图称为星座图(constellation diagram)</li><li>一个点的<code>相位是以它为起点到原点的线与x正轴之间的角度</code>来表示，一个点的<code>振幅则是该点到原点的距离</code>。</li><li>图(b)采用了振幅和相位的16种组合，因此可用每个符号传输4个比特，这种调制方式称为 <code>QAM-16</code></li></ul></li></ol><hr /><h3 id="模拟数据编码为数字编码"><a class="markdownIt-Anchor" href="#模拟数据编码为数字编码"></a> 模拟数据编码为数字编码</h3><ul><li><p>模拟传输</p><ul><li><p><code>调幅、调频、调相</code></p></li><li><p>脉冲编码调制PCM</p><p><img src="https://s2.loli.net/2022/01/05/XIzRWQ9GdsviESV.png" alt="" /></p><ul><li><code>采样定理</code>：<code>带宽是指信号最高频率与最低频率之差</code>，单位为Hz。因此，将模拟信号转换为数字信号时，假设原始信号中的最大频率为f，那么采样频率<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi mathvariant="normal">采</mi><mi mathvariant="normal">样</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{采样}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">采</span><span class="mord cjk_fallback mtight">样</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> <code>必须大于等于最大频率f的两倍</code>，才能保证采样后的数字信号完整保留原始信息。（奈奎斯特定理）</li><li>脉码调制的过程又<b>取样、量化和编码</b>三步构成<ul><li>取样：按照一定的时间间隔采样测量模拟信号幅值</li><li>量化：将取样点处测得的信号幅值分级取整的过程</li><li>编码：将量化后的整数值用二进制里表示。</li></ul></li></ul><blockquote><p>脉码调制中，分级取证量化时引进了误差。<code>分级越细，误差越小，但是每个样本点编码所需的比特数越多</code></p></blockquote><p><img src="https://s2.loli.net/2022/01/05/63fja9XuJlAgyQn.png" alt="" /></p><p><img src="https://s2.loli.net/2022/01/05/SErPD3ZpoaeMCjn.png" alt="" /></p></li></ul></li></ul><hr /><h3 id="模拟数据调制为模拟信号"><a class="markdownIt-Anchor" href="#模拟数据调制为模拟信号"></a> 模拟数据调制为模拟信号</h3><ul><li>为了实现传输的有效性，可能需要较高的频率。这种调制方式还可以使用频分复用(FDM)技术，充分利用带宽资源</li><li>电话机和本地局交换机采用模拟信号传输模拟数据的编码方式：<code>模拟的声音数据是加载到模拟的载波信号中传输的</code></li></ul><hr /><h2 id="多路复用技术"><a class="markdownIt-Anchor" href="#多路复用技术"></a> 多路复用技术</h2><ul><li>多路复用：技术就是把许多信号在单一的传输线路和用单一的传输设备来进行传输的技术</li></ul><hr /><ul><li><p>频分复用(FDM，Frequency Division Multiplexing)</p><ul><li>将频谱分成几个频段，每个用户完全拥有其中的一个频段来发送自己的信号</li></ul><p><img src="https://s2.loli.net/2022/01/05/gHu67l8fOWs5IxJ.png" alt="" /></p><ul><li>比语音通信所需多出来的那部分频带称为<code>保护带(guardband)</code>，它使信道之间完全隔离。但是相邻信道之间仍然可能存在某种重叠。</li><li>采用频分多路复用时，每个信道的频率会得到不同程度的<code>提升</code></li></ul><p><img src="https://s2.loli.net/2022/01/05/vXRKPrNmsY5uwGp.png" alt="" /></p><ul><li>发送数字数据时完全有可能把频谱更有效率地划分成<code>没有保护带</code>。</li><li>在<code>正交频分复用</code>(OFDM, Orthogonal Frequency Division Multiplexing)中，信道带宽被分成许多独立发送数据的子载波（例如 QAM ）。</li><li>子载波在频域中被紧紧地包裹在一起。因此，从每个子载波发出的信号能扩散到相邻子载波。</li></ul></li></ul><hr /><ul><li>波分多路复用(WDM，Wavelength Division Multiplexing)</li></ul><p><img src="https://s2.loli.net/2022/01/05/UBQzvARDKafqort.png" alt="" /></p><ul><li>每条光纤的能量位于不同的波长处。四束光波被<code>组合到一条共享的光纤上</code>，然后传输给远处的接收方。</li><li>在远端，这束光又被分离到与输入端一样多的光纤上。</li></ul><hr /><ul><li><p>时分多路复用(TDM, Time Division Multiplexing)</p><ul><li>用户以<code>循环</code>的方式轮流工作。每个用户<code>周期性地获得整个带宽非常短的一个时间</code>（类似单CPU多进程过程）</li></ul><p><img src="https://s2.loli.net/2022/01/05/HUVGQvkiaR42LPO.png" alt="" /></p><ul><li>基于 PCM 的 TDM 可在中继线上运送多路电话语音，<code>每 125 微秒</code>为每路电话发送一个语音样值。</li><li>北美和日本地区使用的是 Tl 载波 <code>Tl carrier</code> ，Tl 载波包含 <code>24 条被复用在一起的语音信道</code>，每个信道依次将8比特的样值插入到输出流中。</li></ul><p><img src="https://s2.loli.net/2022/01/05/AKpiMg8SoZdaEJW.png" alt="" /></p><ul><li>每帧包含<code>24 * 8=192</code>个比特，再加上<code>额外一个比特用于控制</code>，因而<code>每 125 微秒产生 193个比特。</code></li><li>这样得到的数据传输率为 1.544 Mbps ，其中8 kbps 用于信令控制。第 193 个比特用于帧同步和信令。</li><li>时分多路复用允许将多个 Tl 载波复用到一个更高阶的载波中。</li></ul><p><img src="https://s2.loli.net/2022/01/05/7fOCkTt6IpyJiYV.png" alt="" /></p><ul><li>在北美及日本以外地区，使用<code>2.048 Mbps</code>的<code>El 载波</code>代替 Tl 载波。 El 载波有 <code>32个8比特</code>数据样值被封装在<code>125 微秒</code>的帧中。</li><li>32 个信道中的 <code>30 个用于传输</code>信息，其余<code>2个信道用作信令</code>。每四个帧为一组，提供了 64 个信令比特，其中一半用于信令（是否信道相关或共同信道），另一半用于帧同步或各个国家保留使用。</li></ul></li></ul><hr /><ul><li><p>码分多路复用(CDM，Code Division Multiplexing )</p><ul><li>扩展频谱(spread spectrum)通信的一种形式，它<code>把一个窄带信号扩展到一个很宽的频带上</code>。这种方法更能容忍干扰。</li><li><code>码分多址(CDMA, Code Division Multiple Access)</code>：允许来自不同用户的多个信号共享相同的频带</li></ul><p><img src="https://s2.loli.net/2022/01/05/LglbW7vdqjtnQxz.png" alt="" /></p><ul><li><p>在CDMA中，每个比特时间再划分为m个短的间隔，成为码片，通常m值为64或128，一般m=8，规则如下：</p><ol><li>使用CDMA的每一个站被指派一个唯一的m bit码片序列，一个站<code>如果要发送比特1，则发送它自己的m bit码片序列</code>，<code>如果要发送0，则发送该码片序列的二进制反码</code>，按照惯例将码片中的0写成-1，将1写成+1</li><li><code>CDMA给每一个站分配的码片序列不仅必须各不相同，并且还必须互相正交</code></li></ol><p><img src="https://s2.loli.net/2022/01/05/n8ak6EIMiGYFRhe.png" alt="" /></p><ol start="3"><li>任何一个码片向量和该码片向量自己的规格化内积都是1，任何一个码片向量和该码片的反码的向量的规格化内积都是-1</li></ol></li></ul></li></ul><hr /><h2 id="数据交换技术"><a class="markdownIt-Anchor" href="#数据交换技术"></a> 数据交换技术</h2><h3 id="电路交换"><a class="markdownIt-Anchor" href="#电路交换"></a> 电路交换</h3><ul><li>在进行数据交换前，两个结点之间必须<code>建立一条专用（双方独占）的物理通信路径</code>。这一路径在整个数据传输期间一直被独占，直到通信结束之后才释放。</li><li>电路交换技术分为三个阶段：连接建立、数据传输和连接释放。</li><li>电路交换技术的优点：<ol><li>通信时延小</li><li>有序传输</li><li>没有冲突</li><li>适用范围广</li><li>实时性强</li><li>控制简单</li></ol></li><li>电路交换的缺点：<ol><li>建立连接时间长</li><li>线路独占，效率低下</li><li>灵活性差</li><li>难以规格化</li></ol></li><li>电路建立后，除源节点和目的节点外，电路上的任何节点都采取“直通方式”接收数据和发送数据，<code>不存在存储转发消耗的时间</code></li></ul><p><img src="https://s2.loli.net/2022/01/05/FdTDwBVKNojc5Gi.png" alt="" /></p><hr /><h3 id="报文交换"><a class="markdownIt-Anchor" href="#报文交换"></a> 报文交换</h3><ul><li>数据交换的单位是<code>报文</code>，报文携带有目标地址、源地址等消息。报文交换在交换结点采用的是<code>存储转发</code>的传输方式</li><li>报文交换技术的优点：<ol><li>无需建立连接</li><li>动态分配线路</li><li>提高线路可靠性</li><li>提高线路利用率</li><li>提供多目标服务</li></ol></li><li>报文交换技术的缺点：<ol><li>存在转发时延</li><li>网络节点需要较大的缓存</li><li>报文交换主要是用在早期的电报通信网中，现在较少使用。</li></ol></li></ul><hr /><h3 id="分组交换"><a class="markdownIt-Anchor" href="#分组交换"></a> 分组交换</h3><ul><li>分组交换也采用存储转发的方式，但解决了报文交换中大报文传输的问题：<ul><li>分组交换<code>限制了每次传送的数据块的上限</code>，把大的数据块划分为合理的小数据块，再加上一些控制信息，构成分组(Packet)</li></ul></li><li>网络结点根据控制信息把分组送到下一结点，下一结点接收到分组后，<code>暂时保存并排队等待传输</code>，然后根据控制信息选择下一结点，直到目的结点。</li><li>分组交换的优点：<ol><li>无建立时延</li><li>线路利用率高</li><li>简化存储管理（因为分组长度固定，缓冲区的大小也固定）</li><li>加速传输（后一个分组的存储操作和前一个分组的转发操作可以并行）</li><li>减少了出错概率和重发数据量</li></ol></li><li>分组交换的缺点：<ol><li>存在传输时延，结点交换机需要更强处理能力</li><li>需要传输额外的信息量</li><li>可能会出现失序、丢失或者重复分组</li></ol></li></ul><p><img src="https://s2.loli.net/2022/01/05/3SY1lpPFuWbE2vd.png" alt="" /></p><p><img src="https://s2.loli.net/2022/01/06/s2HIT7k3gnUJwQ5.png" alt="" /></p><hr /><h2 id="传输介质"><a class="markdownIt-Anchor" href="#传输介质"></a> 传输介质</h2><h3 id="导向性传输介质"><a class="markdownIt-Anchor" href="#导向性传输介质"></a> 导向性传输介质</h3><ul><li>电磁波被导向沿着固体媒介传播</li></ul><hr /><ol><li>双绞线</li></ol><p><img src="https://s2.loli.net/2022/01/09/rQJf5H4noDeCWGy.png" alt="" /></p><ul><li>是古老、又最常用的传输介质，由<code>两根</code>采用一定规则并排<code>绞合</code>的、相互绝缘的铜导线组成<ul><li>绞合可以减少对相邻导线的电磁干扰</li></ul></li><li>模拟传输和数字传输都可以使用双绞线，通信距离一般为几公里到数十公里<ul><li>距离太远时，对于模拟传输，需要<code>放大器</code>放大衰减的信号；对于数字传输，要用<code>中继器</code>将失真的信号整形</li></ul></li></ul><hr /><ol start="2"><li>同轴电缆</li></ol><p><img src="https://s2.loli.net/2022/01/09/btiY1HkvrsxZCXp.png" alt="" /></p><ul><li>根据传输信号不同可以分为<code>基带同轴电缆</code>，主要传输基带数字信号；和宽带同轴电缆，主要用于传送宽带信号。</li><li>同轴电缆抗干扰特性比双绞线好，传输距离更远，但是更贵</li></ul><hr /><ol start="3"><li>光纤</li></ol><ul><li>利用光导纤维传递光脉冲来通信，有光脉冲表示1，反之为0</li><li>可见光频率高，因此光纤通信系统的带宽远远大于其他媒介。</li></ul><p><img src="https://s2.loli.net/2022/01/05/cRyJVPL6mbFHGAq.png" alt="" /></p><p><img src="https://s2.loli.net/2022/01/05/FZsaPzr3NeKWIRH.png" alt="" /></p><ul><li>特点：<ol><li>传输损耗小，中继距离长，远距离传输经济</li><li>抗雷电和电磁干扰性能好</li><li>无串音干扰，保密性好</li><li>体积小，重量轻</li></ol></li></ul><hr /><h3 id="非导向性传输介质"><a class="markdownIt-Anchor" href="#非导向性传输介质"></a> 非导向性传输介质</h3><ul><li>自由空间，介质可以是空气、真空、海水等</li></ul><p><img src="https://s2.loli.net/2022/01/05/s7Htdki3TZEgXox.png" alt="" /></p><hr /><h2 id="物理层设备"><a class="markdownIt-Anchor" href="#物理层设备"></a> 物理层设备</h2><ul><li>中继器</li></ul><p><img src="https://s2.loli.net/2022/01/09/gulYI2oa4bwtnKV.png" alt="" /></p><ul><li>集线器</li></ul><p><img src="https://s2.loli.net/2022/01/05/fzgbxS2KdN4D7k6.png" alt="" /></p><hr /><h1 id="数据链路层"><a class="markdownIt-Anchor" href="#数据链路层"></a> 数据链路层</h1><h2 id="数据链路层的设计问题"><a class="markdownIt-Anchor" href="#数据链路层的设计问题"></a> 数据链路层的设计问题</h2><h3 id="数据链路层的功能"><a class="markdownIt-Anchor" href="#数据链路层的功能"></a> 数据链路层的功能</h3><ul><li>向网络层提供一个定义良好的服务接口</li><li>处理传输错误</li><li>调节数据流，确保慢速的接收方方不会被快速的发送方淹没。</li></ul><h2 id=""><a class="markdownIt-Anchor" href="#"></a> <img src="https://s2.loli.net/2022/01/05/87oLN2Pt9sk5wGZ.png" alt="" title="数据包和帧的关系" /></h2><h3 id="提供给网络层的服务"><a class="markdownIt-Anchor" href="#提供给网络层的服务"></a> 提供给网络层的服务</h3><p>一般情况下，数据链路层通常会提供以下三种可能的服务：</p><ol><li>无确认的无连接服务</li></ol><ul><li>无确认的无连接服务是指源机器向目标机器发送独立的帧，<code>目标机器并不对这些帧进行确认。</code></li><li>采用这种服务，事先不需要建立逻辑连接，事后也不用释放逻辑连接。</li><li>若由于线路的噪声而造成了某一帧的丢失，<code>数据链路层并不试图去检测这样的丢帧情况，更不会去试图恢复丢失的帧。</code></li><li>这类服务适合两种场合：<ul><li><code>第一种是错误率很低的场合</code>，此时差错恢复过程可以留给上层来完成</li><li><code>第二种是实时通信</code>，比如语音传输，因为在实时通信中数据迟到比数据受损更糟糕。</li></ul></li></ul><hr /><ol start="2"><li>有确认的无连接服务</li></ol><ul><li>当向网络层提供这种服务时，数据链路层仍然没有使用逻辑连接，但<code>其发送的每一帧都需要单独确认。</code></li><li>如果一个帧在指定的时间间隔内还没有到达，则发送方将再次发送该帧。</li><li>这类服务尤其适用于不可靠的信道，比如无线系统。</li></ul><blockquote><p>有一点值得强调，那就是在数据链路层提供确认只是一种优化手段，永远不应该成为一种需求。</p><ul><li>这一策略的麻烦在于它可能导致传输的低效率。</li><li>链路层对帧通常有严格的长度限制，这是由硬件所决定的，除此之外，还有传播延迟。</li><li>在可靠信道上，比如光纤，重量级数据链路协议的开销可能是不必要的：但在无线信道上，由于信道内在的不可靠性，这种开销还是非常值得的。</li></ul></blockquote><hr /><ol start="3"><li>面向连接的服务：数据链路层向网络层提供的最复杂服务</li></ol><ul><li>采用这种服务，<code>源机器和目标机器在传输任何数据之前要建立一个连接。</code></li><li><code>连接上发送的每一帧都被编号</code>，数据链路层确保发出的每个帧都会真正被接收方收到。它还<code>保证每个帧只被接收一次</code>，并且<code>所有的帧都将按正确的顺序被接收</code>。</li><li>它适用于长距离且不可靠的链路</li><li>如果采用有确认的无连接服务，丢失了确认可能导致一个帧被收发多次，<code>因而将浪费带宽。</code></li><li>当使用面向连接的服务时，数据传输必须经过三个不同的阶段：<ol><li>建立连接，双方初始化各种变量和计数器</li><li>真正传输一个或者多个数据帧</li><li>连接被释放，所有的变量、缓冲区以及其他用于维护该连接的资源也随之被释放。</li></ol></li></ul><p><img src="https://s2.loli.net/2022/01/05/aFKsdtiJBup7h9w.jpg" alt="" title="数据链路层协议的位置" /></p><hr /><h3 id="成帧framing"><a class="markdownIt-Anchor" href="#成帧framing"></a> 成帧（Framing）</h3><ol><li>字符计数法(Character count)</li></ol><p><img src="https://s2.loli.net/2022/01/05/vFda6fDnr7ib3OU.png" alt="" title="字符计数法" /></p><ul><li><code>利用头部中的一个字段来标识该帧中的字符数。</code>当接收方的数据链路层看到字符计数值时，它就知道后面跟着多少个字节 因此也就知道了该帧在哪里结束。</li><li>这个算法的问题在于计数值有可能<code>因为一个传输错误而被弄混</code>。</li></ul><hr /><ol start="2"><li>字符填充法(Flag bytes with byte stuffing)</li></ol><p><img src="https://s2.loli.net/2022/01/05/TSKkZ6GoHvLMNmp.png" alt="" title="字符填充法" /></p><ul><li>成帧方法考虑到了出错之后的重新同步问题，它让每个帧<code>用些特殊的字节作为开始和结束。</code></li><li><code>标志字节(flag byte )</code>，作为帧的起始和结束分界符，两个连续的标志字节代表了 帧的结束和下一帧的开始。</li><li><code>转义字节(ESC)</code>，作为数据内标志字节和转移字节的填充。</li></ul><hr /><ol start="3"><li>位填充法</li></ol><p><img src="https://s2.loli.net/2022/01/05/bGQBAJ9uxzMXeC6.png" alt="" title="位填充法" /></p><ul><li><code>帧的划分可以在比特级完成</code>，因而帧可以包含由任意大小单元（而不是只能以比特为单元）组成的二进制比特数。</li><li>每个帧的开始和结束由一个特殊的比特模式， 01111110 或十六进制 Ox7E标记。这种模式是一个标志字节。<code>每当发送方的数据链路层在数据中遇到连续五个1 ，它便自动在输出的比特流中填入一个比特。</code></li><li>当接收方看到5个连续入境比特1，并且后面紧跟一个比特0，它就自动剔除（即删除）比特0。</li><li>比特填充和字节填充一样，对两台计算机上的网络层是完全透明的。</li><li>如果接收方失去了它的接收轨迹，它所要做的只是扫描输入比特流，找出其中的标志序列：<code>因为这些标志只可能出现在帧的边界，而决不会出现在帧内的数据中。</code></li></ul><blockquote><p><code>采用比特填充和字节填充的一个副作用是一帧的长度现在要取决于它所携带的数据内容。</code></p></blockquote><hr /><ol start="4"><li>物理层违例编码法(Physical layer coding violations)</li></ol><ul><li>使用“编码违法”来区分帧的边界。</li><li>这种方案的优点在于，因为这些用作分界符的信号是保留不用的，所以很容易通过它们找到帧的开始和结束，而且不再需要填充数据。</li></ul><p><img src="https://s2.loli.net/2022/01/05/l7mBVF6cbsIfyXD.png" alt="" title="物理层违例编码法" /></p><hr /><h3 id="差错控制"><a class="markdownIt-Anchor" href="#差错控制"></a> 差错控制</h3><ul><li>确保可靠传递的常用方法是向发送方提供一些有关线路另一端状况的<code>反馈信息。</code></li></ul><blockquote><p>如果在一个协议中，发送方发出了一帧之后就等待肯定的或者否定的确认，那么，若由于硬件故障或通信信道出错等原因而丢失了某一帧，则发送方将永远等待下去。</p></blockquote><ul><li><p>这种可能性可以通过在数据链路层中引入<code>计时器</code>来解决。当发送方发出一帧时，通常还要启动一个计时器。该计时器的超时值应该设置得足够长，以便保证在正常情况下该帧能够到达接收方，并且在接收方进行处理后再将确认返回到发送方。</p></li><li><p>如果帧或者确认被丢失，则计时器将被触发，从而警告发送方存在一个潜在的问题。一种显然的解决方案是重新发送该帧。</p></li><li><p>为了避免接收方将两次或者多次接收到同一帧，并且多次将它传递给网络层，一般有必要给发送出去的帧<code>分配序号</code>，这样接收方可以根据帧的序号来有效区分原始帧和重传帧。</p></li></ul><hr /><h3 id="流量控制"><a class="markdownIt-Anchor" href="#流量控制"></a> 流量控制</h3><ul><li>为了阻止<code>发送方发送帧的速度超过了接收方能够接受这些帧的速度</code>情况发生。常用的办法有两种。<ul><li>第一种方法是<code>基于反馈的流量控制</code>(feedback-based flow control)，接收方给发送方返回信息，允许它发送更多的数据，或者至少告诉发送方自己的情况怎么样。</li><li>第二种方法是<code>基于速率的流量控制</code>(rate-based flow control)，使用这种方法的协议有一种内置的机制，它能限制发送方传输数据的速率，而无须利用接收方的反馈信息。</li></ul></li></ul><hr /><h2 id="差错检测和纠正"><a class="markdownIt-Anchor" href="#差错检测和纠正"></a> 差错检测和纠正</h2><ul><li>一个包含了数据位和校验位的n位单元称为<code>n位码字(codeword)</code></li><li><code>码率(code rate)</code>或者简单地说速率，则定义为码字中不包含元余部分所占的比例，或者用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi mathvariant="normal">/</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">m/n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord">/</span><span class="mord mathdefault">n</span></span></span></span> 表示。</li></ul><hr /><h3 id="纠错码"><a class="markdownIt-Anchor" href="#纠错码"></a> 纠错码</h3><h4 id="海明码"><a class="markdownIt-Anchor" href="#海明码"></a> 海明码</h4><ul><li>两个码字中不相同的位的个数称为<code>海明距离(Hamming distance)</code></li><li>如果两个码字的海明距离为d，则需要d个1位错误才能将一个码字转成另一个码字。</li><li>为了可靠地<code>检测d个错误</code>，需要一个距离为d+1的编码方案。</li><li>为了<code>纠正d个错误</code>，需要一个距离为2d+1的编码方案。</li></ul><hr /><ul><li>以1010110这个二进制数为例解释海明码的编码和校验方法。</li></ul><ol><li>确定校验码的位数</li></ol><ul><li>设n为有效信息的位数，k为校验位的位数，则信息位n和校验位k应满足：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>+</mo><mi>k</mi><mo>≤</mo><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+k \le 2^k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li><li>使不等式成立的k的最小值就是校验码的位数。在本例中，n=7，解得k=4。</li></ul><ol start="2"><li>确定校验码的位置</li></ol><ul><li>校验码在二进制串中的<code>位置为2的整数幂</code>。剩下的位置为数据。</li></ul><table><thead><tr><th style="text-align:center">位置</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th></tr></thead><tbody><tr><td style="text-align:center">内容</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center">1</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">P_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr></tbody></table><ol start="3"><li>求出校验位的值</li></ol><ul><li>以求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的值为例。为了直观，将表格中的位置用二进制表示。</li></ul><table><thead><tr><th style="text-align:center">位置</th><th style="text-align:center">0001</th><th style="text-align:center">00<code>1</code>0</th><th style="text-align:center">00<code>1</code>1</th><th style="text-align:center">0100</th><th style="text-align:center">0101</th><th style="text-align:center">01<code>1</code>0</th><th style="text-align:center">01<code>1</code>1</th><th style="text-align:center">1000</th><th style="text-align:center">1001</th><th style="text-align:center">10<code>1</code>0</th><th style="text-align:center">10<code>1</code>1</th></tr></thead><tbody><tr><td style="text-align:center">内容</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center"><code>1</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center">0</td><td style="text-align:center"><code>1</code></td><td style="text-align:center"><code>0</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">P_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center">1</td><td style="text-align:center"><code>1</code></td><td style="text-align:center"><code>0</code></td></tr></tbody></table><ul><li>为了求出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,要使所有位置的第二位是1的数据（即形如<code>**1*</code>的位置的数据）的<code>异或值为0</code>。即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⨁</mo></mrow><annotation encoding="application/x-tex">\bigoplus</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span></span></span></span> 1 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⨁</mo></mrow><annotation encoding="application/x-tex">\bigoplus</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span></span></span></span> 1 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⨁</mo></mrow><annotation encoding="application/x-tex">\bigoplus</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span></span></span></span> 0 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⨁</mo></mrow><annotation encoding="application/x-tex">\bigoplus</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span></span></span></span> 1 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⨁</mo></mrow><annotation encoding="application/x-tex">\bigoplus</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span></span></span></span> 0 = 0。因此<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = 1。</li><li>同理可得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = 0, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = 1, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">P_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = 0。</li><li>因此1010110的海明码为01110100110。</li></ul><ol start="4"><li>校验</li></ol><ul><li>每个校验组分别利用校验位和参与形成该校验位的信息位进行奇偶校验检查，构成k个校验方程。假设位置为1011的数据由0变成了1：</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.15999999999999992em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>S</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mo>∗</mo><mo>∗</mo><mo>∗</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><msub><mi>P</mi><mn>1</mn></msub><mo>⨁</mo><mn>1</mn><mo>⨁</mo><mn>0</mn><mo>⨁</mo><mn>0</mn><mo>⨁</mo><mn>1</mn><mo>⨁</mo><mn>1</mn><mo>=</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>S</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mo>∗</mo><mo>∗</mo><mn>1</mn><mo>∗</mo><mo stretchy="false">)</mo><mo>=</mo><msub><mi>P</mi><mn>2</mn></msub><mo>⨁</mo><mn>1</mn><mo>⨁</mo><mn>1</mn><mo>⨁</mo><mn>0</mn><mo>⨁</mo><mn>1</mn><mo>⨁</mo><mn>1</mn><mo>=</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>S</mi><mn>3</mn></msub><mo stretchy="false">(</mo><mo>∗</mo><mn>1</mn><mo>∗</mo><mo>∗</mo><mo stretchy="false">)</mo><mo>=</mo><msub><mi>P</mi><mn>3</mn></msub><mo>⨁</mo><mn>0</mn><mo>⨁</mo><mn>1</mn><mo>⨁</mo><mn>0</mn><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>S</mi><mn>4</mn></msub><mo stretchy="false">(</mo><mn>1</mn><mo>∗</mo><mo>∗</mo><mo>∗</mo><mo stretchy="false">)</mo><mo>=</mo><msub><mi>P</mi><mn>4</mn></msub><mo>⨁</mo><mn>1</mn><mo>⨁</mo><mn>1</mn><mo>⨁</mo><mn>1</mn><mo>=</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\left \{ \begin{array}{c}S_1(***1)=P_1\bigoplus 1  \bigoplus 0 \bigoplus 0 \bigoplus 1 \bigoplus 1=1\\ S_2(**1*)=P_2\bigoplus 1  \bigoplus 1 \bigoplus 0 \bigoplus 1 \bigoplus 1=1 \\ S_3(*1**)=P_3\bigoplus 0  \bigoplus 1 \bigoplus 0 = 0 \\ S_4(1***)=P_4\bigoplus 1  \bigoplus 1 \bigoplus 1 = 1\end{array}\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.80004em;vertical-align:-2.15002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65002em;"><span style="top:-1.8999899999999998em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-1.8999899999999998em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.1999899999999997em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.15001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.30001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.60001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.90002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">∗</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mord">∗</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">∗</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">∗</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">∗</span><span class="mord">∗</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><ul><li>以上四组中，若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub><msub><mi>S</mi><mn>2</mn></msub><msub><mi>S</mi><mn>3</mn></msub><msub><mi>S</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">S_1S_2S_3S_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的值为&quot;0000&quot;，则说明无错；如果一组异或值为1，说明该组中有数据出错了。</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub><msub><mi>S</mi><mn>2</mn></msub><msub><mi>S</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">S_1S_2S_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的异或都为1，说明出错数据的位置为1011，直接将该位取反即可</li></ul><hr /><h3 id="检错码"><a class="markdownIt-Anchor" href="#检错码"></a> 检错码</h3><blockquote><p>光纤或高品质铜线的错误率要低得多，因此对于偶尔出现的错误采用差错检测和重传的处理方式通常更加有效。</p></blockquote><hr /><h4 id="奇偶校验码parity"><a class="markdownIt-Anchor" href="#奇偶校验码parity"></a> 奇偶校验码(Parity)</h4><ul><li>奇偶校验码是奇校验码和偶校验码的统称，它又n-1位信息元和1位校验元组成</li><li>奇偶位的选择原则是使得<code>码字中比特1的数目是偶数（或奇数）</code>。这样处理等同于对数据位进行模2加或异或操作来获得奇偶位。</li><li>探测奇数位的错误很容易<ul><li>1个错误：11100<u>1</u>0<code>1</code>；可以检出错误</li><li>3个错误：11<u>011</u>00<code>1</code>；可以检出错误</li><li>2个错误：1110<u>11</u>0<code>1</code>；不可以检出错误</li><li>校验位也可能出错</li><li>随即错误被检测到的概率是50%</li></ul></li></ul><hr /><h4 id="交错校验interleaving"><a class="markdownIt-Anchor" href="#交错校验interleaving"></a> 交错校验(interleaving)</h4><ul><li>我们将为n列中的<code>每列</code>计算校验位，按k行发送全部的数据位。</li><li>发送次序是从上到下发送每一行，行内数据位通常按从左到右的次序发送。在最后一行，发送n个校验位。</li></ul><p><img src="https://s2.loli.net/2022/01/05/AKkNisEbFdD9SgP.png" alt="" title="交错校验" /></p><ul><li>这种方法对于 nk 长度的数据块使用了 n 个校验位就能检测出一个长度小于等于 n 的突发错误。</li></ul><hr /><h4 id="校验和checksums"><a class="markdownIt-Anchor" href="#校验和checksums"></a> 校验和(Checksums)</h4><ul><li>所谓校验和，就是将被校验数据进行累加，并舍弃累加溢出的位，最终得到的1个或多个字节的结果。</li></ul><p><img src="https://s2.loli.net/2022/01/05/ogzfnarvY1eWiBS.png" alt="" title="校验和" /></p><ul><li><p>在发送数据时，为了计算数据包的检验和。应该按如下步骤：</p><ol><li>把校验和字段设置为0；</li><li>把需要校验的数据看成以16位为单位的数字组成，依次进行<code>二进制反码求和</code>；</li><li>运算结果<code>取反</code>，得到校验和</li></ol></li><li><p>在接收数据时，计算数据包的检验和相对简单，按如下步骤：</p><ol><li>把首部看成以16位为单位的数字组成，依次进行<code>二进制反码求和</code>，包括校验和字段；</li><li>检查计算出的校验和的结果是否为0；</li><li>如果等于0，说明被整除，校验和正确。否则，校验和就是错误的，协议栈要抛弃这个数据包。</li></ol></li></ul><p><img src="https://s2.loli.net/2022/01/05/KlPQg6fnStCO4Za.png" alt="" title="校验和" /></p><hr /><h4 id="循环冗余校验码ccrc-cyclic-redundancy-check"><a class="markdownIt-Anchor" href="#循环冗余校验码ccrc-cyclic-redundancy-check"></a> 循环冗余校验码(CCRC, Cyclic Redundancy Check )</h4><ul><li>CRC是一种数据传输检错功能，对数据进行多项式计算，并将得到的结果附在帧的后面，接收设备也执行类似的算法，以保证数据传输的正确性和完整性。</li><li>x的最高幂次为R，转换成对应的二进制数有<code>R+1位。</code><ul><li>如生成多项式为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>x</mi><mn>4</mn></msup><mo>+</mo><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">G(x)=x^4+x^3+x+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">G</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>， 可转换为二进制数码11011。</li></ul></li><li>计算冗余码<ol><li>加0：在要发送的数据后加r个0，其中<code>r为生成多项式G（x）的阶</code>（一般来说，多项式为N位，则阶为N-1）；</li><li>模2除法：加0后的数据除以生成多项式G（x），则余数就是所求的冗余码/FCS/CRC检验码的比特序列（模2除法的本质就是<code>异或运算</code>）。</li><li>最终要发送的数据就是：（0扩展）原数据（左移r位）+FCS。</li></ol></li></ul><p><img src="https://s2.loli.net/2022/01/05/W1EOP5g9Ryljvft.png" alt="" title="计算冗余码" /></p><ul><li>验证冗余码<ul><li>在接收端将收到的每一个帧都除以在发送时使用的生成多项式，然后检查得到的余数R，若：<ol><li>R=0，发送数据没有出错；</li><li>R≠0，判定接收到的数据是错误的（只是有检错功能，却没有纠错功能，无法确定到出错的位数），直接丢弃。</li></ol></li></ul></li></ul><p><img src="https://s2.loli.net/2022/01/09/d28mePGhb9L3ryB.png" alt="" title="验证冗余码" /></p><blockquote><p>在数据链路层使用CRC循环冗余码的差错检验技术，只能做到对发送帧的无比特差错接收，还不能做到可靠传输（数据链路层发送端发送什么，接收端就收到什么）。</p></blockquote><hr /><h2 id="基本数据链路层协议"><a class="markdownIt-Anchor" href="#基本数据链路层协议"></a> 基本数据链路层协议</h2><p><img src="https://s2.loli.net/2022/01/05/IJYHOlfq8QZB51y.png" alt="" title="实现" /></p><ul><li>发送方的数据链路层每当发出一帧，就要启动一个内部计时器或者时钟。如果在预设的时间间隔内没有收到应答，则时钟超时，数据链路层会收到一个中断信号。</li></ul><hr /><h3 id="理想化单工协议"><a class="markdownIt-Anchor" href="#理想化单工协议"></a> 理想化单工协议</h3><ul><li>假设：<ul><li>不需要考虑出错的情况（流量控制、差错检测）</li><li>数据只能单向传输</li><li>可用的缓存空间无限大</li><li>物理层服务可靠，信道不会损坏帧或丢失帧</li></ul></li></ul><p><img src="https://s2.loli.net/2022/01/05/26M7SWcVUmz5tQb.png" alt="" title="理想化单工协议" /></p><ul><li>协议由两个单独的过程组成 一个发送过程和一个接收过程。发送过程运行在源机器的数据链路层上；接收过程运行在目标机器的数据链路层上。</li><li>理想化单工协议是不现实的，因为它不处理任何流量控制或纠错工作。其处理过程接近于无确认的无连接服务。</li></ul><hr /><h3 id="无噪声信道上的停-等协议"><a class="markdownIt-Anchor" href="#无噪声信道上的停-等协议"></a> 无噪声信道上的停-等协议</h3><ul><li><p>仍假设通信信道不会出错，并且数据流量是单工的。</p></li><li><p>接收方将数据包传递给网络层之后给发送方返回一个小的确认帧，允许它发送下一帧。</p></li><li><p>发送方在发出一帧之后，根据协议要求，它必须等待一段时间直到确认帧到达。这种延缓就是流量控制协议的一个简单例子。</p></li><li><p>对于发送方来说，确认帧的到来比帧内包含什么内容更重要，因此接收方根本不需要往确认帧中填充任何特别的信息。发送方的数据链路层甚至根本不检查接收到的帧，因为对它而言只有一种可能性，即入境帧总是来自接收方的确认。</p></li></ul><p><img src="https://s2.loli.net/2022/01/05/s5bf9wXHIBFuTZN.png" alt="" title="理想停等协议" /></p><hr /><h3 id="有错信道上的停-等协议"><a class="markdownIt-Anchor" href="#有错信道上的停-等协议"></a> 有错信道上的停-等协议</h3><ul><li><p>信道可能会出错，帧可能会被损坏，也可能完全被丢失。</p></li><li><p>自动重复请求(<code>ARQ</code> , Automatic Repeat Request)或带有重传的肯定确认(PAR, Positive Acknowledgement with Retransmission)</p><ul><li>发送方发送包含CRC的数据帧，并启动计时器</li><li>接收方接受数据帧并验证CRC和<code>序号</code>，然后发送<code>ACK</code>(ACKnowledge Character，表示确认发来的数据已经接受无误)，或者<code>NAK</code>(Negative Acknowledgment，确认数据有错误的信号)</li><li>发送方若接收到ACK，就发送新的一帧</li><li>发送方若收到NAK，或者发生超时，则重发原数据帧。</li><li>若ACK确认帧丢失<ul><li>构造一个重复的帧</li><li>并附上<code>一位序号</code>以区分新旧帧</li></ul></li></ul></li></ul><p><img src="https://s2.loli.net/2022/01/05/VRZ1ewdFfD3EvXH.png" alt="" title="sender3" /></p><p><img src="https://s2.loli.net/2022/01/09/UkWLTmvH6oR75zS.png" alt="" title="recever3" /></p><p><img src="https://s2.loli.net/2022/01/05/mye2WGR4bN9A7Pa.png" alt="" title="流程图" /></p><hr /><ul><li>停-等协议的信道利用率<ul><li>B 为信道速率(bits/sec)</li><li>L 为帧大小(bits)</li><li>R 为往返传播时间(sec)</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi><mo>=</mo><mfrac><mrow><mi>L</mi><mi mathvariant="normal">/</mi><mi>B</mi></mrow><mrow><mi>L</mi><mi mathvariant="normal">/</mi><mi>B</mi><mo>+</mo><mi>R</mi></mrow></mfrac><mo>=</mo><mfrac><mi>L</mi><mrow><mi>L</mi><mo>+</mo><mi>R</mi><mi>B</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">U = \frac {L/B}{L/B+R} = \frac {L}{L+RB}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mord mtight">/</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mord mtight">/</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.275662em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li></ul></li></ul><p><img src="https://s2.loli.net/2022/01/05/gjpzFvB4L2If1wD.png" alt="" title="效率" /></p><hr /><h2 id="滑动窗口协议"><a class="markdownIt-Anchor" href="#滑动窗口协议"></a> 滑动窗口协议</h2><h3 id="一些概念"><a class="markdownIt-Anchor" href="#一些概念"></a> 一些概念</h3><ul><li>捎带确认(piggybacking)<ul><li>当一个数据帧到达的时候，接收方并不是立即发送一个单独的控制帧，而是抑制一下自己并且开始等待，直到网络层传递给它下一个分组。</li><li>然后，确认信息被附在往外发送的数据帧上（使用帧头中的<code>ack域</code>）。实际上，确认报文搭了下一个外发数据帧的便车。</li><li>使用捎带确认的最主要好处是<code>更好地利用了信道的可用带宽</code>。帧头的 ack 字段只占用很少几位，而一个单独的帧则需要一个帧头、确认信息和校验和。</li></ul></li><li>滑动窗口<ul><li>任何一个出境帧都包含一个序号，范围从0到某个最大值。序号的最大值通常是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，这样序号正好可以填入到一个n位的字段中。</li><li><code>发送窗口</code>(sending window)：<ul><li>所有滑动窗口协议的本质是在任何时刻发送方总是维持着一组序号，分别对应于允许它发送的帧。</li><li>发送方窗口内的序号代表了那些可以被发送的帧，或者那些已经被发送但还没有被确认的帧。</li><li>任何时候当有新的数据包从网络层到来时，它被赋予窗口中的下一个最高序号，<code>并且窗口的上边界前移一格。</code></li><li>当收到一个确认时，窗口的<code>下边界也前移一格。</code></li></ul></li><li>类似地，接收方也维持着一个<code>接收窗口</code>(receiving window)<ul><li>接收方数据链路层的窗口对应于它可以接受的帧。任何落在窗口内的帧被放入接收方的缓冲区。</li><li>收到一个帧，而且<code>其序号等于窗口下边界</code>时，接收方将它传递给网络层，并将<code>整个窗口</code>向前移动1个位置。</li></ul></li></ul></li></ul><p><img src="https://s2.loli.net/2022/01/05/gZqiOwlLU2eAVFG.png" alt="" title="滑动窗口" /></p><ul><li><p>发送方必须在内存中保存所有这些帧，以便满足可能的重传需要。因此，如果最大的窗口尺寸为n，则发送方需要n个缓冲区来存放未被确认的帧。</p></li><li><p>与发送方窗口不同 接收方窗口始终保持着它的初始大小，<code>窗口的旋转意味着下一帧被接受并被传递到网络层。</code></p></li></ul><p><img src="https://s2.loli.net/2022/01/05/fjk7VUSdtMFp24a.png" alt="" title="流程图" /></p><hr /><h3 id="1位滑动窗口协议"><a class="markdownIt-Anchor" href="#1位滑动窗口协议"></a> 1位滑动窗口协议</h3><ul><li>由于发送方在发出一帧以后，必须等待前一帧的确认到来才能发送下一帧，所以<code>这样的协议使用了停-等式办法</code></li></ul><p><img src="https://s2.loli.net/2022/01/05/D4ZFNEQjioTHuJd.png" alt="" title="协议发" /></p><ol><li>初始启动的机器从它的网络层获取第一个数据包，然后根据该数据包创建一帧，并将它发送出去。</li><li>该帧（或者任何其他帧）到达目的地，接收方的数据链路层检查该帧，看它是否为重复帧，如果这帧正是接收方所期望的，则将它传递给网络层，井且接收方的窗口向前滑动。</li></ol><p><img src="https://s2.loli.net/2022/01/05/nYTLdkBc61DybUq.png" alt="" title="协议收" /></p><ul><li>确认字段包含了最后接收到的正确帧的序号。</li><li>如果该序号与发送方之前试图发送的帧的序号一致，则发送方知道，存储在 buffer 中的帧己经处理完毕，于是，它就可以从网络层获取下一个数据包。</li><li>如果序号不一致，则它必须继续发送同一帧。无论什么时候只要接收到一帧，就要返回一帧。</li></ul><p><img src="https://s2.loli.net/2022/01/05/b8vHqCjVaOBgdAm.png" alt="" title="AB同时发送第一帧" /></p><ul><li>对于不正常的情况，如AB同时发起通信或发生多个过早超时，则每一帧都有可能被发送三次或者更多次，严重浪费了宝贵带宽。</li></ul><hr /><h3 id="回退n帧协议go-back-n"><a class="markdownIt-Anchor" href="#回退n帧协议go-back-n"></a> 回退N帧协议(Go-Back-N)</h3><ul><li>1位滑动窗口协议效率低，发送方等待时间长，由此产生了回退N帧协议</li><li><code>接收窗口大小为1</code> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 只能按序接收</li><li>即使存在 MAX_SEQ+1个不同的序号(分别为 0、1、 2 、···、MAX_SEQ)，<code>发送窗口大小最大为MAX_SEQ</code><ul><li>否则无法区分新旧帧</li></ul></li><li>采用<code>累积确认</code>：对第n帧的ack意味着第n帧以及之前的帧全部正确到达</li></ul><p><img src="https://s2.loli.net/2022/01/05/54s6L3mpJBdakcn.png" alt="" title="GBN" /></p><ul><li>接收方只接受/确认按<code>顺序到达</code>的帧(内部会维护变量指示下一个应该到达的帧的序号)<ul><li>丢失的或出错的帧后接收到的帧全部丢弃</li><li>发送方发生超时时，<code>重新发送所有已发送但没有被确认的帧</code></li></ul></li></ul><p><img src="https://s2.loli.net/2022/01/05/RE3v8p4elDcwTOJ.png" alt="" title="计时器" /></p><hr /><h3 id="选择重传协议selective-repeat"><a class="markdownIt-Anchor" href="#选择重传协议selective-repeat"></a> 选择重传协议(Selective Repeat)</h3><p><img src="https://s2.loli.net/2022/01/05/uiCwHhj1sIADbyU.png" alt="" title="选择重传" /></p><ul><li>发送窗口和接收窗口大小都为<code>(MAX_SEQ+1)/2</code></li><li>当错误发生时，<code>接收方会立即发送一个NAK</code></li><li>缓存区更大</li></ul><p><img src="https://s2.loli.net/2022/01/05/bBSyxo3KhJeNuQq.png" alt="" title="选择重传" /></p><ul><li>发送方：<ul><li>如果收到ACK，且该ACK帧序号在窗口内，则将该帧确认为已接收</li><li>如果该序号是窗口的下界，则窗口向前移动到具有最小序号的未确认帧处</li><li>若窗口移动了，并且还有序号在窗口内的未发送帧，则发送该帧</li></ul></li><li>接收方：<ul><li><code>利用捎带确认或者独立确认(辅助计时器)</code>来发送ACK</li><li>接收方会确认在接收窗口里任意编号的正确帧（窗口大小的原因）</li><li>失序的帧会被<code>缓存</code>，并且返回给发送方一个确认帧。</li><li>如果收到了窗口序号外（小于窗口下界）的帧，就返回一个ACK。其他情况则忽略。</li></ul></li></ul><p><img src="https://s2.loli.net/2022/01/05/S9ZpdiErnDjFkC1.png" alt="" title="选择重传" /></p><hr /><h2 id="数据链路层实例"><a class="markdownIt-Anchor" href="#数据链路层实例"></a> 数据链路层实例</h2><hr /><h1 id="介质访问控制子层the-medium-access-control-sublayer"><a class="markdownIt-Anchor" href="#介质访问控制子层the-medium-access-control-sublayer"></a> 介质访问控制子层(The Medium Access Control Sublayer)</h1><p><img src="https://s2.loli.net/2022/01/05/2DmIp5tadVxfXAP.jpg" alt="" /></p><hr /><p><img src="https://s2.loli.net/2022/01/05/rmegylVaTYQp74d.png" alt="" /></p><ul><li><code>MAC子层负责介质访问控制机制的实现，即处理局域网中各站点对共享通信介质的争用问题</code></li><li>MAC子层还涉及局域网中的物理寻址；而LLC子层负责屏蔽掉MAC子层的不同实现，将其变成统一的LLC界面，从而向网络层提供一致的服务</li></ul><p><img src="https://s2.loli.net/2022/01/05/Y8KPAUN1pETdaDF.png" alt="" /></p><hr /><h2 id="共享信道分配问题"><a class="markdownIt-Anchor" href="#共享信道分配问题"></a> 共享信道分配问题</h2><h3 id="静态信道分配方法"><a class="markdownIt-Anchor" href="#静态信道分配方法"></a> 静态信道分配方法</h3><ul><li><p>所谓静态分配方法，也是<code>传统</code>的分配方法，它采用<code>频分多路复用、时分多路复用或CDMA</code>将单个信道划分后静态地分配给多个用户。</p></li><li><p>当<code>用户站数较多</code>或<code>使用信道的站数在不断变化</code>或者<code>通信量的变化具有突发性</code>时，静态频分多路复用方法的性能较差，因此，传统的静态分配方法，不完全适合计算机网络</p></li></ul><hr /><h3 id="动态信道分配方法"><a class="markdownIt-Anchor" href="#动态信道分配方法"></a> 动态信道分配方法</h3><ul><li>所谓动态分配方法就是动态地为每个用户站点分配信道使用权。<ul><li>竞争法协议<ul><li>存在冲突</li></ul></li><li>无冲突法协议</li><li>有限竞争协议<ul><li>前两种的组合</li></ul></li></ul></li></ul><hr /><h3 id="动态信道分配的假设"><a class="markdownIt-Anchor" href="#动态信道分配的假设"></a> 动态信道分配的假设</h3><ol><li>站模式(independent traffic)：由N个<code>独立</code>的站（比如计算机、电话）组成，每个站都有一个程序或者用户产生要传输的帧。</li><li>单信道(Single Channel)：所有的通信都用这一个信道。所有的站可以在该信道上传输数据，也可以从该信道接收数据。</li><li>冲突可观察(observable Collision)<ul><li>如果两帧同时传输，则它们在<code>时间上就重叠</code>，由此产生的信号是混乱的，这种情况称为<code>冲突</code>(collision)。</li><li>所有的站都能够检测到冲突事件的发生。冲突的帧必须在以后再次被发送。除了因冲突而产生错误外，不会再有其他的错误。</li></ul></li><li>时间连续或分槽(Continuous or slotted time)</li></ol><ul><li>时间连续：时间可以假设是连续的，即在任何时刻都可以开始传输帧。</li><li>分槽：<ul><li>时间分槽或者分成离散的间隔（称为时间槽）。</li><li>帧的传输只能从某个时间槽的起始点开始。</li><li>一个时间槽可能包含0、1 或者多个帧，分别对应于空闲的时间槽、一次成功发送，或者一次冲突。</li></ul></li></ul><ol start="5"><li>载波侦听或不听(Carrier Sense or no carrier sense)</li></ol><ul><li>有了载波侦听的假设，一个站在试图用信道之前就能<code>知道该信道当前是否正被使用</code>。如果信道侦听结果是忙，则没有一个站会再去试图使用该信道。</li><li>通过向信道上加载侦听帧来判断</li><li>N个侦听帧叠加仍是侦听帧；侦听帧和数据帧叠加仍是原来的数据帧</li><li>如果收到的信息和侦听帧相同，则信道空闲</li></ul><hr /><h2 id="多路访问协议"><a class="markdownIt-Anchor" href="#多路访问协议"></a> 多路访问协议</h2><h3 id="aloha"><a class="markdownIt-Anchor" href="#aloha"></a> ALOHA</h3><h4 id="pure-aloha"><a class="markdownIt-Anchor" href="#pure-aloha"></a> Pure ALOHA</h4><ul><li>对应连续时间</li></ul><p><img src="https://s2.loli.net/2022/01/05/YvIpT1E4dGsSALV.png" alt="" /></p><ul><li>数据帧可以在任意时间点发送</li><li>每个站在给中央计算机发送帧之后，该计算机把该帧重新广播给所有站。因此，那个<code>发送站可以侦听来自集线器的广播</code>，以此确定它的帧是否发送成功。</li><li>如果帧被损坏了，则发送方要等待一段<code>随机时间</code>，然后再次发送该帧。<ul><li>等待的时间必须是随机的，否则同样的帧会一次又一次地冲突，因为冲突帧被重发的节奏完全一致。</li></ul></li></ul><p><img src="https://s2.loli.net/2022/01/06/6F9GQZKqvMbghI2.png" alt="" /></p><ul><li>要想正确地发送数据帧，则发送数据帧的<code>前一个帧时</code>和<code>当前帧时</code>其他用户不能发送数据帧，即易冲突期为两个帧时<ul><li>帧时(frame time)：表示传输一个标准的、固定长度的帧所需要的时间（即帧的长度除以比特率）</li></ul></li></ul><hr /><h4 id="pure-aloha-协议的效率分析"><a class="markdownIt-Anchor" href="#pure-aloha-协议的效率分析"></a> Pure ALOHA 协议的效率分析</h4><ul><li>S：吞吐率，一个帧时产生的新的帧的数目</li><li>G：吞吐量，一个帧时内等待发送的帧的个数</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">P_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：一个数据帧不发生冲突的概率<ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><mi>G</mi><msub><mi>P</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">S = GP_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault">G</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li></ul></li><li>在给定的一个帧时内希望有G帧，但生成k帧的概率服从<code>泊松分布</code>：$$P_r[k] = G<sup>ke</sup>{-G}/k!$$</li><li>生成0帧的概率为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>e</mi><mrow><mo>−</mo><mi>G</mi></mrow></msup></mrow><annotation encoding="application/x-tex">e^{-G}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">G</span></span></span></span></span></span></span></span></span></span></span></span>。在两个帧时长的间隔中，生成帧的平均数是2G。</li><li>因此，在整个易受冲突期中，不发送帧的概率是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub><mo>=</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>G</mi></mrow></msup></mrow><annotation encoding="application/x-tex">P_0 = e^{-G}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">G</span></span></span></span></span></span></span></span></span></span></span></span>，利用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><mi>G</mi><msub><mi>P</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">S = GP_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault">G</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>可以得到$$S = Ge^{-2G}$$</li></ul><p><img src="https://s2.loli.net/2022/01/05/JUgfrD2wF1cKl6C.png" alt="" /></p><ul><li>最大的吞吐量出现在当<code>G=0.5 时，S = 1/2e</code>, 大约等于 0.184 。</li></ul><hr /><h4 id="slotted-aloha"><a class="markdownIt-Anchor" href="#slotted-aloha"></a> Slotted ALOHA</h4><ul><li><p>信道上的时间被分成离散的时间间隔即时槽，其<code>大小相当于帧的传输时间</code>。所有站点的时钟保持同步。<code>站点只有在时槽开始时</code>才能传输数据。</p></li><li><p>只有那些都在同一个时槽开始进行传输的帧才有可能冲突，可能发生冲突危险区比ALOHA降低了一半 。</p><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub><mo>=</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>G</mi></mrow></msup></mrow><annotation encoding="application/x-tex">P_0 = e^{-G}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">G</span></span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><mi>G</mi><msup><mi>e</mi><mrow><mo>−</mo><mi>G</mi></mrow></msup></mrow><annotation encoding="application/x-tex">S = Ge^{-G}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord mathdefault">G</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">G</span></span></span></span></span></span></span></span></span></span></span></span></li><li>当 <code>G = 1，S = 1/e</code>，有最大吞吐量</li></ul></li></ul><p><img src="https://s2.loli.net/2022/01/05/1sNmJH76ZkylpYG.png" alt="" /></p><ul><li>吞吐量G在拐点左侧时为<code>轻载荷</code>：吞吐率S随G增加而增加</li><li>吞吐量G在拐点左侧时为<code>重载荷</code>：吞吐率S随G增加而减少，因为冲突概率增加了</li></ul><hr /><h3 id="csma-载波侦听多路访问协议"><a class="markdownIt-Anchor" href="#csma-载波侦听多路访问协议"></a> CSMA （载波侦听多路访问协议）</h3><ul><li><p>ALOHA 和分槽ALOHA都没有利用到无线分组网和局域网的一个主要特性，那就是与帧的传输时间相比，<code>传播时间是很短的</code>：当一个站点发送帧后，别的站点马上就会知道。</p></li><li><p>CSMA机制：也称为<code>先听先说</code>，是<code>竞争法</code>协议</p><ul><li>想要传输的站点首先<code>侦听传输介质</code>上是否有其他站点在传输（载波监听〕。如果传输介质忙，它必须等待。如果空闲，则可能传输。</li><li>两个或多个站点还是有可能同时开始传输，这时就会产生冲突。考虑到这种情况，发送站点在发送完后要等待一段时间（<code>要把来回传输的最大时间和发送确认的站点竞争信道的时间考虑在内</code>）以等待确认，如果没有收到确认，发送站点认为发生了冲突，就重发该帧。</li></ul></li></ul><hr /><h4 id="持续和非持续csma"><a class="markdownIt-Anchor" href="#持续和非持续csma"></a> 持续和非持续CSMA</h4><ul><li><p>非持续CSMA</p><ul><li>基本思想：<ol><li>若媒体空闲就传输；否则，转到第2步</li><li>若媒体忙，等待一段<code>随机</code>的重传延迟时间，重复第1步</li></ol></li><li>缺点：如果多个站点同时会浪费部分信道容量</li></ul></li><li><p>1-持续CSMA协议</p><ul><li>基本思想：<ol><li>若媒体空闲就传输；否则，转到第2步</li><li>若媒体忙则继续监听，直到检测到信道空闲然后立即传输</li><li>如有冲突，则等待一段随机的时间重复第1步</li></ol></li></ul></li><li><p>P-持续CSMA协议</p><ul><li>基本思想：<ul><li>若媒体空闲，以<code>概率P</code>传输，以<code>概率(1-P)</code>延迟一个时间单位。该时间单位通常<code>等于最大的传播延迟的两倍</code></li><li>若传输延迟了一个时间单位，则重复第1步</li><li>若媒体忙，继续监听直到信道空闲并重复第1步</li></ul></li></ul></li></ul><p><img src="https://s2.loli.net/2022/01/05/7MSpoD2QGkF5vPs.png" alt="" /></p><ul><li>P-持续CSMA和非持续CSMA在重载荷情况下信道吞吐率相对较高</li></ul><hr /><h4 id="带冲突检测的csma-csmacd-csma-with-collision-detection"><a class="markdownIt-Anchor" href="#带冲突检测的csma-csmacd-csma-with-collision-detection"></a> 带冲突检测的CSMA (CSMA/CD, CSMA with Collision Detection)</h4><ul><li><p>以太网采用的是CSMA/CD</p><ul><li>载波监听：站点能监测到链路是忙还是空闲；</li><li><code>冲突检测</code>：站点在<code>传输的同时监听信道</code>，从而能够监测到站点所传输的帧与别的站点传输的帧之间发生冲突的情形 。</li></ul></li><li><p>基本算法</p><ol><li>若媒体空闲，传输；否则，转第2步。</li><li>若媒体忙，<code>一直监听直到信道空闲</code>然后立即传输。<ul><li>本质是1-持续CSMA加上冲突检测</li></ul></li><li>若在传输中监听到冲突，发出一个短小的人为干扰信号让所有的站点都知道发生了冲突并停止传输。</li><li>发完人为干扰信号，<code>等待一段随机的时间</code>，再次试图传输（从第1步开始重复〕。</li></ol></li><li><p>工作过程通常可以概括为</p><ul><li>先听后发</li><li>边听边发</li><li>冲突停发</li><li>随机重发</li></ul></li></ul><p><img src="https://s2.loli.net/2022/01/05/dDNTc1YszSwnh3e.png" alt="" /></p><ul><li>CSMA/CD的状态</li></ul><p><img src="https://s2.loli.net/2022/01/05/sF9rACiGt75c3Ym.png" alt="" /></p><hr /><h3 id="无冲突协议collision-free-protocols"><a class="markdownIt-Anchor" href="#无冲突协议collision-free-protocols"></a> 无冲突协议(Collision-Free Protocols)</h3><ul><li>核心思想是避免冲突<ul><li>发送端必须知道什么时候轮到它来发送数据</li></ul></li></ul><h4 id="基本位图协议the-basic-bit-map-protocol"><a class="markdownIt-Anchor" href="#基本位图协议the-basic-bit-map-protocol"></a> 基本位图协议(The basic bit-map protocol)</h4><p><img src="https://s2.loli.net/2022/01/05/mpH2saFwniEYzcG.png" alt="" /></p><ul><li>每个竞争期正好包含N个槽，<code>j号站通过在j号槽中插入1位</code>来声明自己有帧要发送</li><li>当所有N个槽都经过后，每个站都知道哪些站希望传送数据，此时它们<code>按数字顺序</code>开始传送数据</li><li>像这样<code>在实际传送数据之前先广播自己有发送数据愿望</code>的协议，称为预留协议(reservation protocol)</li><li>效率分析：N个竞争位，每一帧数据长度为d位<ul><li>重载荷：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>N</mi><mo>∗</mo><mi>d</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>N</mi><mo>+</mo><mi>N</mi><mo>∗</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(N*d)/(N+N*d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mclose">)</span></span></span></span></li><li>轻载荷：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>N</mi><mo>+</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d/(N+d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mclose">)</span></span></span></span></li><li>适合于重载荷信道分配，在轻载荷时效率较低</li></ul></li></ul><hr /><h4 id="二进制倒计数binary-countdown"><a class="markdownIt-Anchor" href="#二进制倒计数binary-countdown"></a> 二进制倒计数(Binary countdown)</h4><ul><li>对基本位图进行改进，将原来的竞争位数由N下降到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">log_2N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></li></ul><p><img src="https://s2.loli.net/2022/01/05/gmM41iVladDFJH5.png" alt="" /></p><ul><li><p>如果一个站想要使用信道，它就以<code>二进制位串</code>的形式从高序的位开始广播自己的地址。</p><ul><li>假定所有地址都有同样的长度。</li><li>不同站地址中相同位在同时发送时被信道<code>布尔或</code>(BOOLEAN OR)在一起。</li><li>我们把这样的协议称为二进制倒计数 (binary countdown)协议</li></ul></li><li><p>该协议具有这样一种特性，高序站的优先级比低序站的优先级高</p></li><li><p>在<code>轻载荷</code>情境下，该协议效率较高</p></li></ul><hr /><h3 id="有限竞争协议limited-contention-protocols"><a class="markdownIt-Anchor" href="#有限竞争协议limited-contention-protocols"></a> 有限竞争协议(Limited-Contention Protocols)</h3><ul><li>将站点进行分组，在组间使用无冲突法协议，在组内采用竞争法协议进行信道分配<ul><li>避免了竞争和空闲造成的浪费</li></ul></li></ul><p><img src="https://s2.loli.net/2022/01/05/lUpad8h6je2Z7yo.png" alt="" /></p><ul><li>只要减少参与竞争的站数量，则站获得信道的概率就会增加。</li><li>通过调整每组中站点个数n来动态地进行信道分配。<ul><li>轻载荷尽量用竞争法，将n增大</li><li>重载荷尽量用无冲突法，将n减小</li></ul></li></ul><hr /><h3 id="无线局域网协议limited-contention-protocols"><a class="markdownIt-Anchor" href="#无线局域网协议limited-contention-protocols"></a> 无线局域网协议(Limited-Contention Protocols)</h3><ul><li>无线局域网络相比于有线网络更加复杂<ul><li>节点可能有不同的覆盖范围<ul><li>导致<code>隐蔽终端</code>和<code>暴露终端</code>问题</li></ul></li><li>节点无法检测出冲突<ul><li>避免冲突的代价很昂贵</li></ul></li></ul></li></ul><p><img src="https://s2.loli.net/2022/01/05/L4xyMESOGjoT92s.png" alt="" /></p><ul><li><code>隐藏终端问题</code>(hidden station problem)：由于竞争者离得太远而导致站无法检测到潜在的竞争者</li><li><code>暴露终端问题</code>(exposed station problem)：发送方侦听到传输，但能安全传输到不同的接收方</li></ul><hr /><h4 id="冲突避免多路访问cmaca-multiple-access-with-collision-avoidance"><a class="markdownIt-Anchor" href="#冲突避免多路访问cmaca-multiple-access-with-collision-avoidance"></a> 冲突避免多路访问(CMACA, Multiple Access with Collision Avoidance)</h4><p><img src="https://s2.loli.net/2022/01/05/qdMbKtLJh4lBf1O.png" alt="" /></p><ul><li>A首先给B发送一个<code>RTS</code> (Request To Send )帧，这个短帧 (30 字节)包含了随后将要发送的数据帧的长度</li><li>然后，B用一个 <code>CTS</code> (Clear to Send)作为应答，CTS 帧也包含了数据长度（从 RTS 帧中复制过来）。</li><li>A在收到了 CTS 帧之后便开始传输。</li><li>如果一个站<code>听到了 RTS 帧，那么它一定离 A 很近</code>，它必须保持沉默，至少等待足够长的时间以便在无冲突情况下 CTS 被返回给 A。<ul><li>C 落在 A 的范围内，但不在 B 的范围内。因此，<code>它听到了 A 发出的 RTS</code>，但是没有听到 B 发出的 CTS 。只要它没有干扰 CTS ，那么在数据帧传送过程中，它可以自由地发送任何信息。即它是个<code>暴露终端</code></li></ul></li><li>如果一个站<code>听到了 CTS ，则它一定离 B 很近</code>，在<code>接下来的数据传送过程中</code>它必须一直保持沉默，只要检查 CTS 帧，该站就可以知道数据帧的长度（即数据传输要持续多久）。<ul><li>D 落在 B 的范围内，但不在 A 的范围内。它听不到 RTS 帧，但是<code>听到了 CTS 帧</code>。只要听到了 CTS 帧，这意味着它与一个将要接收数据帧的站离得很近，所以，它就延缓发送任何信息<code>直到那个帧如期传送完毕</code>。</li><li>站 E 听到了这两条控制消息，和 D 一样在数据帧完成之前它必须保持安静。</li></ul></li></ul><hr /><h2 id="以太网ethernet"><a class="markdownIt-Anchor" href="#以太网ethernet"></a> 以太网(Ethernet)</h2><h3 id="以太网的产生和发展"><a class="markdownIt-Anchor" href="#以太网的产生和发展"></a> 以太网的产生和发展</h3><ul><li>以太网的起源:ALOHA无线电系统(1968-1972)</li><li>Xerox 创建第一个实验性的以太网(1972-1977)</li><li>DEC、Intel和Xerox将以太网标准化(1979-1983)</li><li>IEEE 802.3标准问世（1982年）,10BASE-5出现；</li><li>10BASE-T结构化布线的历史(1986-1990)</li><li>交换式和全双工制以太网的出现(1990-1994)</li><li>快速以太网的出现(1992-1995)</li><li>千兆网的出现(1996至今)</li></ul><hr /><h4 id="以太网电缆ethernet-cabling"><a class="markdownIt-Anchor" href="#以太网电缆ethernet-cabling"></a> 以太网电缆(Ethernet Cabling)</h4><ul><li>有4种正式的<code>10 Mbps</code>以太网标准。<ul><li>10Base-5：10Base-5是最初的<code>粗同轴电缆</code>以太网标准。</li><li>10Base-2：10Base-2是<code>细同轴电缆</code>以太网标准。</li><li>10Base-T：10Base-T是10 Mbps的<code>双绞线</code>以太网标准。</li><li>10Base-F：10Base-F是10 Mbps的<code>光缆</code>以太网标准。</li></ul></li></ul><p><img src="https://s2.loli.net/2022/01/05/rjHSvBeFEDPUxoz.png" alt="" /></p><blockquote><p>IEEE 802.3 标准<br><br /><img src="https://s2.loli.net/2022/01/05/zFbR67M8YOAeouh.png" alt="" /></p></blockquote><p><img src="https://s2.loli.net/2022/01/05/Kjh2nBpk3aUGXMe.png" alt="" /></p><p><img src="https://s2.loli.net/2022/01/05/E3sg5GKWFPdIn8c.png" alt="" /></p><hr /><h4 id="以太网中信号编码"><a class="markdownIt-Anchor" href="#以太网中信号编码"></a> 以太网中信号编码</h4><p><img src="https://s2.loli.net/2022/01/05/sU8GYTJCpRyMzSI.png" alt="" /></p><hr /><h3 id="经典以太网-mac-子层协议"><a class="markdownIt-Anchor" href="#经典以太网-mac-子层协议"></a> 经典以太网 MAC 子层协议</h3><p><img src="https://s2.loli.net/2022/01/05/u5PnN6FRJ13sdXv.png" alt="" /></p><ul><li>首先是 8 bytes 的前导码<code>(Preamble)</code>，每个字节包含比特模式<code>10101010</code>（除了最后一个字节的最后 2 位为 11 ）<ul><li>这最后一个字节称为 802.3 的帧起始定界符 (Start of Frame, SOF)</li></ul></li><li>如果传输出去的目标地址第一位是 0，则表示这是一个普通地址；如果是 1，则表示这是一个组地址。<ul><li>由全 1 组成的特殊地址保留用作<code>广播(broadcasting )</code></li><li>地址字段的前 3 个字节用作该站所在的组织<code>唯一标识符</code>(OUI, Organizationally Unique Identifier )</li></ul></li><li>采用<code>类型</code>(Type)或<code>长度</code>(Length)字段取决于是以太网帧还是 IEEE 802.3 帧。<ul><li>类型字段指定了<code>把帧送给哪个进程处理</code>。</li><li>长度字段指明数据的长度<ul><li>限定了最大长度(1500 bytes)</li></ul></li><li>任何值小于或等于 1500 可解释为长度字段，任何大于 1500 可解释为类型字段</li></ul></li><li>以太网要求有效帧必须<code>至少 64 字节长</code>，从目标地址算起直到校验和，包括这两个字段本身在内。如果帧的数据部分少于 46 个字节，则使用<code>填充 (Pad)</code> 字段来填充该帧，使其达到最小长度要求。</li></ul><p><img src="https://s2.loli.net/2022/01/05/jDtKeIFyU1JgVl8.png" alt="" /></p><ul><li>限制最小帧长的最重要的原因是为了避免如上图所示情况当一个短帧还没有到达电缆远端的发送方，该帧的传送就已经结束：而在电缆的远端，该帧可能与另一帧发生冲突。此时无法检测冲突。</li></ul><hr /><h4 id="二进制指数后退的-csmaca-the-binary-exponential-backoff-algorithm"><a class="markdownIt-Anchor" href="#二进制指数后退的-csmaca-the-binary-exponential-backoff-algorithm"></a> 二进制指数后退的 CSMA/CA (The Binary Exponential Backoff Algorithm)</h4><ul><li>一般地，在第 i 次冲突时，从<b> $ 0 $ ~ $2^i-1 $ </b>之间随机选择一个数，然后等待这么多个时间槽，之后再重试发送。<ul><li>时间被分成离散的时槽，其长度等于在传输媒体上来回传输的时间（<code>帧时</code>），802.3标准规定为512比特时间。</li></ul></li><li>如果冲突的次数达到10次后，随机等待的<code>最大时槽数固定为1023</code>。在<code>16次</code>冲突后，站点放弃传输，并报告一个错误。</li></ul><hr /><h3 id="以太网的性能"><a class="markdownIt-Anchor" href="#以太网的性能"></a> 以太网的性能</h3><p><img src="https://s2.loli.net/2022/01/05/BNqYt2Xr1mvjk5b.png" alt="" /></p><hr /><h3 id="交换式以太网switched-ethernet"><a class="markdownIt-Anchor" href="#交换式以太网switched-ethernet"></a> 交换式以太网(Switched Ethernet)</h3><p><img src="https://s2.loli.net/2022/01/05/VPKRuWB2cGvU6yt.png" alt="" /></p><ul><li>交换机以太网利用以太网交换机组网，既可以<code>将计算机直连到交换机的端口上</code>，也可以<code>将它们连入一个网段</code>，然后将这个网段连到交换机的端口。<ul><li>如果将计算机直接连到交换机的端口，那么它将独享该端口提供的带宽</li><li>如果计算机通过以太网连入交换机，那么该以太网上的所有计算机共享交换机端口提供的带宽</li></ul></li></ul><p><img src="https://s2.loli.net/2022/01/05/Jaomq2DgSA1LOkT.png" alt="" /></p><ul><li>交换机只<code>把帧输出到该帧想去的端口</code>。<ul><li>当交换机端口接收到来自某个站的以太网帧，它就检查该帧的以太网地址，确定该帧前往的目的地端口</li></ul></li></ul><hr /><h3 id="快速以太网fast-ethernet"><a class="markdownIt-Anchor" href="#快速以太网fast-ethernet"></a> 快速以太网(Fast Ethernet)</h3><ul><li>快速以太网技术100Base-T是由10Base-T标准以太网发展而来的。<ul><li>其协议标准为1995年颁布的IEEE 802.3u，可<code>支持100 Mbps</code>的数据传输速率</li><li>与 10 Base-T 一样可支持共享式与交换式两种使用环境，在交换式以太网环境中可以实现全双工通信。</li><li>IEEE 802.3u 在 MAC 子层<code>仍采用CSMA/CD作为介质访问控制协议</code>，并保留了IEEE 802.3的帧格式<br /><img src="https://s2.loli.net/2022/01/05/EIKoPxsX8aJHMyC.png" alt="" /></li></ul></li></ul><p><img src="https://s2.loli.net/2022/01/05/dnBmSjYkcO8paJM.png" alt="" /></p><blockquote><p>采用快速以太网集线器作为中央设备（100Base-TX集线器），使用非屏蔽5类双绞线以星型连接的方式连接以太网节点（工作站和服务器），以及连接另一个快速以太网集线器和10Base-T的共享集线器。</p></blockquote><h4 id="千兆以太网gigabit-ethernet"><a class="markdownIt-Anchor" href="#千兆以太网gigabit-ethernet"></a> 千兆以太网(Gigabit Ethernet)</h4><p><img src="https://s2.loli.net/2022/01/06/zlfUu2A1ymnYkQo.png" alt="" /></p><p><img src="https://s2.loli.net/2022/01/05/mNC9cuROfZzDLVn.png" alt="" /></p><hr /><h2 id="无线局域网wireless-lans"><a class="markdownIt-Anchor" href="#无线局域网wireless-lans"></a> 无线局域网(Wireless LANs)</h2><h3 id="80211-体系结构和协议栈"><a class="markdownIt-Anchor" href="#80211-体系结构和协议栈"></a> 802.11 体系结构和协议栈</h3><p><img src="https://s2.loli.net/2022/01/05/LrO1A5MZCFdjtTD.png" alt="" /></p><ul><li><p>在<code>有架构模式</code>下，每个客户端与一个接入点 AP<code>( Access Point )</code>关联，该接入点又与其他网络连接。</p><ul><li>客户端发送和接收数据包都要通过 AP 进行。</li><li>几个接入点可通过一个称为<code>分布式系统( distribution system )</code>的有线网络连接在一起，形成一个扩展的 802.11 网络。<ul><li>在这种情况下，客户端可以通过它们的接入点向其他客户端发送帧。</li></ul></li></ul></li><li><p><code>自组织网络( ad hoc network )</code>模式下的网络由一组相互关联的计算机组成，它们<code>相互之间可以直接向对方发送帧。</code></p><ul><li>自组织网络并没有那么受欢迎。</li></ul></li></ul><hr /><p><img src="https://s2.loli.net/2022/01/05/vkn8RlsWIHxp2uc.png" alt="" /><br /><img src="https://s2.loli.net/2022/01/05/ENFxsXyIkZRO92c.png" alt="" /></p><ul><li>客户端和 AP 的协议枝相同。物理层对应于 OSI 的物理层</li><li>所有 802 协议的数据链路层分为两个或更多个子层<ul><li>在 802.11 ，介质访控制 (MAC, Medium Access Control) 子层<code>决定如何分配信道</code></li><li>逻辑链路控制 (LLC, Logical Link Control) 子层的工作是<code>隐藏 802系列协议之间的差异</code>，使它们在网络层看来并无差别。</li></ul></li></ul><hr /><h3 id="80211-mac-子层协议"><a class="markdownIt-Anchor" href="#80211-mac-子层协议"></a> 802.11 MAC 子层协议</h3><ul><li>802.11 试图避免冲突，采用的协议称为带有冲突避免的 CSMA<ul><li>需要发送帧的站必须<code>以随机后退开始</code>（除非它最近没有用过信道，并且信道处于空闲状态），而且它不等待冲突的发生。</li><li>该站将等待，直到信道处于闲置状态。<ul><li>通过侦听确定在一个很短的时间内没有信号，然后倒计数空闲时间槽，<code>当有帧在发送时暂停该计数器</code></li><li>当计数器递减到 0,该站就发送自己的帧。</li><li>如果帧发送成功，<code>目标站立即发送一个短确认(ACK)</code></li><li>如果没有收到确认，则可推断出传输发生了错误，无论是冲突或是其他什么错。在这种情况下，发送方要<code>加倍后退选择的时间槽数，再重新试图发送</code>。如此反复，直到成功发送帧或达到重传的最大次数。</li></ul></li></ul></li></ul><p><img src="https://s2.loli.net/2022/01/05/UzvwhLV9srnb1Ry.png" alt="" /></p><ul><li><p>A 站首先发出一个帧。当 A 发送时，B 站和 C 站准备就绪发送。</p></li><li><p>它们看到信道正忙，便等待它变成空闲。</p></li><li><p>不久，A 收到一个确认，信道进入空闲状态。然而，<code>不是两个站都发出一帧</code>从而立即产生冲突，而是<code>B 站和C 站都执行后退算法</code>。</p></li><li><p>C 站选择了一个较短的后退时间，因而先获得发送权。B 站侦听到 C 在使用信道时<code>暂停自己的倒计时</code>，并在<code>C 收到确认之后立即恢复倒计时</code>。</p></li><li><p>一旦 B 完成了后退，立即发送自己的帧。</p></li><li><p>和以太网相比，这里有两个主要区别：</p><ul><li>首先，早期的后退有助于避免冲突。</li><li>其次，可以利用确认来推断是否发生冲突。</li></ul></li></ul><hr /><ul><li>不同站的<code>传输范围可能有所不同</code>。有线环境下，系统被设计成让所有站都可以听到对方。在射频传播的复杂环境下，这种状况并不适用于无线站。因此，类似前面提到的隐藏终端等问题就会出现。</li></ul><p><img src="https://s2.loli.net/2022/01/05/N5vQIAHaxgKyzBf.png" alt="" /></p><ul><li>802.11 定义信道侦听包括<code>物理侦听</code>和<code>虚拟侦</code>听两部分。<ul><li><code>物理侦听只是简单地检查介质</code>，看是否存在有效的信号</li><li>有了<code>虚拟侦听，每个站可以保留一个信道何时要用的逻辑记录</code>，这是通过跟踪<code>网络分配向量( NAV, Network Allocation Vector )</code>获得的。<ul><li><code>NAV 信号是不传输的</code>，它们只是由站内部使用，提醒自己保留一定时间内的安静。</li><li>每个帧携带一个<code>NAV 字段，说明这个帧所属的一系列数据将传输多长时间</code>。无意中听到这个帧的站就知道无论自己是否能够侦听到物理信号，由 NAV所指出的时间段信道一定是繁忙的。</li><li><code>可选的 RTS/CTS 机制</code>使用 NAV 来防止隐藏终端在同一时间发送。</li></ul></li></ul></li></ul><p><img src="https://s2.loli.net/2022/01/05/b8yWnjSefmTOrE9.png" alt="" /></p><hr /><ul><li>802.11 个巧妙的机制来让 VoIP 通信先于对等流量传输。<ul><li>它是作为一组扩展于2005 年被引入的，标准命名为 802.11e 。</li><li>它扩展了 CSMA/CA，并且仔细定义帧之间的各种时间间隔。</li><li>帧发出去后，<code>需要保持一段特定时间的空闲以便检查信道不在被用</code>，然后任何站才可以发送帧。这里的关键就在于为不同类型的帧确定不同的时间间隔。</li></ul></li></ul><p><img src="https://s2.loli.net/2022/01/05/F6McJIWhtTZ1pLD.png" alt="" /></p><ul><li>常规的数据帧之间的间隔称为 DCF 帧间隔 (<code>DIFS</code>, DCF InterFrame Spacing )</li><li>最短的间隔是<code>短帧间间隔</code>( <code>SIFS</code>, Short InterFrame Spacing )</li><li><code>仲裁帧间空间</code>(<code>AIFS</code>, Arbitration lnterFrame Space) 间隔显示了两个不同优先级的例子。短的时间间隔 AIFSl 小于 DIFS ，但比 SIFS 长。</li><li><code>扩展帧间间隔</code> (<code>EIFS</code>, Extended InterFrame Spacing)，仅用于一个站刚刚收到坏帧或未知帧后报告问题。</li></ul><hr /><h3 id="80211-帧结构"><a class="markdownIt-Anchor" href="#80211-帧结构"></a> 802.11 帧结构</h3><ul><li><p>802.11 标准定义了三种不同类型的帧：<code>数据帧、控制帧和管理帧</code>。每一种帧都有一个头，包含了与 MAC 子层相关的各种字段。</p></li><li><p>根据类型不同，帧的结构存在差异</p></li><li><p><code>数据帧</code>有三个地址用于通过APs</p></li></ul><p><img src="https://s2.loli.net/2022/01/05/pNPzMFfVu3q8XJY.png" alt="" /><br /><img src="https://s2.loli.net/2022/01/06/X8HOa3oYKIuUZFN.png" alt="" /></p><ul><li>Protocol Version ― 表示 IEEE 802.11 标准版本。</li><li>Type ― 帧类型：管理、控制和数据。</li><li>Subtype ― 帧子类型：认证帧、解除认证帧、连接请求帧，连接响应帧、重新连接请求帧、重新连接响应帧、解除连接帧、信标帧、Probe 帧、Probe 请求帧或 Probe 响应帧。</li><li>To DS ― 当帧发送给 Distribution System（DS）时，该值设置为1。</li><li>From DS ― 当帧从 Distribution System（DS）处接收到时，该值设置为1。</li><li>MF ― More Fragment 表示当有更多分段属于相同帧时该值设置为1。</li><li>Retry ― 表示该分段是先前传输分段的重发帧。</li><li>Pwr ― Power Management，表示传输帧以后，站所采用的电源管理模式。</li><li>More ― More Data，表示有很多帧缓存到站中。</li><li>W ― WEP，表示根据WEP（Wired Equivalent Privacy） 算法对帧主体进行加密。</li><li>O ― Order 表示利用严格顺序服务类发送帧的顺序。</li><li>Duration 值用于网络分配向量（NAV）计算。</li><li>RA(receiver address)：无线网络中，该<code>数据帧的接收者</code></li><li>TA(transmitter address)：无线网络中，该<code>数据帧的发送者</code></li><li>DA(destine address)：该帧的<code>目的mac地址</code></li><li>SA(source address)：该帧的<code>源mac地址</code></li><li>Sequence Control ― 由分段号（4位）和序列号（12位）组成。</li><li>Data ― 发送或接收的信息。</li><li>CRC ― 包括32位的循环冗余校验（CRC）。</li></ul><hr /><h2 id="宽带无线broadband-wireless"><a class="markdownIt-Anchor" href="#宽带无线broadband-wireless"></a> 宽带无线(Broadband Wireless)</h2><ul><li><code>802.16 被非正式称为全球微波接入互操作性</code>( <code>WiMAX</code>, Worldwide Interoperability for Microwave Access )</li></ul><hr /><h3 id="80216-体系结构与协议栈"><a class="markdownIt-Anchor" href="#80216-体系结构与协议栈"></a> 802.16 体系结构与协议栈</h3><ul><li>无线客户端连接到有线基站（类似3G）</li></ul><p><img src="https://s2.loli.net/2022/01/05/oPmWdhak6TFJ84G.png" alt="" /></p><ul><li>用于空中接口的 802.16 协议栈总体结构与其他 802 网络相似，但有了更多的子层。</li></ul><p><img src="https://s2.loli.net/2022/01/05/i28lxuC5DQhYOKM.png" alt="" /></p><ul><li>物理层上面是数据链路层，它包括 3 个子层。<ul><li>最下面的安全子层涉及隐私和安全，它管理<code>加密、解密和密钥管理。</code></li><li>MAC 公共子层负责信道管理：基站调度下行信道，管理上行信道</li><li>特定服务汇聚子层(Convergence sublayer)采用了其他 802 协议的逻辑链路子层。它的功能是<code>为网络层提供接口</code>。<ul><li>协议定义了不同的汇聚子层，以便与不同的上层进行无缝连接。</li><li>尽管标准还定义了诸如以太网和 ATM 协议的映射，最<code>重要的选择还是 IP</code> 。</li><li>由于 IP 是无连接，而 802.16 MAC子层是面向连接的，因此两层之间必须在地址和连接之间进行映射。</li></ul></li></ul></li></ul><hr /><h3 id="80216-物理层"><a class="markdownIt-Anchor" href="#80216-物理层"></a> 802.16 物理层</h3><ul><li>802.16 标准的设计非常灵活在 2GHz 到 11 GHz 之间的范围内它都可以运行，并且支持大小不同的信道</li><li>这些信道上的传输<code>采用了 OFDM（正交频分复用）技术</code>，相比 802.11,802.16 OFDM 系统进行了优化设计，因而获得了许可频谱和广域传输的最大效益<ul><li>信道被分成具有一个更长符号持续时间的许多子载波，以便忍受无线信号的更大衰减</li><li>每个子载波上的符号以 QPSK QAM-16 QAM-64 调制方案发送</li></ul></li><li>802.16 的设计者选择了一个在站之间划分信道的灵活方案，该方案称为<code>正交频分多址(OFDMA, Orthogonal Frequency Division Multiple Access)</code><ul><li>有了 OFDMA ，可以为不同的站分配不同的子载波集，因此可以同时有多个站发送或接收。</li></ul></li></ul><p><img src="https://s2.loli.net/2022/01/05/ElrwF7n8UsgNAvt.png" alt="" /></p><ul><li>它以一个前导码开始来同步所有的站，然后是来自基站的下行链路传输。<ul><li>首先，基站发送流量图，告诉所有站<code>如何分配帧的下行子载波和上行子载波</code>。</li><li>基站控制着流量图，所以它可以根据每个站的需要一个帧一个帧地分配不同的带宽。</li><li>接下来，基站给不同的固定用户和移动站<code>发送突发流量</code>，所用的子载波由同时出现的流量图规定。</li><li>下行链路传输结束后，还要另外加一段<code>保护时间</code>，这样便于站从接收状态切换到发送状态。</li><li>最后，用户站和移动站通过上行链路向基站发送突发流量，所用的子载波通过流量图保留。</li><li>其中一个上行链路突发被保留用作<code>测距( ranging )</code>，这是一个过程，新的站通过它调整自己的时间，井向连接的基站请求初始带宽。</li></ul></li></ul><hr /><h3 id="80216-mac-子层协议"><a class="markdownIt-Anchor" href="#80216-mac-子层协议"></a> 802.16 MAC 子层协议</h3><ul><li><code>MAC 子层面向连接</code>，并且支持点对多点传输，这意味着一个基站可以和多个用户站通信。</li><li>下行链路方向的传输非常简单。<ul><li>基站控制着物理层的 <code>“突发” (burst)</code>，用来给不同用户站发送信息。</li><li>MAC 子层把自己的帧封装到这结构中。为了减少开销，有几种不同的选择。<ul><li>例如， MAC 帧可能被单独发送，或背靠背地打包成组一起发送</li></ul></li></ul></li><li>上行链路信道要复杂一些，因为多个需要接入的<code>用户要竞争它的使用权</code>。<ul><li>上行信道的分配方案与服务质量问题有紧密关系。服务分为 4 类，分别定义如下：<ol><li><strong>恒定比特率服务</strong><ul><li>目标是<code>传输未经压缩的语音信号</code></li><li>这种服务需要在预定的时间间隔中<code>发送预定数量的数据</code>。</li><li>具体做法是为这种类型的每个连接分配特定的“突发”，一旦带宽获得分配，则可自动用来发送“突发飞无须再次请求。</li></ul></li><li><strong>实时可变比特率服务</strong><ul><li>目标是<code>传输被压缩的多媒体</code></li><li>在所谓的软实时应用中，每个时刻需要的带宽可能都会发生变化。</li><li>具体做法是基站以一定的周期轮询用户，询问它每次传输需要多少带宽。</li></ul></li><li><strong>非实时可变比特率服务</strong><ul><li>目标是<code>非实时但繁重的传输任务</code></li><li>对于这种服务，基站要经常轮询用户，但不是按照严格预定的时间间隔</li></ul></li><li><strong>尽力而为服务</strong><ul><li>这里没有询问，用户必须与其他尽力而为型的用户竞争带宽。</li></ul></li></ol></li></ul></li></ul><hr /><h3 id="80216-帧结构"><a class="markdownIt-Anchor" href="#80216-帧结构"></a> 802.16 帧结构</h3><ul><li>所有 MAC 帧都以一个通用的头作为开始。头之后跟着一个可选的有效载荷字段和一个可选的校验和 (CRC) 字段</li><li>在<code>控制帧中有效载荷字段是不需要的</code>，例如，那些请求信道时间槽的控制帧。校验和也是可选的，这是因为在物理层上进行了纠错。</li></ul><p><img src="https://s2.loli.net/2022/01/05/mpnj1wtzfX4TsZ8.png" alt="" /></p><ul><li><strong>EC</strong> 比特指明了有效载荷字段是否经过了加密</li><li><strong>Type</strong> (类型)字段标识了该帧的类型，通常指明<code>是否存在封装和分段。</code></li><li><strong>CI</strong> 比特表明本帧是否包含最后的校验和</li><li><strong>EK</strong> 字段指明了所使用的加密密钥</li><li><strong>Length</strong>（长度）字段给出了该帧的总长度，<code>包括头部。</code></li><li><strong>Connection ID</strong> 字段指明了该帧属于哪个连接</li><li><strong>Header CRC</strong> 字段是一个仅仅<code>针对头的校验和</code>，所用的多项式为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mn>8</mn></msup><mo>+</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x^8+x^2+x+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li><li>(b) 显示了一个用来请求带宽的控制帧，它的开始处是一个“ 1 ”而不是“ 0 ”，它的第 2 个和第 3 个字节构成了一个 16 位的数字，该数字说明了<code>需要多少带宽来运载规定数量的字节</code></li><li>带宽请求帧并不包含有效载荷，也不包含针对整帧的 CRC.</li></ul><hr /><h2 id="ieee-8022-logical-link-controlllc逻辑链路控制"><a class="markdownIt-Anchor" href="#ieee-8022-logical-link-controlllc逻辑链路控制"></a> IEEE 802.2: Logical Link Control(LLC，逻辑链路控制)</h2><p><img src="https://s2.loli.net/2022/01/05/NRgiPtTxenhrQK3.png" alt="" /></p><ul><li>为数据链路层提供差错控制和流量控制</li><li>从网络层隐藏 802.3/4/5/… 固有的差异</li><li>提供三种服务<ul><li>不可靠的数据报服务。</li><li>确认的数据报服务。</li><li>可靠的面向连接的服务。</li></ul></li></ul><hr /><h2 id="数据链路层交换"><a class="markdownIt-Anchor" href="#数据链路层交换"></a> 数据链路层交换</h2><h3 id="网桥"><a class="markdownIt-Anchor" href="#网桥"></a> 网桥</h3><ul><li>采用称为<code>网桥(bridge)</code>的设备来把多个局域网联结起来组成更大的局域网</li><li>网桥根据<code>MAC帧的目的地址</code>对帧进行<code>转发和过滤</code></li></ul><p><img src="https://s2.loli.net/2022/01/05/4wc8BkzKWneDtdR.png" alt="" /></p><ul><li>通过桥设备可以实现<code>异构协议之间的互联</code></li></ul><p><img src="https://s2.loli.net/2022/01/05/z4DfXmMPeKuTCVL.png" alt="" /></p><ul><li>以下为IEEE 802 帧格式</li></ul><p><img src="https://s2.loli.net/2022/01/05/AyMPJYItT3ERkG9.png" alt="" /></p><ul><li>下图展示具有四个 LAN 和两个网桥的配置</li></ul><p><img src="https://s2.loli.net/2022/01/05/R3tJOEVg8anPfNq.png" alt="" /></p><hr /><h3 id="spanning-tree-bridges生成树桥"><a class="markdownIt-Anchor" href="#spanning-tree-bridges生成树桥"></a> Spanning Tree Bridges（生成树桥）</h3><p><img src="https://s2.loli.net/2022/01/05/BWASYH5pCIfs7Ui.png" alt="" /></p><ul><li>用<code>STP生成树协议</code>来处理由于通过桥设备连接了若干局域网以后在局域网中出现回路导致局域网阻塞的问题</li></ul><p><img src="https://s2.loli.net/2022/01/05/nmzg2PiQkyYRH1o.png" alt="" /></p><ul><li>虚线为备用连接，利用<code>树的特征</code>来找到备用连接<ul><li>树的根节点到叶节点没有回路</li></ul></li></ul><hr /><h3 id="中继器集线器网桥交换机路由器和网关"><a class="markdownIt-Anchor" href="#中继器集线器网桥交换机路由器和网关"></a> 中继器／集线器／网桥／交换机／路由器和网关</h3><p><img src="https://s2.loli.net/2022/01/06/iCjLyTwMHoeXJfD.png" alt="" /></p><p><img src="https://s2.loli.net/2022/01/05/zRTCoiNh4PGa7ZE.png" alt="" /></p><hr /><h3 id="虚拟局域网virtual-lans"><a class="markdownIt-Anchor" href="#虚拟局域网virtual-lans"></a> 虚拟局域网(Virtual LANs)</h3><ul><li>主要考虑局域网安全性，在物理上对局域网进行<code>逻辑上的划分</code>，即物理上在一个局域网里，但不互通，如同在两个局域网中</li></ul><p><img src="https://s2.loli.net/2022/01/05/IowUaBC3dGqVeAF.png" alt="" /></p><ul><li>虚拟局域网的实例</li></ul><p><img src="https://s2.loli.net/2022/01/05/VNZ3RfCqHQEM1c5.png" alt="" /></p><ul><li>利用 IEEE 802.1Q 进行划分</li></ul><hr /><h4 id="ieee-8021q-协议"><a class="markdownIt-Anchor" href="#ieee-8021q-协议"></a> IEEE 802.1Q 协议</h4><ul><li>在802.3协议基础上增加了VLAN Tag</li></ul><p><img src="https://s2.loli.net/2022/01/06/DUowgBfNZE4ryKX.png" alt="" /></p><ul><li>User Priority：定义用户优先级，包括8个优先级别。</li><li>CFI：以太网交换机中，规范格式指示器总被设置为0。</li><li>VID：VLAN ID 是对 VLAN 的识别字段，<code>该字段为12位</code>。VID=0 用于识别帧优先级。 4095（FFF）作为预留值，所以 VLAN配置的最大可能值为4094。<ul><li>识别 VLAN：<ul><li>端口，一个端口上的所有机器都属于同一个VLAN</li><li>MAC地址</li><li>第 3 层协议或 IP 地址，检查帧的有效载荷字段</li></ul></li></ul></li><li>在进行帧的转发的过程中，只在VLAN Tag标识的VLAN中进行转发，不同VLAN之间的节点无法通讯，从而保证局域网的安全性</li></ul><hr /><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p><img src="https://s2.loli.net/2022/01/06/jnTM3Ytsfmb9vlR.png" alt="" /></p><hr /><h1 id="网络层"><a class="markdownIt-Anchor" href="#网络层"></a> 网络层</h1><h2 id="网络层的设计问题"><a class="markdownIt-Anchor" href="#网络层的设计问题"></a> 网络层的设计问题</h2><h3 id="存储转发数据包交换"><a class="markdownIt-Anchor" href="#存储转发数据包交换"></a> 存储转发数据包交换</h3><p><img src="https://s2.loli.net/2022/01/06/UMacsE38BvYeVto.png" alt="" /></p><ul><li>如果一台主机要发送一个数据包：<ol><li>它就将数据包传输给最近的路由器，路由器可能在它自己的 LAN 上，也可能在一条通向 ISP 的点到点链路上</li><li>在该数据包到达路由器，并且路由器的链路层<code>完成了对它校验和的验证</code>之后，它先被存储在路由器上</li><li>然后沿着路径被转发到下一个路由器，直至到达目标主机，这里就是数据包的目的地。</li></ol></li></ul><hr /><h3 id="提供给传输层的服务"><a class="markdownIt-Anchor" href="#提供给传输层的服务"></a> 提供给传输层的服务</h3><ul><li><p>在设计网络层服务时，一定要牢记下面这些目标</p><ol><li>向上提供的服务应该独立于路由器技术。</li><li>应该向传输层<code>屏蔽</code>路由器的数量、类型和拓扑关系。</li><li>传输层可用的网络地址应该有一个统一编址方案，甚至可以跨越 LAN 和 WAN</li></ol></li><li><p>网络层提供给传输层的服务有面向连接和面向无连接之分。</p><ul><li>网络层服务方式的不同主要取决于通信子网的内部结构。</li><li>面向无连接的服务在通信子网内通常以<code>数据报</code>（Datagram）方式实现。</li><li>面向连接的服务则通常采用<code>虚电路</code>（Virtual Circuit，简称VC）方式实现。</li></ul></li></ul><hr /><h3 id="无连接服务的实现"><a class="markdownIt-Anchor" href="#无连接服务的实现"></a> 无连接服务的实现</h3><p><img src="https://s2.loli.net/2022/01/06/sh78qdCizjyrADV.png" alt="" /></p><ul><li>传输层代码运行在 H1 上，通常在操作系统内部。它在消息的前面加上一个传输头，然后将结果交给网络层</li><li>每一台路由器都有一个<code>内部表</code>，它指明了针对每一个可能的目标地址应该将数据包送到哪里去。<ul><li>每个表项由两部分数据组成：<code>目标地址和通往目标地址所使用的出境线路</code>。</li></ul></li><li>每个数据包携带一个目标 IP 地址，路由器使用该地址来单独转发每一个数据包。<ul><li>不同的包可能有不同的路线</li></ul></li></ul><hr /><h3 id="面向连接服务的实现"><a class="markdownIt-Anchor" href="#面向连接服务的实现"></a> 面向连接服务的实现</h3><ul><li>使用<code>内部标签</code>沿着虚拟电路转发数据包<ul><li>需要提前建立虚拟电路（VC）</li></ul></li><li>隐藏在虚电路背后的思想是<code>避免为每个要发送的数据包选择一条新路径</code><ul><li>当建立一个连接时，从源机器到目标机器之间的一条路径就被当作这个连接的一部分确定了下来，并且保存在这些中间路由器的表中</li><li>所有需要在这个连接上通过的流量，都使用这条路径</li><li>当连接被释放之后，虚电路也随之消失。</li><li>在面向连接的服务中，<code>每个数据包包含一个标识符，指明了它属于哪一条虚电路</code>。</li></ul></li></ul><p><img src="https://s2.loli.net/2022/01/06/qXFiAu9jGL8rE61.png" alt="" /></p><hr /><h3 id="虚电路与数据报网络的比较"><a class="markdownIt-Anchor" href="#虚电路与数据报网络的比较"></a> 虚电路与数据报网络的比较</h3><p><img src="https://s2.loli.net/2022/01/06/IrF8o7mxaCHgEOZ.png" alt="" /></p><ul><li>在网络内部，数据报和虚电路网络之间存在着几个方面的权衡<ul><li>建立时间和地址解析时间:<ul><li>使用虚电路需要一个建立阶段，这个阶段既花费时间也消耗资源。然而，一旦付出了这个代价，处理一个数据包的方法却非常简单：<code>路由器只要使用电路号作为索引，在表中找到该数据包的去向即可</code></li><li>在数据报网络中，不需要建立电路，但路由器需要执行一个更为复杂的查找过程以便找到目标表项。</li></ul></li><li>数据报网络所用的目标地址比虚电路网络所用的电路号要长，因为数据报网络的目标地址具备全局意义。<ul><li>如果数据包相当短，在每个数据包中都包括完整的目标地址可能意味着大量的协议开销，因而造成带宽资源的浪费。</li></ul></li><li>另一个问题是路由器内存所要求的表空间的数量。<ul><li>在数据报子网中，针对每一个可能的目标地址都要求有一个表项</li><li>在虚电路网络中，只要为每一条虚电路提供一个表项即可</li></ul></li></ul></li></ul><hr /><h2 id="路由算法"><a class="markdownIt-Anchor" href="#路由算法"></a> 路由算法</h2><ul><li>所谓<code>路由</code>是指为到达目的网络所进行的最佳路径选择，路由是网络层最重要的功能。</li><li>在网络层完成路由功能的设备被称为<code>路由器</code>，路由器是专门设计用于实现网络层功能的网络互连设备<ul><li>除了路由器外，某些交换机里面也可集成带网络层功能的模块即路由模块，带路由模块的交换机又称<code>三层交换机</code>。</li></ul></li><li>另外，在某些操作系统软件中也可以实现网络层的路由功能，在操作系统中所实现的路由功能又称为软件路由</li></ul><hr /><h3 id="路由协议"><a class="markdownIt-Anchor" href="#路由协议"></a> 路由协议</h3><ul><li><p>路由器将所有有关如何到达目的网络的最佳路径信息以数据库表的形式存储起来，这种专门用于存放路由信息的表被称为<code>路由表</code>。路由表的不同表项可给出到达不同目的网络所需要历经的路由器接口信息。</p></li><li><p>路由器的某一个接口在收到帧后，如何路由：</p><ul><li>首先进行帧的拆封以便从中分离出相应的IP分组</li><li>然后利用子网掩码<code>求“与”</code>的方法从IP分组中提取出目标网络号</li><li>将目标网络号与路由表进行比对看能否找到一种匹配，即确定是否存在一条到达目标网络的最佳路径信息。</li><li>若存在匹配，则将IP分组重新封装成端口所期望的帧格式并将其从路由器相应的端口转发出去；<code>若不存在匹配，则将相应的IP分组丢弃。</code></li></ul></li><li><p>查找路由表以获得最佳路径信息的过程被称为路由器的<code>“路由”功能</code>，而将从接收端口进来的数据在输出端口重新转发出去的功能称为路由器的<code>“交换”功能</code>。<code>“路由”与“交换”是路由器的两大基本功能。</code></p></li><li><p>在网络层用于动态生成路由表信息的协议被称为<code>路由协议</code>，路由协议使得网络中的路由设备能够相互交换网络状态信息，从而在内部生成关于网络连通性的映像（Map）并由此计算出到达不同目的网络的最佳路径或确定相应的转发端口。</p></li><li><p>路由协议的核心是<code>路由选择算法</code>。不同的路由选择算法通常会采用不同的评价因子及权重来进行最佳路径的计算，常见的评价因子包括<code>带宽、可靠性、延迟、负载、跳数和费用</code>等。</p></li></ul><hr /><h3 id="路由算法-2"><a class="markdownIt-Anchor" href="#路由算法-2"></a> 路由算法</h3><ul><li><p>好的路由算法需要：</p><ul><li>Correctness(正确性)</li><li>Simplicity(简单性)</li><li>Robustness(健壮性)</li><li>Stability(稳定性)</li><li>Fairness(公平性)</li><li>Optimality(最优性)</li></ul></li><li><p>在路由器中维持一个能正确反映网络拓扑与状态信息的路由表对于路由器完成路由功能是至关重要的。通常有两种方式可用于路由表信息的生成和维护，即分别是<code>静态路由和动态路由</code></p><ul><li><code>静态路由</code>是指网络管理员根据其所掌握的网络连通信息<code>以手工配置方式创建的路由表表项</code>。<ul><li>这种方式要求网络管理员对网络的拓扑结构和网络状态有着非常清晰的了解，而且当网络连通状态发生变化时，静态路由的更新也要通过手工方式完成。</li></ul></li><li>能<code>自动适应</code>网络状态变化而对路由表信息进行动态更新和维护的路由生成方式，这就是<code>动态路由</code>。</li></ul></li></ul><p><img src="https://s2.loli.net/2022/01/06/otZPaf4yGWDdc1M.png" alt="" /></p><hr /><h3 id="优化原则"><a class="markdownIt-Anchor" href="#优化原则"></a> 优化原则</h3><p><img src="https://s2.loli.net/2022/01/06/ZPNrCnsFRjhY7tO.png" alt="" /></p><ul><li><code>最优路径</code>的一般陈述如下：如果路由器 J 在从路由器 I 到路由器 K 的最优路径上，那么从 J 到 K 的最优路径也必定遵循同样的路由。</li><li>作为最优化原则的一个直接结果，从所有的源到一个指定目标的<code>最优路径的集合</code>构成了一棵以目标节点为根的树。这样的树称为<code>汇集树 (sink tree)</code></li></ul><hr /><h3 id="最短路径算法shortest-path-routing"><a class="markdownIt-Anchor" href="#最短路径算法shortest-path-routing"></a> 最短路径算法(Shortest Path Routing)</h3><ul><li>基本想法是构造一张网络图<code>（无向图）</code>，图中的每个节点代表一个路由器，每条边代表一条通信线路或者链路。<ul><li>为了选择一对给定路由器之间的路由，算法只需要在图中找出它们之间的最短路径。</li></ul></li><li>最短路径（ shortest path ）概念：<ul><li>一种测量路径长度的方法是跳数</li><li>另一种度量是以千米为单位的地理距离</li><li>除跳数和物理距离之外，还可以用许多其他度量来标示路径的长短。例如，图中每条边用一个标准测试包的平均延迟来标记</li><li>一般情况下，边上面的标记可以作为距离、带宽、平均流量、通信成本、平均延迟等其他因素的一个函数</li></ul></li><li>给定一个图，计算两个节点之间最短路径的算法己经有几个：Dijkstra 算法<ul><li>每一个节点都标出了（在圆括号内〉从源节点沿着己知的最佳路径到达本节点的距离。</li><li>初始时，所有的路径都不知道，因此所有节点都被标记为<code>无限远</code>。</li><li>初始时，所有的标记都是<code>暂时的</code>。当发现一个标记代表了从源节点到该节点的<code>最短可能路径</code>，该标记就变成<code>永久</code>，以后不再改变。</li></ul></li></ul><p><img src="https://s2.loli.net/2022/01/06/wQjPn6ZGmhV7I9z.png" alt="" /></p><hr /><h3 id="泛洪算法flooding"><a class="markdownIt-Anchor" href="#泛洪算法flooding"></a> 泛洪算法(Flooding)</h3><ul><li>在实现路由算法时，每个路由器必须<code>根据本地知识而不是网络的全貌</code>做决策。一个简单的本地技术是泛洪（ flooding ）<ul><li>这种技术<code>将每一个入境数据包发送到除了该数据包到达的那条线路以外的每条出境线路</code>。</li></ul></li><li>泛洪法会产生大量的重复数据包，除非采取某些措施来抑制泛洪过程，否则将会产生无限多的数据包：<ul><li>其中一项措施是在每个数据包的头中设置一个跳计数器，每经过一跳该计数器减一，当计数器到达<code>0 时就丢弃该数据包</code>。<ul><li>理想情况下，<code>跳计数器的初始值应该等于从源端到接收方之间路径的长度</code>。如果发送方不知道该路径有多长，它可以将计数器的初始值设置为最坏情形下的长度，即网络的直径</li><li>带有跳计数器的泛洪能够产生随着跳数增大而指数增长的重复数据包</li></ul></li><li>抑制数据包泛滥的一种更好技术是<code>让路由器跟踪己经泛洪过的数据包</code>，从而避免第二次发送它们。<ul><li>实现这个目标的一种方式是让每个源路由器在接收来自主机的数据包时填上一个序号，然后每个路由器为每个源路由器准备一张表，记录己经观察到的来自源路由器的序号。如果入境数据包在这张表中，它就不能再被泛洪到其他路由器。</li></ul></li></ul></li><li>对于发送大多数数据包来说，泛洪算法是不切实际的，但它确实有一些重要的用途：<ul><li>它确保数据包能被传送到网络中的每个节点，对于广播信息来说，这是一种有效的广播手段。</li><li>泛洪途径的鲁棒性非常好。即使大量路由器被炸成碎片（例如，位于战争地区的一个军事网络），泛洪也能找到一条路径（如果存在），使得数据包到达目的地。</li><li>泛洪还可用作其他路由算法进行比较的性能度量。</li></ul></li></ul><hr /><h3 id="距离矢量算法distance-vector-routing"><a class="markdownIt-Anchor" href="#距离矢量算法distance-vector-routing"></a> 距离矢量算法(Distance Vector Routing)</h3><h4 id="具体算法"><a class="markdownIt-Anchor" href="#具体算法"></a> 具体算法</h4><ul><li>距离矢量路由算法是这样工作的:<ul><li>每个路由器维护一张表（即一个矢量），表中列出了当前己知的到每个目标的最佳距离，以及所使用的链路。</li><li>这些表通过邻居之间相互交换信息而不断被更新，最终每个路由器都了解到达每个目的地的最佳链路。</li></ul></li></ul><p><img src="https://s2.loli.net/2022/01/06/w6BoWUi38JKZljg.png" alt="" /></p><ul><li>在距离矢量路由算法中，每个路由器维护一张路由表，它以网络每个路由器为索引，并且每个路由器对应一个表项。<ul><li>该表项包含两部分：到达该目标路由器的首选出境线路，以及到达该目标路由器的距离估计值</li><li>如果度量值为传播延迟，则路由器很容易测量出链路的传播延迟。它只要直接发送<code>一个特殊的 ECHO 数据包</code>给邻居，邻居收到后盖上时间戳，尽可能快地发回来即可。</li></ul></li><li>每个路由器向与它<code>相邻的站点</code>发送一个包含它到所有其他路由器的距离的向量（最短路径或最小代价）</li><li>路由器根据邻居发送的距离—矢量的动态信息启动算法，更新路由表</li><li>距离矢量路由的计算举例:<br /><img src="https://s2.loli.net/2022/01/06/p4alwOdeSCxBfW9.png" alt="" /></li><li>距离矢量路由建立路由表的初始过程:<br /><img src="https://s2.loli.net/2022/01/09/olscdy6UIfZ7EVH.png" alt="" /></li><li>距离矢量路由网络发现过程:<br /><img src="https://s2.loli.net/2022/01/09/7DdFxbjoqgWJraK.png" alt="" /><ul><li>如果网络中的最长路径为N，则算法经过N次迭代计算后收敛。即第N步之后，网上的所有路由器都获得到达信宿40.0.0.0的路由信息。</li></ul></li></ul><hr /><h4 id="距离矢量路由的收敛性问题"><a class="markdownIt-Anchor" href="#距离矢量路由的收敛性问题"></a> 距离矢量路由的收敛性问题</h4><ul><li>问题:<ul><li>逐站传递更新信息，算法的收敛速度慢<ul><li>整个网络最佳路径的寻找过程称为收敛 (convergence )</li><li>对于好消息的反应非常迅速，而对于坏消息的反应异常迟缓</li></ul></li><li>有可能出现各站路由信息不一致</li><li>有可能传播错误的路由信息</li></ul></li><li>后果<ul><li>在站点间构成更新路由的路径环(Routing Loops)</li><li>计数至无穷大(Count to Infinity)<br /><img src="https://s2.loli.net/2022/01/06/MSQbunK2ypxzr3E.png" alt="" /></li><li>解决办法：定义路径代价的<code>最大值</code>（Maximum）</li></ul></li><li>提高收敛速度：<ul><li>水平分割（Split Horizon）</li><li>毒性逆转（Poison Reverse）</li><li>保持计时（Hold-Down Timers）</li><li>触发更新（Triggered Updates）</li></ul></li></ul><hr /><h4 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h4><ul><li>采用最短路径准则，计算D信宿(距离，下站)；</li><li>每个站点只知道自己和邻居的局部信息，在自己的刷新周期到来时，根据邻居的路由变化重新启动算法；</li><li>算法的收敛速度慢（特别是对网络崩溃）造成全网信息的不一致，导致产生路径环，使计数至无穷大；</li><li>当路径环产生时，定义距离的最大值可防止算法进入死循环，解决计数至无穷大问题</li></ul><hr /><h3 id="链路状态路由link-state-routing"><a class="markdownIt-Anchor" href="#链路状态路由link-state-routing"></a> 链路状态路由(Link State Routing)</h3><ul><li>当网络拓扑结构发生变化后距离矢量路由算法需要太长时间才能收敛到稳定状态（由于无穷计数问题）。因此，距离矢量路由算法被一个全新的算法所替代，该算法称为<code>链路状态路由算法（ link state routing ）</code></li><li>今天，链路状态路由算法的变种算法－－一IS-IS 或者 OSPF 己经成为大型网络或 Internet 应用最为<code>广泛的路由算法</code>。</li><li>每一个路由器必须完成以下的事情，算法才能正常工作：<ol><li>发现它的邻居节点，并了解其网络地址。</li><li>设置到每个邻居节点的距离或者成本度量值。</li><li>构造一个包含所有刚刚获知的链路信息包。</li><li>将这个包发送给所有其他的路由器，并接收来自所有其他路由器的信息包。</li><li>计算出到每个其他路由器的最短路径。</li><li>实际上，算法<code>将完整的拓扑结构分发给了每一个路由器</code>。然后每个路由器运行 Dijkstra算法就可以找出从本地到每一个其他路由器的最短路径。</li></ol></li></ul><hr /><ul><li>发现邻居:<ul><li>当一个路由器启动时，它的第一个任务是找出哪些路由器是它的邻居。<ul><li>为了实现这个目标，它只需在每一条点到点线路上发送一个<code>特殊的 HELLO 数据包</code>。</li><li>线路另一端的路由器应该返回一个应答说明自己是谁。<br /><img src="https://s2.loli.net/2022/01/06/7yKJTDMckjhNpx9.png" alt="" /><ul><li>模拟局域网的一个更好方法来是把它看作一个节点</li></ul></li></ul></li></ul></li></ul><hr /><ul><li>设置链路成本<ul><li>如果网络在地理上分散，链路的延迟可以作为成本的组成部分</li><li>确定这种延迟的最直接方法是通过线路给另一边发送一个<code>特殊的ECHO 数据包</code>，要求对方立即发回。</li></ul></li></ul><hr /><ul><li>构造链路状态包(Building Link State Packets)<ul><li>一旦收集到了所需要的交换信息，每个路由器的下一步工作是构建一个包含所有这些信息的数据包。<ul><li>该数据包的内容首先是发送方的标识符，接着是一个序号（ Seq ）和年龄，以及一个邻居列表</li><li>对于每个邻居，同时要给出到这个邻居的延迟。<br /><img src="https://s2.loli.net/2022/01/06/uwhZOAEdCbWJTyG.png" alt="" /></li></ul></li></ul></li></ul><hr /><ul><li>分发链路状态包<ul><li><code>序号随着每一个新数据包发出而逐一递增</code>。路由器记录下它所看到的所有（源路由器、序号）对。当一个新的链路状态数据包到达时，路由器检查这个新来的数据包是否己经出现在上述观察到的列表中。<ul><li>如果这是一个新数据包，则把它转发到除入境线路之外的所有其他线路上。如果这是一个重复数据包，则将它丢弃。</li><li>如果一个路由器崩溃了，那么它将丢失所有的序号记录表。如果它再从 0 开始，那么，下一个数据包将被作为重复数据包而拒绝。</li></ul></li><li>为了解决序号重启或出错的问题，在每个数据包的序号之后包含一个<code>年龄（ age ）字段</code><ul><li>每秒钟将年龄减 1，<code>当年龄字段的值被减到 0 时，来自路由器的该信息将被丢弃</code>。<br /><img src="https://s2.loli.net/2022/01/06/Sg3pzhCb2uHoTsD.png" alt="" /></li></ul></li><li>这里的每一行对应于一个刚刚到达的，但是还没有完全处理完毕的链路状态数据包。</li><li>发送标志表明该数据包必须在所指示的线路上发送。确认标志表明它必须在这条线路上得到确认。</li></ul></li></ul><hr /><ul><li>计算新路由<ul><li>一旦路由器己经积累了全部的链路状态数据包之后，它就可以构造出完整的网络图</li><li>可以在路由器本地运行 Dijkstra 算法，以便构建出从本地出发到所有可能目标的最短路径</li></ul></li></ul><hr /><ul><li>距离矢量路由和链路状态路由的比较：</li></ul><table><thead><tr><th style="text-align:center">距离矢量路由</th><th style="text-align:center">链路状态路由</th></tr></thead><tbody><tr><td style="text-align:center">通过与邻居的信息交换获得网络拓扑知识</td><td style="text-align:center">全网获得共同的全局性网络拓扑知识</td></tr><tr><td style="text-align:center">路由计算是增加路由器之间的站点数（hops）</td><td style="text-align:center">计算到达其他站点的最短路径</td></tr><tr><td style="text-align:center">定期刷新路由：收敛慢</td><td style="text-align:center">触发刷新：收敛快</td></tr><tr><td style="text-align:center">向相邻站点传送路由表的副本</td><td style="text-align:center">向其他站点发送链路状态的动态变化</td></tr></tbody></table><hr /><h3 id="层次路由hierarchical-routing"><a class="markdownIt-Anchor" href="#层次路由hierarchical-routing"></a> 层次路由(Hierarchical Routing)</h3><ul><li>在采用了分层路由之后，<code>路由器被划分成区域（region）</code>。每个路由器知道如何将数据包路由到自己所在区域内的目标地址，但是对于其他区域的内部结构毫不知情。<br /><img src="https://s2.loli.net/2022/01/06/Ag18bpsaLne4KMx.png" alt="" /><ul><li>如果采用分级路由，则路由表如图 5-14 © 所示，所有针对本区域内的路由器表项都跟原先一样</li><li>但是，所有<code>到其他区域的路由都被压缩到了单个路由器</code>中．</li></ul></li><li>优点：节省路由器空间</li><li>缺点：可能增加路径长度</li></ul><hr /><h3 id="广播路由broadcast-routing"><a class="markdownIt-Anchor" href="#广播路由broadcast-routing"></a> 广播路由(Broadcast Routing)</h3><ul><li><code>同时给全部目标地址发送一个数据包称为广播（broadcasting）</code></li><li>为了实现广播，人们己经提出了各种各样的方法：<ul><li>让源机器简单地给每一个目标单独发送一个数据包<ul><li>非常浪费带宽，并要具有所有路由器的完整列表</li></ul></li><li>泛洪路由<ul><li>比较浪费带宽</li></ul></li><li><code>多目标路由（multidestination routing）</code>，每个数据包包含一组目标地址，或者一个位图，由该位图指定所期望到达的目标。<ul><li>必须知道所有目标路由器地址</li></ul></li><li>逆向路径转发（reverse path forwarding）</li></ul></li></ul><hr /><h3 id="逆向路径转发reverse-path-forwarding"><a class="markdownIt-Anchor" href="#逆向路径转发reverse-path-forwarding"></a> 逆向路径转发(reverse path forwarding)</h3><ul><li>当一个广播分组到达一个路由器的时候，该路由器对它进行检查，看它到来的那条线路是否是<code>通常用来给广播源发送分组的那条线路</code></li><li>如果是，则很可能该分组是沿着最佳路径被转发过来的，因而是到达当前路由器的第一个副本，那么路由器将该分组转发到除了到来线路之外的所有其他线路上。</li><li>否则，该分组被当作一个可能的重复分组而丢弃。</li></ul><p><img src="https://s2.loli.net/2022/01/06/M7JObcuhz8rWKwE.png" alt="" /></p><hr /><h2 id="拥塞控制算法congestion-control-algorithms"><a class="markdownIt-Anchor" href="#拥塞控制算法congestion-control-algorithms"></a> 拥塞控制算法(Congestion Control Algorithms)</h2><h3 id="拥塞控制的一般原则"><a class="markdownIt-Anchor" href="#拥塞控制的一般原则"></a> 拥塞控制的一般原则</h3><ul><li><code>拥塞 (congestion )</code>：（一部分）网络中存在太多的数据包导致数据包被延迟延迟和丢失，从而降低了传输性能</li><li>流量控制和拥塞控制<ul><li>拥塞控制：确保网络能够承载所有到达的流量</li><li>流量控制：确保一个快速的发送方不会持续地以超过接收方接收能力的速率传输数据。</li></ul></li></ul><p><img src="https://s2.loli.net/2022/01/06/W9svXgASr21KFql.png" alt="" /></p><ul><li>随着负载接近承载能力，偶尔突发的流量填满了路由器内部的缓冲区，因而某些数据包会被丢失。</li><li><code>拥塞崩溃( congestion collapse )</code>：随着注入负载的增加到超出网络的容量，网络性能骤降</li><li>开环和闭环<ul><li>开环通过良好的设计解决问题，不考虑网络的当前状态做出决策。</li><li>闭环基于反馈环。<ul><li>监控系统。<ul><li>检测何时何地发生拥塞。</li></ul></li><li>将信息传递到可以采取行动的地方。</li><li>调整系统操作以纠正问题。</li></ul></li></ul></li><li>解决方案：<code>增加资源</code>（开环系统）或<code>减少负载</code>（闭环系统）</li><li>拥塞预防策略：<br /><img src="https://s2.loli.net/2022/01/09/hDwjvQSZEoFIb96.png" alt="" /></li></ul><hr /><h3 id="拥塞控制的途径"><a class="markdownIt-Anchor" href="#拥塞控制的途径"></a> 拥塞控制的途径</h3><p><img src="https://s2.loli.net/2022/01/06/aJpcy5uswnIKzoS.png" alt="" /></p><hr /><h4 id="虚电路子网中的拥塞控制"><a class="markdownIt-Anchor" href="#虚电路子网中的拥塞控制"></a> 虚电路子网中的拥塞控制</h4><ul><li>在一个虚电路网络中，如果新的连接将导致网络变得拥挤不堪，那么就应该拒绝这种新连接的建立。这种控制称为<code>准入控制(admission control)</code></li><li>准入控制还可以和流量感知路由相结合，在虚电路建立过程中，考虑<code>绕开流量热点区域</code>的路由</li></ul><p><img src="https://s2.loli.net/2022/01/06/tAD5oWMlHRI6ErF.png" alt="" /></p><hr /><h4 id="数据报子网中的拥塞控制"><a class="markdownIt-Anchor" href="#数据报子网中的拥塞控制"></a> 数据报子网中的拥塞控制</h4><ul><li>首先，路由器必须确定何时快要接近拥塞，最好在拥塞发生之前能确定。为此，每个路由器可连续监测它正在使用的资源。<ul><li>三种可能的资源分别是：<ul><li>输出线路的利用率</li><li>在路由器内缓冲的排队数据包</li><li>由于没有足够的缓冲而丢失的数据包数量</li></ul></li></ul></li><li>监控其输出线的利用率：<ul><li>U，该线路的最近利用率 或 排队延迟估计</li><li>f，瞬时线路利用率，（0 或 1） 或 瞬时队列长度的样值</li><li>a,（常数）决定路由器忘记最近历史的速度，<code>这就是所谓的指数加权移动平均</code></li><li>$ U_{new} = a * U_{old} + (1-a) * f $</li></ul></li><li>当 U 移动到阈值以上时，路由器就要注意开始拥塞了（<code>警告状态</code>）</li></ul><hr /><blockquote><p>路由器必须及时把反馈信息传递给造成拥塞的发送方。拥塞是网络的一种体验，但缓解拥塞则需要使用网络的发送方采取行动。为了传递反馈信息，路由器必须标识适当的发送方</p></blockquote><ul><li><strong>抑制包</strong><ul><li>通知拥塞发送方的最直接方式是直接告诉发送方。</li><li>在这种方法中，路由器选择一个被拥塞的数据包，给该数据包的源主机返回一个<code>抑制包 (choke packet)</code></li><li>同时，在原来的拥塞数据包上添加一个<code>标记</code>（设置头部中的一位），因而它在前行的路径上不会产生更多的抑制包。</li><li>除此以外，数据包的转发过程如同平常一样。</li><li>当源主机收到了抑制包，按照要求它必须减少发送给指定目标的流量</li><li>很可能多个抑制包被发送到了一个给定的主机和目的地。主机应该<code>忽略掉在固定时间间隔</code>内到达的这些额外抑制包，直至其减缓流量的行为产生了效果。</li><li>超过这个固定的时间间隔，从路由器进一步反馈来的抑制包则指出网络仍然处于拥塞状态。</li></ul></li><li><strong>显式拥塞通知</strong><ul><li>除了生成额外的包发出拥塞警告外，路由器可以在<code>它转发的任何数据包上打上标记</code>（设置数据包头的某一个标志位）发出信号，表明它正在经历着拥塞。</li><li>网络传递数据包时，接收方可以注意到有个拥塞己经发生，<code>在它发送应答包时顺便告知发送方</code>。</li><li>然后发送方降低传输速率。<br /><img src="https://s2.loli.net/2022/01/06/8Lx6BcvmSj2uU5k.png" alt="" /></li></ul></li><li><strong>逐跳后压</strong><ul><li>当网络速度很高或者距离很远时，由于传播延迟的缘故，拥塞信号发出后到它产生作用这期间又有许多新的数据包己经被注入到网络。</li><li>办法是让抑制包在沿途的每一跳都发挥作用<br /><img src="https://s2.loli.net/2022/01/06/7K8utUhYWafTNIH.png" alt="" /></li><li>这种逐跳方案的实际效果是拥塞点上的拥塞现象很快得到了缓解，但是其代价是上游路径需要消耗更多的缓冲区空间。</li></ul></li></ul><hr /><h4 id="负载脱离load-shedding"><a class="markdownIt-Anchor" href="#负载脱离load-shedding"></a> 负载脱离(Load Shedding)</h4><ul><li>负载脱落 (load shedding) 是指当路由器因为来不及处理数据包而面临被这些数据包淹没的危险时，就<code>将它们丢弃</code>。</li><li>关键的问题是选择丢弃哪个数据包：<ul><li>首选的方案可能取决于使用<code>网络的应用程序类型</code>。<ul><li>对于文件传输，旧的数据包价值要高于新的数据包</li><li>对于实时媒体流，新的数据包价值超过老的数据包</li></ul></li><li>随即脱落</li><li>某些数据包比其他数据包更重要，为数据包设置<code>优先级</code>，按优先级高低脱落</li><li>允许主机超出限制，但所有<code>超出的流量都被标记为低优先级</code></li></ul></li></ul><hr /><h2 id="服务质量"><a class="markdownIt-Anchor" href="#服务质量"></a> 服务质量</h2><p><img src="https://s2.loli.net/2022/01/06/OJHPWYhzoXkG59g.png" alt="" /></p><hr /><h2 id="网络互联"><a class="markdownIt-Anchor" href="#网络互联"></a> 网络互联</h2><h3 id="互联"><a class="markdownIt-Anchor" href="#互联"></a> 互联</h3><ul><li>网络的不同可体现在不同方面。比如不同的调制解调技术或帧格式这样的差异属于物理层和数据链路层内部<br /><img src="https://s2.loli.net/2022/01/09/Y2bVB7QZEu84GpO.png" alt="" /></li><li>互连网络的基本概念<ul><li>互连网络是指将分布在不同地理位置的网络、设备连接起来，以构成更大规模的网络，最大程度地实现网络资源的共享。<ul><li>网络连接</li><li>网络互连</li><li>网络互通</li></ul></li></ul></li><li>网络互连的类型<ul><li>网络互连的类型分以下几种：<ul><li>局域网—局域网互连<ul><li>同构网互连：具有相同协议的局域网互连</li><li>异构网互连：不同协议的局域网互连</li></ul></li><li>局域网—广域网互连</li><li>广域网—广域网互连</li></ul></li><li>网络互连需解决的问题<ul><li>处理互连网络的帧、分组、报文和协议的差异问题</li></ul></li><li>网络互连从通信协议的角度来看可以分成四个层次：<br /><img src="https://s2.loli.net/2022/01/09/i36PmuxYvfEWT8D.png" alt="" /></li></ul></li></ul><hr /><ul><li><p>物理层的互连</p><ul><li>在不同的<code>电缆段之间复制位信号</code>是物理层互连的基本要求。</li><li>物理层的连接设备主要是<code>中继器</code>。中继器是最低层的物理设备，用于在局域网中<code>连接几个网段</code>，只起简单的信号放大作用，用于延伸局域网的长度。</li><li>严格地说，中继器是网段连接设备而不是网络互连设备。<br /><img src="https://s2.loli.net/2022/01/06/bJtd9CNzIcAHwmx.png" alt="" /></li></ul></li><li><p>数据链路层互连</p><ul><li>数据链路层互连要解决的问题是在网络之间存储转发数据帧。</li><li>互连的主要设备是交换机。<ul><li>交换机在网络互连中起到数据接收、地址过滤与数据转发的作用，它用来实现多个网络系统之间的数据交换。</li><li>用交换机实现数据链路层互连时，允许互连网络的数据链路层与物理层协议是相同的，也可以是不同的。<br /><img src="https://s2.loli.net/2022/01/06/Vel3sf5vGZDFmRw.png" alt="" /></li></ul></li></ul></li><li><p>网络层互连</p><ul><li>网络层互连要解决的问题是在<code>不同的网络之间存储转发分组</code></li><li>互连的主要设备是路由器</li><li>网络层互连包括<code>路由选择、拥塞控制、差错处理与分段技术</code>等<ul><li>如果网络层协议相同，则互连主要是解决路由选择问题</li><li>如果网络层协议不同，则需使用多协议路由器</li></ul></li><li>用路由器实现网络层互连时，允许互连网络的网络层及以下各层协议是相同的，也可以是不同的<br /><img src="https://s2.loli.net/2022/01/06/cQNBLprKuZM15xm.png" alt="" /></li></ul></li><li><p>高层互连</p><ul><li>传输层及以上各层协议不同的网络之间的互连属于高层互连</li><li>实现高层互连的设备是网关</li><li>高层互连使用的网关很多是应用层网关，通常简称为<code>应用网关</code>。如果使用应用网关来实现两个网络高层互连，那么允许两个网络的应用层及以下各层网络协议是不同的</li><li>网关一般用于<code>不同类型、差别较大</code>的网络系统之间的互连。又可用于同一个物理网而在逻辑上不同的网络之间互连，还可用于不同大型主机之间和不同数据库之间的互连<br /><img src="https://s2.loli.net/2022/01/09/ztyS8ValE6bwxr2.png" alt="" /></li></ul></li></ul><hr /><ul><li>互联网如何连接<ul><li>第一，可以制造这样的设备，它能将每种网络的数据包翻译或转换成每个其他类别网络的数据包</li><li>第二，在不同网络的上面增加一个间接层， 并且构造一个公共层来解决这个问题<br /><img src="https://s2.loli.net/2022/01/06/LvA9zW4OGNcXpf5.png" alt="" /></li><li>在路由器上，数据包被从帧中提取出来，数据包中的网络地址被用来决定把它转发到哪里</li><li>而在交换机（或网桥）上，整个帧是根据其 MAC 地址传送的。交换机不必了解正在被交换的数据包所采用的网络层协议，同样路由器也不必了解交换机所采用的链路层协议。</li><li>路由器是在网络层运行的数据包交换机。 路由器比网桥更灵活<ul><li>在不同网络之间转换地址</li><li>对大数据包进行<code>分段</code>，以便跨网络传输的最大数据包长度很小</li><li>选择通过子网的适当路径</li><li>强制执行策略（例如，不要从该网络转发任何本地数据包）</li></ul></li><li>因为路由器比网桥做更多的工作，所以它们的运行速度通常比网桥慢。</li></ul></li></ul><hr /><h3 id="隧道"><a class="markdownIt-Anchor" href="#隧道"></a> 隧道</h3><ul><li><code>隧道技术</code>是一种通过使用互联网络的基础设施在网络之间传递数据的方式。<ul><li>使用隧道传递的数据可以是不同协议的数据包，<code>隧道协议将其它协议的数据包重新封装然后通过隧道发送。新的帧头提供路由信息</code>，以便通过互联网传递被封装的负载数据。<br /><img src="https://s2.loli.net/2022/01/06/6gQzZG3SLdKvMlY.png" alt="" /><br /><img src="https://s2.loli.net/2022/01/06/FovR4LdCrPubzVx.png" alt="" /></li></ul></li></ul><hr /><h3 id="数据包分段fragmentation"><a class="markdownIt-Anchor" href="#数据包分段fragmentation"></a> 数据包分段(Fragmentation)</h3><ul><li>如果源子网的<code>信息包太长，目的子网无法接受</code>，路由器就把它分成更小的包，TCP/IP协议中把这个过程叫“分段”</li></ul><p><img src="https://s2.loli.net/2022/01/06/9BzAdgsK4Ca5nc2.png" alt="" /></p><ul><li><p>一个完整的设计要求分段以可以重新构建原有数据流的方式编号。</p><ul><li>IP 采用的设计思想是：给每个段一个<code>数据包序号〈所有的数据包都携带〉</code>、一个数据包内的<code>绝对字节偏移量</code>和一个指明<code>是否到达数据包末尾的标志位</code><br /><img src="https://s2.loli.net/2022/01/06/haRtnNo8MEBy1Pi.png" alt="" /></li></ul></li><li><p>这样的设计有问题</p><ul><li>现在某些链路上运载的段的头或许是没必要的</li><li>还因为段的存在，因此开销可能比透明分段高。分段不利于性能，因为除了增加头开销，数据包的丢失概率也增加了</li><li>任何个段的丢失都将导致整个数据包的丢失</li><li>在网络中避免分段操作，这个过程称为路径 <code>MTU 发现(path MTU discovery)</code><br /><img src="https://s2.loli.net/2022/01/06/8MhQGwelZqxRr43.png" alt="" /><ul><li>每个 IP 数据包发出时在它的头设置一个比特，指示不允许对该数据包实施分段操作。</li><li>如果一个路由器接收的数据包太大，它就生成一个报错数据包并发送给源端，然后丢弃该数据包</li><li>路径 MTU 发现的优点是源端现在知道应该发送多长的数据包了。</li><li>路径 MTU 发现方法的缺点是有可能增加发送数据包的启动延迟。</li></ul></li></ul></li></ul><hr /><h2 id="internet-的网络层"><a class="markdownIt-Anchor" href="#internet-的网络层"></a> Internet 的网络层</h2><ul><li><p>Internet 的设计原则</p><ol><li>Make sure it works.（能够工作）</li><li>Keep it simple.（简单）</li><li>Make clear choices.（明确的选择）</li><li>Exploit modularity.（模块化）</li><li>Expect heterogeneity.（具备异构性）</li><li>Avoid static options and parameters.（灵活的选择和参数）</li><li>Look for a good design; it need not be perfect.（好的设计，而不是完美的）</li><li>Be strict when sending and tolerant when receiving.（发送操作要严格，接收操作要有容忍度）</li><li>Think about scalability.（伸缩性）</li><li>Consider performance and cost.（性能和代价）</li></ol></li><li><p>在网络层，可以把Internet 看作是一种相互关联的网络或自治域（自治系统）集合。没有真正的结构，但存在几个主要骨干网。这些都是由高带宽线路和快速路由器组成。<br /><img src="https://s2.loli.net/2022/01/06/KX738xHiIJQDZ5O.png" alt="" /></p></li></ul><hr /><h3 id="ipv4-协议"><a class="markdownIt-Anchor" href="#ipv4-协议"></a> IPv4 协议</h3><ul><li>每个 IP 数据报包含两部分，一个头和一个正文<ul><li>正文部分也称之为有效净荷</li><li>头由一个 20 字节的定长部分和一个可选的变长部分组成。</li></ul></li></ul><p><img src="https://s2.loli.net/2022/01/06/VFUfvomg1jQut9Z.png" alt="" /></p><ul><li>IP 数据报头的传输<code>从左到右并从上到下</code>， Version 字段的高序字节最先被传送出去</li><li>版本 (Version) 字段记录了数据报属于协议哪个版本（IPv4版本对应的值是 0100）</li><li>IHL 字段指明了头到底有多长（<code>以 32 位字长度为单位</code>）。 IHL 的最小值为 5，这表明头没有可选项。该4位字段的最大值为 15 ，把头的长度限制为最大 60 字节，因此选项（ Options ）字段最多为 40 字节。</li><li>区分服务 (Differentiated services) 字段用来区分不同的服务种类。<code>可靠性和速度</code>的各种组合都是可能的选择。占8比特，包括一个3比特长度的优先级，3个标志位D、T、R，2位保留未用。<ul><li>过程字段(Routine) ：3位，设置了数据包的重要性，取值越大数据越重要，取值范围为：0（正常）~ 7（网络控制）</li><li>延迟字段(Delay) ：1位，取值：0（正常）、1（期待低的延迟）</li><li>流量字段(Throughput) ：1位，取值：0（正常）、1（期待高的流量）</li><li>可靠性字段(Reliability) ：1位，取值：0（正常）、1（期待高的可靠性）</li></ul></li><li>总长度 (Total length)字段包含了<code>该数据报中的所有内容</code>，即头和数据。</li><li>标识 (ldentification) 字段的用途是让目标主机确定一个新到达的分段属于哪一个数据报。<code>同一个数据报的所有段包含同样的标识值</code>。</li><li>DF 代表“不分段” ( Don’t Fragment )标志位。这是针对路由器的一条命令，它不允许路由器分割该数据报</li><li>MF 代表“更多的段” ( More Fragment )标志位。<code>除了最后一个段以外，其他所有的段都必须设置这一位。</code></li><li>分段偏移量 (Fragment offset )字段指明了该段在当前数据报中的位置。除了数据报的最后一个段以外，其他所有段的<code>长度必须是 8 字节的倍数</code>。<br /><img src="https://s2.loli.net/2022/01/06/sNEVyLeP9JHZTRM.png" alt="" /></li><li>生存期( Time to live )字段是一个用于限制数据包生存期的计数器。<code>在每一跳上该计数器必须被递减</code>，当它递减到 时，数据包就被丢弃</li><li>协议(Protocol) 字段指明了该将它交给哪个传输进程。指该分组所使用的网络协议类型，如ICMP、DNS等，占8位。各协议对应的值如下表所示。<br /><img src="https://s2.loli.net/2022/01/06/vZ6EDWla1zSHbOP.png" alt="" /></li><li>头校验和 (Header checksum) 字段仅验证头</li><li>源地址 (Source address) 字段和目标地址 (Destination address) 字段表示源网络接口和目标网络接口的 IP 地址</li><li>选项 (Options) 字段<ul><li>IP数据报选项字段是可选的，主要用于网络测试和调试。</li><li>选项的长度取决于选项的类型，并且每个选项的格式都不相同。</li><li>选项格式：代码（1个字节），长度（1个字节），数据部分。<br /><img src="https://s2.loli.net/2022/01/06/ONkHrwItcCbZud2.png" alt="" /></li></ul></li></ul><hr /><h3 id="ip-地址"><a class="markdownIt-Anchor" href="#ip-地址"></a> IP 地址</h3><ul><li>一个 IP 地址并不真正指向一台主机，而是指向一个网络接口，所以如果一台主机在两个网络上，它必须有两个 IP 地址。</li><li>IP 地址具有层次性。每个 32 位地址由高位的可变长网络和低位的主机两部分数据组成。<ul><li>同一网络上〈比如以太局域网〉的所有主机，其地址的网络值是相同的。</li></ul></li><li>IP 地址的书写方式是点分十进制表示法。按此格式，4 个字节中的每个写成十进制，取值范围从 0 到 255</li><li>前缀长度相当于网络部分中的二进制掩码。以这种格式书写时称为子网掩码( subnet mask )，它可以与一个 IP 地址进 AND 操作，以便提取出该 IP 地址的网络部分。<br /><img src="https://s2.loli.net/2022/01/06/zhstVvGiYxnwaCJ.png" alt="" /></li></ul><hr /><h4 id="分类的ip地址"><a class="markdownIt-Anchor" href="#分类的ip地址"></a> 分类的IP地址</h4><p><img src="https://s2.loli.net/2022/01/06/S7zl5OqtunjQ4pa.png" alt="" /></p><ul><li><p><strong>A类地址</strong></p><ul><li>A类地址用来支持<code>超大型网络</code>。A类IP地址仅使用第一个8位组标识地址的网络部分。其余的3个8位组用来标识地址的主机部分。用二进制数表示时，A类地址的第1位（最左边）总是0。</li><li>第1个8位组的最小值为00000000（十进制数为0），最大值为01111111（十进制数为127），但是<code>0和127两个数保留使用</code>，不能用做网络地址。</li><li>任何IP地址第1个8位组的取值范围在1到126之间时都是A类地址。</li><li>A类地址的网络掩码为：255.0.0.0</li><li>127是一个特殊的网络ID，又称本机网络，可用来检查TCP／IP协议工作状态。</li></ul></li><li><p><strong>B类地址</strong></p><ul><li>B类地址用来支持<code>中大型网络</code>。B类IP地址使用4个8位组的前2个8位组标识地址的网络部分，其余的2个8位组用来标识地址的主机部分。</li><li>用二进制数表示时，B类地址的前2位（最左边）总是10。因此，第1个8位组的最小值为10000000（十进制数为128），最大值为10111111（十进制数为191）。</li><li>任何IP地址第1个8位组的取值范围在128到191之间时都是B类地址。</li><li>B类地址的网络掩码为：255.255.0.0</li></ul></li><li><p><strong>C类地址</strong></p><ul><li>C类地址用来支持<code>小型网络</code>。C类IP地址使用4个8位组的前3个8位组标识地址的网络部分，其余的1个8位组用来标识地址的主机部分。</li><li>用二进制数表示时，C类地址的前3位（最左边）总是110。因此，第1个8位组的最小值为11000000（十进制数为192），最大值为11011111（十进制数为223）。</li><li>任何IP地址第1个8位组的取值范围在192到223之间时都是C类地址。</li><li>每个C类网络号有254台主机。</li><li>C类地址的网络掩码为：255.255.255.0</li></ul></li><li><p><strong>D类地址</strong></p><ul><li>D类地址用来支持<code>组播</code>。组播地址是唯一的，用来转发目的地址为<code>预先定义的一组IP地址</code>的分组。因此，一台工作站可以将单一的数据流传输给多个接收者。</li><li>用二进制数表示时，D类地址的前4位（最左边）总是1110。D类IP地址的第1个8位组的范围是从11100000到11101111，即从224到239。</li><li>任何IP地址第1个8位组的取值范围在224到239之间时都是D类地址。</li><li>在多播（/组播）操作中<code>没有网络或主机位</code>，数据包将传送到网络中选定的主机子集中。</li></ul></li><li><p><strong>E类地址</strong></p><ul><li>Internet工程任务组保留E类地址作为研究使用，因此Internet上没有发布E类地址使用。</li><li>用二进制数表示时，E类地址的前4位（最左边）总是1111。E类IP地址的第1个8位组的范围是从11110000到11111111，即240到255。</li><li>任何IP地址第1个8位组的取值范围在240到255之间时都是E类地址</li></ul></li><li><p>特殊的IP地址<br /><img src="https://s2.loli.net/2022/01/06/vIDOFA4Q6qTCRYK.png" alt="" /><br /><img src="https://s2.loli.net/2022/01/06/kc8KVXhLxAw3WPl.png" alt="" /></p><ul><li>网络地址<ul><li>用于表示网络本身，具有正常的网络号部分，<code>主机号部分为全“0”的IP地址代表一个特定的网络</code>，即作为网络标识之用，如102.0.0.0、138.1.0.0和198.10.1.0分别代表了一个A类、B类和C类网络。</li></ul></li><li>广播地址<ul><li>用于向网络中的所有设备广播分组。具有正常的网络号部分，<code>主机号部分为全“1”的IP地址代表一个在指定网络中的广播</code>，被称为广播地址，如102.255.255.255、138.1.255.255和198.10.1.255分别代表在一个A类、B类和C类网络中的广播。</li></ul></li><li>私有地址（不能在Internet上使用）<ul><li>10.0.0.0~10.255.255.255</li><li>172.16.0.0~172.31.255.255</li><li>192.168.0.0~192.168.255.255</li></ul></li></ul></li></ul><hr /><h4 id="子网"><a class="markdownIt-Anchor" href="#子网"></a> 子网</h4><ul><li>子网（Sub Networking）是指由网络管理员将一个给定的网络分为若干个更小的部分，这些更小的部分被称为子网（Subnet）</li><li>子网划分的优越性<ul><li>引入子网划分技术可以有效提高IP地址的利用率，从而可节省宝贵的IP地址资源。</li></ul></li><li>子网掩码</li><li>子网掩码（Subnet mask）通常与IP地址配对出现，其功能是告知主机或路由设备，IP地址的哪一部分代表网络号部分，哪一部分代表主机号部分。<ul><li>子网掩码使用与IP地址相同的编址格式，即32位长度的二进制比特位，也可分为4个8位组并采用点十进制来表示。但在子网掩码中，<code>与IP地址中的网络位部分对应的位取值为“1”，而与IP地址主机部分对应的位取值为“0”。</code></li><li>通过将子网掩码与相应的IP地址进行<code>求“与”操作</code>，就可决定给定的IP地址所属的网络号（包括子网络信息）</li><li>例如，102.2.3.3/255.0.0.0表示该地址中的前8位为网络标识部分，后24位表示主机部分，从而网络号为102.0.0.0<br /><img src="https://s2.loli.net/2022/01/06/i4FvJylOQYhTjxq.png" alt="" /><br /><img src="https://s2.loli.net/2022/01/09/pdP4Tax5RDtqMJE.png" alt="" /></li></ul></li></ul><hr /><h4 id="cidr一无类域间路由"><a class="markdownIt-Anchor" href="#cidr一无类域间路由"></a> CIDR一无类域间路由</h4><ul><li>消除了传统的A、B、C类地址以及划分子网的概念，融合子网地址和子网掩码，方便子网划分</li><li>记法：IP地址后加上 “/”，然后写上网络前缀的位数<br /><img src="https://s2.loli.net/2022/01/09/lEHgt4rs9o7RUMS.png" alt="" /></li><li>把多个小前缀的地址块合并成一个大前缀的地址块的过程称为路由聚合（route aggregation ），由此产生的较大前缀地址块有时称为超网（supernet ），以便有别于地址块的分割。</li><li>前缀允许重叠。规则是数据包按最具体路由的方向发送，即具有最少 IP地址的<code>最长匹配前缀（longest matching prefix ）</code></li><li>CIDR 的工作原理如下<ul><li>当一个数据包到达时，路由器扫描路由表以便确定目的地是否在前缀的地址块内。</li><li>有可能多个具有不同前缀的表项得到匹配，在这种情况下，使用具有<code>最长前缀的表项</code></li></ul></li></ul><hr /><h4 id="nat-网络地址转换"><a class="markdownIt-Anchor" href="#nat-网络地址转换"></a> NAT－网络地址转换</h4><ul><li>公用地址和私有地址<ul><li>公有IP地址是唯一的，因为公有IP地址是全局的和标准的，所以没有任何两台连到公共网络的主机拥有相同的IP地址。</li><li>私有地址（Private Address）的地址资源供内部实现IP网络时使用。<code>根据规定，所有以私有地址为目的地址的IP数据报都不能被路由至Internet上</code>，这些以私有地址作为逻辑标识的主机若要访问外面的Internet，必须采用网络地址翻译（Network Address Translation，简称NAT）或应用代理（proxy）方式。</li></ul></li></ul><p><img src="https://s2.loli.net/2022/01/09/k9ThqVA8RnULFQy.png" alt="" /></p><ul><li><p>NAT的类型</p><ul><li>静态NAT<ul><li>静态NAT在地址映射表中为每一个需要转换的内部本地地址创建了一个固定的地址映射关系，<code>映射了唯一的内部全局地址</code>，本地地址与全局地址一一对应</li><li>也就是说，在静态NAT中，内部网络中的每一个主机都被永久映射了可以访问外部网络的某个合法地址，当内部主机访问外部网络时，内部本地地址就会转换为相应的全局地址。</li></ul></li><li>动态NAT<ul><li>动态NAT是将可用的内部全局地址的地址集定义为<code>NAT池（NAT Pool）</code>，对于要与外界进行通信的内部主机，如果还没有建立映射关系，NAT设备将会动态的从NAT池中选择一个全局地址与内部主机的本地地址进行转换。</li><li>该映射关系在<code>连接建立时动态创建，而在连接终止时将被回收</code>。动态NAT增强了网络的灵活性，减少了所需的全局地址的数量。</li><li>如<code>果NAT池中的全局地址被全部占用，则此后的地址转换申请将被拒绝</code>，这样会造成网络连通性的问题。另外由于每次的地址转换都是动态的，所以同一主机在不同连接中的全局地址是不同的，这会增加网络管理的难度</li></ul></li><li>地址端口转换（NAPT）<ul><li>地址端口转换是动态转换的一种变形，它可以<code>使多个内部主机共享一个内部全局地址</code>，而通过源地址和目的地址的<code>TCP/UDP端口号来区分</code>地址映射表中的映射关系和本地地址，这样就更加减少了所需的全局地址的数量。</li></ul><blockquote><p>例如，假设内部主机192.168.1.2和192.168.1.3都使用源端口1723向外发送数据包，NAPT路由器把这两个内部本地地址都转换为全局地址202.10.50.2，而使用不同的端口号1492和1723。当接收方收到源端口为1492的报文时，则返回的报文在到达NAPT路由器后，其目的地址和端口将被转换为192.168.1.2:1723。当接收方收到源端口为1723的报文时，则返回的报文在到达NAPT路由器后，其目的地址和端口将被转换为192.168.1.3:1723。</p></blockquote></li></ul></li><li><p>配置NAT<br /><img src="https://s2.loli.net/2022/01/09/YgfS3APRMKLZ4dJ.png" alt="" /></p></li></ul><hr /><h3 id="internet-控制协议"><a class="markdownIt-Anchor" href="#internet-控制协议"></a> Internet 控制协议</h3><h4 id="icmpinternet-control-message-protocolinternet-控制消息协议"><a class="markdownIt-Anchor" href="#icmpinternet-control-message-protocolinternet-控制消息协议"></a> ICMP(Internet Control Message Protocol)：Internet 控制消息协议</h4><ul><li>在网络层提供了Internet控制消息协议（Internet control message protocol，简称ICMP）来检测网络，包括路由、拥塞、服务质量等问题。</li><li>ICMP是在RFC792中定义的，其中给出了多种形式的ICMP消息类型，每个ICMP消息类型都被封装于IP分组中。网络测试工具“Ping”和“Tracert”就都是基于ICMP实现的。</li><li>例如，若在主机1上输入一个“Ping 192.168.1.1”命令，则相当于向目的主机192.168.1.1发出了一个以<code>回应请求（Echo Request）</code>为消息类型的ICMP包，若目的主机存在，则其会向主机1发送一个以回应应答（Echo Reply）为消息类型的ICMP包；若目的主机不存在，则主机1会得到一个以不可达目的地（Unreachable Destination）为消息类型的ICMP错误消息包。</li><li>ICMP报文是封装在IP数据报内部的。<br /><img src="https://s2.loli.net/2022/01/09/9mQpxb8jvPnqyNh.png" alt="" /><br /><img src="https://s2.loli.net/2022/01/09/LrZzwIAfEFWRBHg.png" alt="" /></li><li>ICMP网络错误通告的数据报包括目的端不可达通告、超时通告、参数错误通告等。<ol><li>目的端不可达通告</li></ol><ul><li>路由器主要的功能是对IP数据报进行路由和转发，但在操作过程中存在着失败的可能。失败的原因是多种多样的，如目的端硬件故障、路由器没有到达目的端的路径、目的端不存在等。</li></ul><ol start="2"><li>超时通告</li></ol><ul><li>路由器选择如果出现错误，会导致路由环路的产生，从而引起TTL值递减为0和定时器超时。若定时器到时，路由器或目的主机会将IP数据报丢弃，并向源端发送超时通告。</li></ul><ol start="3"><li>参数错误通告</li></ol><ul><li>如果IP数据报中某些字段出现错误，且错误非常严重，路由器会将其抛弃，并向源端发送参数错误通告。</li></ul></li></ul><hr /><h4 id="arpthe-address-resolution-protocol地址解析协议"><a class="markdownIt-Anchor" href="#arpthe-address-resolution-protocol地址解析协议"></a> ARP(The Address Resolution Protocol)：地址解析协议</h4><ul><li>为使设备之间能够互相通信，<code>源设备需要目的设备的IP地址和MAC地址</code>。当一台设备试图与另一台已知IP地址的设备通信时，它必须确定对方的MAC地址。使用TCP/IP协议集中的地址解析协议（Address Resolution Protocol，简称ARP）可以自动获得MAC地址。<code>ARP协议允许主机根据IP地址查找MAC地址。</code></li><li>每一个主机都设有一个<code>ARP高速缓存</code>，里面有所在的局域网上的各主机和路由器的IP地址到硬件地址的映射表。</li><li><code>代理ARP（proxy ARP）</code>：即所有目的主机不与源主机在同一网络中的数据报均会被发给源主机的默认网关，由默认网关来完成下一步的数据传输工作。</li></ul><p><img src="https://s2.loli.net/2022/01/09/iolMF1xwkvuQKyW.png" alt="" /></p><ul><li><p><code>子网内</code>ARP解析</p><ul><li>一台计算机能够解析另一台计算机地址的<code>条件是这两台计算机都连在同一物理网络中</code>，如主机1向主机2发送数据报。<ul><li>主机1以主机2的IP地址为目的IP地址，以自己的IP地址为源IP地址封装了一个IP数据报；在数据报发送以前，<code>主机1通过将子网掩码和源IP地址及目的IP地址进行求“与”操作判断源和目的在同一网络中</code></li></ul></li><li>于是主机1转向查找本地的<code>ARP缓存</code>，以确定在缓存中是否有关于主机2的IP地址与MAC地址的映射信息</li><li>若在缓存中<code>存在主机2的MAC地址信息</code>，则主机1的网卡立即以主机2的MAC地址为目的MAC地址、以自己的MAC地址为源MAC地址进行帧的封装并启动帧的发送<ul><li>主机2收到该帧后，确认是给自己的帧，进行帧的拆封并取出其中的IP分组交给网络层去处理</li></ul></li><li>若在缓存中<code>不存在</code>关于主机2的MAC地址映射信息，则主机1以广播帧形式向同一网络中的所有结点发送一个<code>ARP请求（ARP request）</code><ul><li>在该广播帧中48位的<code>目的MAC地址以全“1”即“ffffffffffff”表示</code>，并在数据部分发出关于“谁的IP地址是192.31.65.5”的询问，这里192.31.65.5代表主机2的IP地址。</li></ul></li><li>网络CS中的所有主机都会收到该广播帧，并且所有收到该广播帧的主机都会检查一下自己的IP地址，但只有主机2会以自己的MAC地址信息为内容给主机1发出一个<code>ARP回应（ARP reply）</code>。</li><li>主机1收到该回应后，首先将其中的MAC地址信息加入到本地ARP缓存中，然后启动相应帧的封装和发送过程<br /><img src="https://s2.loli.net/2022/01/06/rkX3gsD7whWztJl.png" alt="" /></li></ul></li><li><p>子网间ARP解析</p><ul><li>源主机和目的主机<code>不在同一网络</code>中<ul><li>例如主机1向主机4发送数据报，假定主机4的IP地址为192.31.63.8。这时若继续采用ARP广播方式请求主机4的MAC地址是不会成功的，因为<code>第2层广播（在此为以太网帧的广播）是不可能被第3层设备路由器转发的</code>。</li></ul></li><li>需要采用一种被称为<code>代理ARP（proxy ARP）</code>的方案，即所有目的主机不与源主机在同一网络中的数据报均会被<code>发给源主机的默认网关，由默认网关来完成下一步的数据传输工作</code>。注意，所谓默认网关是<code>指与源主机位于同一网段中的某个路由器接口的IP地址</code><ul><li>在此例中相当于路由器的以太网接口F1/E3的IP地址，即192.31.65.1。</li><li>也就是说在该例中，<code>主机1以默认网关的MAC地址为目的MAC地址</code>，而以主机1的MAC地址为源MAC地址，将发往主机4的分组封装成以太网帧后发送给默认网关，然后交由路由器来进一步完成后续的数据传输。</li></ul></li><li>实施代理ARP时需要在<code>主机1上缓存关于默认网关的MAC地址映射信息</code>，若不存在该信息，则同样可以采用前面所介绍的ARP广播方式得知，因为默认网关与主机1是位于同一网段中的<br /><img src="https://s2.loli.net/2022/01/09/I75PatgenY4o1xC.png" alt="" /></li></ul></li></ul><hr /><ul><li><strong>RARP(The Reverse Address Resolution Protocol)：反向地址解析协议</strong><ul><li>反向地址解析协议（RARP）<code>把MAC地址绑定到IP地址上</code>。这种绑定允许一些网络设备在把数据发送到网络之前对数据进行封装。</li><li>一个网络设备或工作站可能知道自己的MAC地址，但是不知道自己的IP地址。<code>设备发送RARP请求，网络中的一个RARP服务器出面来应答RARP请求</code>，RARP服务器有一个事先做好的从工作站硬件地址到IP地址的映射表，当收到RARP请求分组后，RARP服务器就从这张映射表中查出该工作站的IP地址，然后写入RARP响应分组，发回给工作站。</li></ul></li></ul><hr /><h4 id="dhcp-dynamic-host-configuration-protocol动态主机配置协议"><a class="markdownIt-Anchor" href="#dhcp-dynamic-host-configuration-protocol动态主机配置协议"></a> DHCP (Dynamic Host Configuration Protocol)：动态主机配置协议</h4><ul><li>动态主机配置协议 （DHCP） 是一种使网络管理员能够集中管理和自动分配 IP 网络地址的通信协议。在 IP 网络中，每个连接 Internet 的设备都需要分配唯一的 IP 地址。 DHCP 使网络管理员能从中心结点监控和分配 IP 地址。当某台计算机移到网络中的其它位置时，能自动收到新的IP 地址。</li><li>DHCP 使用了租约的概念，或称为计算机 IP 地址的有效期。租用时间是不定的，主要取决于用户在某地联接 Internet 需要多久，这对于教育行业和其它用户频繁改变的环境是很实用的。通过较短的租期， DHCP 能够在一个计算机比可用 IP 地址多的环境中动态地重新配置网络。</li><li>DHCP 支持为计算机分配静态地址，如需要永久性 IP 地址的 Web 服务器。</li></ul><p><img src="https://s2.loli.net/2022/01/09/npJ61zeOKYGAk3j.png" alt="" /></p><ul><li>Server-DHCP服务器，IP地址池，为客户端分配：IP地址、子网掩码、网关、DNS服务器。</li><li>DHCP客户，向服务器提出申请，从服务器自动获取：IP地址、子网掩码、网关、DNS服务器的IP地址</li></ul><p><img src="https://s2.loli.net/2022/01/09/OUCdoghne1uNZxJ.png" alt="" /></p><p><img src="https://s2.loli.net/2022/01/09/xAXHJhGcjlqtRr4.png" alt="" /></p><hr /><h4 id="内部网关协议和外部网关协议"><a class="markdownIt-Anchor" href="#内部网关协议和外部网关协议"></a> 内部网关协议和外部网关协议</h4><ul><li>按照作用范围和目标的不同，路由协议还可被分为内部网关协议和外部网关协议。</li><li><strong>内部网关协议</strong>（IGP，Interior Gateway Protocols）是指作用于自治系统以内的路由协议。 <strong>RIP</strong>（ Routing Information Protocol ,属于距离矢量路由）、<strong>OSPF</strong> (Open Shortest Path First，属于链路状态路由)等都属于内部网关协议。</li><li><strong>外部网关协议</strong>（EGP，Exterior Gateway Protocols）则是作用于不同自治系统之间的路由协议。在Internet广为使用的边界网关协议（Border Gateway Protocol，简称<strong>BGP</strong>，属于距离矢量路由）则是外部网关协议的典型例子。</li><li>所谓自治系统（Autonomous System，简称AS）是指网络中那些由相同机构操纵或管理，对外表现出相同的路由视图的路由器所组成的系统。</li></ul><hr /><h4 id="ospf一一内部网关路由协议"><a class="markdownIt-Anchor" href="#ospf一一内部网关路由协议"></a> OSPF一一内部网关路由协议</h4><ul><li>OSPF是一种链路状态路由协议的典型例子。</li></ul><p><img src="https://s2.loli.net/2022/01/09/bB7KLAafiGhYuyc.png" alt="" /></p><p><img src="https://s2.loli.net/2022/01/09/gembHFkKoYX2LPZ.png" alt="" /></p><hr /><h3 id="ipv6"><a class="markdownIt-Anchor" href="#ipv6"></a> IPv6</h3><ul><li><strong>IPv6的定义</strong><ul><li>IPv6采用128位地址长度，几乎可以不受限制地提供地址。如果按保守方法估算IPv6实际可分配的地址，那么整个地球的每平方米面积上可分配1000多个地址。</li><li>在IPv6的设计过程中除了解决了地址短缺问题以外，还考虑了在IPv4中解决不好的其他问题，主要有端到端IP连接、服务质量（QoS）、安全性、多播、移动性、即插即用等。</li><li>IPv6与IPv4相比，有以下特点和优点：<ul><li>更大的地址空间。IPv4中规定IP地址长度为32，即有2<sup>32−1个地址；而IPv6中IP地址的长度为128，即有2</sup>128−1个地址。</li><li>更小的路由表。IPv6的地址分配一开始就遵循聚类（Aggregation）的原则，这使得路由器能在路由表中用一条记录（Entry）表示一片子网，大大减小了路由器中路由表的长度，提高了路由器转发数据报的速度。</li><li>增强的组播（Multicast）支持以及对流的支持（Flow-control）。这使得网络上的多媒体应用有了长足发展的机会，为服务质量（QoS）控制提供了良好的网络平台。</li><li>加入了对自动配置（Auto-configuration）的支持。这是对DHCP协议的改进和扩展，使得网络（尤其是局域网）的管理更加方便和快捷。</li><li>更高的安全性。在使用IPv6网络时用户可以对网络层的数据进行加密并对IP报文进行校验，这极大地增强了网络安全。</li></ul></li></ul></li><li><strong>IPv6数据报格式</strong><ul><li>IPv6数据报头</li><li>扩展（下一个报头）</li><li>有效载荷</li></ul></li></ul><p><img src="https://s2.loli.net/2022/01/09/ZtSPwy4RQDKsaBi.png" alt="" /></p><ul><li><p><strong>Version (版本号)</strong> ：二进制0110</p></li><li><p><strong>Traffic Class(业务量等级)</strong>：在IPv6优先级域中首先要区分二大业务量（traffic）：</p><ol><li>受拥塞控制（congestion-controlled）业务量；</li><li>不受拥塞控制的（noncongestion-controlled）业务量。</li></ol><ul><li>在IPv6规范中0～7级的优先级为受拥塞控制的业务量保留，这种业务量的最低优先级为1，Internet控制用的业务量优先级为7。</li><li>不受拥塞控制的业务量是指当网络拥塞时不能进行速率调整的业务量。对时延要求很严的实时话音即是这类业务量的一个示例。在IPv6中将其值为8～15的优先级分配给这种类型的业务量。</li></ul></li><li><p><strong>流标识</strong>：一个流由其源地址、目的地址和流序号来命名。在IPv6规范中规定“流”是从某个源点向（单点或组播的）信宿发送的分组群中，源点要求中间路由器进行特殊处理的那些分组。也就是说，流是指源点、信宿和流标记三者分别相同的分组的集合。</p></li><li><p><strong>有效载荷长度</strong>：有效载荷长度域指示IP基本头标以后的IP数据报剩余部分的长度，单位是字节。此域占16位，因而IP数据报通常应在65535字节以内。</p></li><li><p><strong>下一报头</strong>：下一报头用来标识数据报中的基本IP报头的下一报头，在此报头中，指示选项的IP报头和上层协议。<br /><img src="https://s2.loli.net/2022/01/09/zUKJuGNeLgMXsvR.png" alt="" /></p></li><li><p>站段限制：站段限制决定了能够将分组传输到多远。主机在生成数据报时，在站段限制域中设置某一初值，然后将数据报送到网上的路由器。各路由器从该值起逐次减1。如数据报到达信宿之前其站段限制变为0，该数据报就被抛弃掉。</p></li><li><p>源地址和目的地址：基本IP头标中最后2个域是源地址和目的地址，它们各占128位。在此域中置入数据报最初的源地址和最后的目的地址</p></li></ul><hr /><ul><li><strong>IPv6扩展头</strong><ul><li>IPv6规范定义了6个扩展报头</li><li>每个扩展报头由前面报头的Next Header字段标识</li><li>每个扩展报头的字节长为8的整数倍</li></ul></li></ul><p><img src="https://s2.loli.net/2022/01/09/8iJTO3Vt45xyMYh.png" alt="" /></p><ul><li><strong>Hop-by-Hop Options Extension Header</strong><ul><li>Hop-by-Hop Options扩展报头携带着必须由数据包经过路径上的每个节点进行检查的可选信息。它必须紧跟在IPv6 报头后，并由Next Header 值0 表示。</li><li>在IPv4 中，路由器判断是否需要检查数据报的惟一方法是解析所有数据报中的上层数据，至少是部分解析。这极大地降低了路由处理速度。</li><li>在IPv6 中，如果没有Hop-by-Hop Options 扩展报头，则路由器知道无须处理路由器相关的信息，因此可以立即把数据包路由到最终目的地。</li><li>若存在Hop-by-Hop Options 扩展报头，则路由器只需检查报头，而无须深入查看数据包。<br /><img src="https://s2.loli.net/2022/01/06/BKAt7HQDslVGNRd.png" alt="pic" /></li><li>Options（选项，长度不定）：这可能是一个或多个选项。该选项的长度是不定的，由Header Extension Length 字段决定。</li><li>Option Type（选项类型）字段是Options 字段的第一个字节，包含了在执行处理的节点不能识别该选项时如何处理选项的信息。该值的前两位值指定了要执行的操作。</li></ul></li><li><strong>Routing Extension Header</strong><ul><li>Routing报头用来给出一个或多个数据包在到达目的地的路径上应该经过的中间节点。在IPv4 中，这叫做Loose Source 和Record Route 选项。Routing 报头由其前一个报头的Next Header 值43 标识<br /><img src="https://s2.loli.net/2022/01/06/j63vDW2RklCZdYA.png" alt="" /></li></ul></li></ul><hr /><h1 id="传输层-2"><a class="markdownIt-Anchor" href="#传输层-2"></a> 传输层</h1><h2 id="传输服务"><a class="markdownIt-Anchor" href="#传输服务"></a> 传输服务</h2><h3 id="提供给上层的服务"><a class="markdownIt-Anchor" href="#提供给上层的服务"></a> 提供给上层的服务</h3><p><img src="https://s2.loli.net/2022/01/09/XyEewlgI415HaQb.png" alt="" /></p><hr /><h3 id="传输服务原语"><a class="markdownIt-Anchor" href="#传输服务原语"></a> 传输服务原语</h3><p><img src="https://s2.loli.net/2022/01/09/HWXSMl21xzIURhy.png" alt="" /></p><p><img src="https://s2.loli.net/2022/01/09/uno5dIgtFXh6MEb.png" alt="" /></p><ul><li>段（传输层之间交换的单元）被包裹在数据包（网络层之间交换的单元）中，而数据包则被包含在帧（数据链路层之间交换的单元）中。</li><li>当一帧到达时，数据链路层对帧头进行处理，如果帧目标地址与本地传递地址匹配，则把帧的有效载荷字段中的内容传递给网络实体。</li><li>网络实体对数据包头进行类似处理，然后把数据包的有效载荷字段内容向上传递给传输实体。</li></ul><p><img src="https://s2.loli.net/2022/01/06/DQ4jxwOIWiHdlAG.png" alt="" /></p><ul><li>斜体标记的状态转移是由到达的包引起的。实线表示客户的状态序列，虚线表示服务器的状态序列</li></ul><hr /><h3 id="berkeley-套接字"><a class="markdownIt-Anchor" href="#berkeley-套接字"></a> Berkeley 套接字</h3><p><img src="https://s2.loli.net/2022/01/09/8KDhHUJV4vX5Sys.png" alt="" /></p><hr /><h2 id="传输协议的要素"><a class="markdownIt-Anchor" href="#传输协议的要素"></a> 传输协议的要素</h2><p><img src="https://s2.loli.net/2022/01/09/MtVir3hR9lL1pXO.png" alt="" /></p><hr /><h3 id="寻址"><a class="markdownIt-Anchor" href="#寻址"></a> 寻址</h3><p><img src="https://s2.loli.net/2022/01/09/uPByKRM738DW4qh.png" alt="" /></p><ul><li>使用通用术语传输服务访问点( TSAP, Transport Service Access Point )来表示传输层的一个特殊端点。</li><li>网络层上的类似端点（即网络层地址）称为网络服务访问点 (CNSAP. Network Service Access Point )。<ul><li>IP 地址是 NSAP 的实例。</li></ul></li><li>应用进程（包括客户和服务器）可以将自己<code>关联到一个本地 TSAP 上</code>，以便与一个远程 TSAP 建立连接。这些连接运行在每台主机的 NSAP 之上。在有些网络中，每台计算机只有一个 NSAP ，但是可能有多个传输端点共享此 NSAP ，因此需要某种方法来区分这些传输端点。</li></ul><p><img src="https://s2.loli.net/2022/01/09/yWD8GLgZUOlVEdw.png" alt="" /></p><hr /><h3 id="连接建立"><a class="markdownIt-Anchor" href="#连接建立"></a> 连接建立</h3><ul><li><p>关键问题是确保可靠性，即使数据包可能丢失、损坏、延迟和重复</p><ul><li>不能将旧的或重复的数据包视为新数据包</li><li>对于丢失/损坏的包，使用 ARQ 和校验和</li></ul></li><li><p>三次握手</p><ul><li>它要求一方检查<code>连接请求是否的确是当前的</code><br /><img src="https://s2.loli.net/2022/01/09/lFgupj3wzST4HLI.png" alt="" /></li></ul></li></ul><hr /><h3 id="连接释放"><a class="markdownIt-Anchor" href="#连接释放"></a> 连接释放</h3><ul><li>终止连接的方式有两种：非对称释放和对称释放<ul><li>非对称释放连接是电话系统的工作方式：当一方挂机后，连接就被中断了。</li><li>对称释放连接是把连接看成两个<code>独立的单向连接</code>，要求单独释放每一个单向连接．</li></ul></li><li>非对称释放方法太冒失，可能导致数据的丢失。<br /><img src="https://s2.loli.net/2022/01/09/NtdyRblzrZWcDa5.png" alt="" /></li><li>使用对称释放方式，每个方向被单独释放，两个方向的连接释放相互独立。因而，即使当主机发送了 DISCONNECT 段以后，它仍然可以接收数据。<br /><img src="https://s2.loli.net/2022/01/09/m8tMIhs947gXcEZ.png" alt="" /></li></ul><hr /><h3 id="流量控制和缓冲"><a class="markdownIt-Anchor" href="#流量控制和缓冲"></a> 流量控制和缓冲</h3><ul><li>解决缓冲区大小问题的另一个方法是为每个连接使用一个大的循环缓冲区<br /><img src="https://s2.loli.net/2022/01/09/lciNAMPjfdLSuyX.png" alt="" /><ul><li>这个系统古朴典雅，并且不依赖于段的大小，但只有当连接重载时，内存的使用情况才很好。</li></ul></li><li>流量控制示例：A 的数据受 B 的缓冲区限制<br /><img src="https://s2.loli.net/2022/01/09/z8vZlctqyaTFprK.png" alt="" /></li></ul><hr /><h2 id="internet-传输协议-udp"><a class="markdownIt-Anchor" href="#internet-传输协议-udp"></a> Internet 传输协议： UDP</h2><h3 id="udp-概述"><a class="markdownIt-Anchor" href="#udp-概述"></a> UDP 概述</h3><ul><li>Internet 协议集支持一个<code>无连接</code>的传输协议，该协议称为用户数据报协议(<code>UDP, User Datagram Protocol</code>)。 UDP 为应用程序提供了一种无需建立连接就可发送封装的 IP 数据报的方法。</li></ul><p><img src="https://s2.loli.net/2022/01/09/dbvK8OoeLEnjDuU.png" alt="" /></p><ul><li><p>UDP建立在IP协议之上，它封装在IP数据区中，同IP协议一样提供无连接数据报传输。相对于IP协议，它<code>唯一增加的能力是提供协议端口</code>，以保证进程通信。</p></li><li><p>UDP目标端口：一个UDP端口是一个可读写的软件结构，内部有一个接收报文缓冲区。接收数据时，UDP软件要判断此目标端口是否与当前使用的端口匹配，如是，则将数据报放入相应的接收队列，否则，抛弃该数据并向源端口发送“端口不可达”的差错消息报文。</p></li><li><p>长度：以字节计的整个报文长度，<code>最小为8，只有报头；最大65515</code>。</p></li><li><p>校验和：它是一个可选项，以提高效率</p></li><li><p>在利用IP传送语音和视频的时候，要利用UDP协议</p></li><li><p>IPv4 的伪头部如图所示<br /><img src="https://s2.loli.net/2022/01/06/e9YaopGS8iuhzUK.png" alt="" /></p><ul><li>它包含源机器和目标机器的 32 地址、 UDP 的协议号（17), 以及 UDP 段〈包括头〉的字节计数。</li></ul></li></ul><hr /><h3 id="远程过程调用"><a class="markdownIt-Anchor" href="#远程过程调用"></a> 远程过程调用</h3><ul><li><strong>远程过程调用(RPC, Remote Procedure Call)</strong>：允许本地程序调用远程主机上的过程。当机器 1 上的进程调用机器 2 的一个过程时，机器 1 上的调用进程被挂起，而机器 2 上的被调用过程则开始执行。信息以参数的形式从调用方传输到被调用方，而过程的执行结果则从反方向传递回来</li></ul><p><img src="https://s2.loli.net/2022/01/06/CwXuyr2AT73QO18.png" alt="" /></p><ul><li>客户端（Client）： 服务的调用方。</li><li>服务端（Server）：真正的服务提供者。</li><li>客户端存根（Client stub）：存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。</li><li>服务端存根（Server stub）：接收客户端发送过来的消息，将消息解包，并调用本地的方法。</li></ul><hr /><h3 id="实时传输协议rtp-real-time-transport-protocol"><a class="markdownIt-Anchor" href="#实时传输协议rtp-real-time-transport-protocol"></a> 实时传输协议(RTP, Real-time Transport Protocol)</h3><ul><li>RTP 由 RFC 3550 描述，目前已经广泛应用于<code>多媒体应用程序</code>。<br /><img src="https://s2.loli.net/2022/01/06/gp3MVRGEx8tdWKi.png" alt="" /></li></ul><p><img src="https://s2.loli.net/2022/01/06/TxoykWZw2VpgOtv.png" alt="" /></p><ul><li>Ver：RTP协议的版本号，占2位，当前协议版本号为2。</li><li>P：填充标志，占1位，如果P=1，则在该报文的尾部填充一个或多个额外的八位组(满足4字节的倍数)，它们不是有效载荷的一部分。</li><li>X：扩展标志，占1位，如果X=1，则在RTP报头后跟有一个扩展报头。</li><li>CC：CSRC计数器，占4位，指示CSRC 标识符的个数。</li><li>M: 标记，占1位，不同的有效载荷有不同的含义，对于视频，标记一帧的结束；对于音频，标记会话的开始。</li><li>PT: 有效载荷类型，占7位，用于说明RTP报文中有效载荷的类型，如GSM音频、JPEG图像等,在流媒体中大部分是用来区分音频流和视频流的，这样便于客户端进行解析。</li><li>序列号：占16位，用于标识发送者所发送的RTP报文的序列号，每发送一个报文，序列号增1。这个字段当下层的承载协议用UDP的时候，网络状况不好的时候可以用来检查丢包。同时出现网络抖动的情况可以用来对数据进行重新排序，在linux服务器中这个字段是从0开始的，同时音频包和视频包的sequence是分别计数的。</li><li>时间戳(Timestamp)：占32位，时间戳反映了该RTP报文的第一个八位组的采样时刻。接收者使用时间戳来计算延迟和延迟抖动，并进行同步控制。</li><li>同步信源(SSRC)标识符：占32位，用于标识同步信源。该标识符是随机选择的，参加同一视频会议的两个同步信源不能有相同的SSRC。</li><li>特约信源(CSRC)标识符：每个CSRC标识符占32位，可以有0～15个。每个CSRC标识了包含在该RTP报文有效载荷中的所有特约信源。</li></ul><hr /><h2 id="internet-传输协议-tcp"><a class="markdownIt-Anchor" href="#internet-传输协议-tcp"></a> Internet 传输协议： TCP</h2><h3 id="tcp-概述"><a class="markdownIt-Anchor" href="#tcp-概述"></a> TCP 概述</h3><ul><li>在RFC793中定义，具有以下功能：<ul><li>数据传输</li><li>多路复用</li><li>可靠传输</li><li>流量控制</li><li>连接</li></ul></li><li>TCP是建立在IP协议之上，封装在IP数据区中，但它是在基于无连接的IP协议之上提供<code>面向连接</code>的<code>高可靠性</code>数据传输和与进程通信的能力。它利用<code>确认与超时重传</code>、<code>滑动窗口机制</code>进行流控和拥塞控制来保证高可靠性的，同时，为了保证可靠性，它以牺牲效率为代价，在高实时要求场合不合适。</li></ul><hr /><h3 id="tcp-服务模型"><a class="markdownIt-Anchor" href="#tcp-服务模型"></a> TCP 服务模型</h3><ul><li><p>TCP 服务由发送端和接收端创建一种称为**套接字（ socket ）**的端点来获得。每个套接字有一个套接字编号（地址），该编号由主机的 IP址以及一个本地主机的 16 位数值组成的。</p><ul><li>这个 16 位数值称为<strong>端口（port ）</strong>，端口是 TCP的TSAP 名字。</li><li>为了获得 TCP 服务，必须显式地在一台机器的套接字和另一台机器的套接字之间建立一个连接<br /><img src="https://s2.loli.net/2022/01/06/Ar2LeynZD57zJlB.png" alt="" /></li></ul></li><li><p>一个 TCP 连接就是一个字节流，而不是消息流。端到端之间不保留消息的边界。</p><ul><li>如果发送进程将 512 字节的数据块写到一个 TCP 流中，那么这些数据有可能按 512 字节块、 1024 字节块、 2048 字节块或者其他的方式被递交给接收进程。</li><li>接收端不管多么努力尝试，都无法获知这些数据被写入字节流时的单元大小。<br /><img src="https://s2.loli.net/2022/01/06/tuEHVByGqobNDI5.png" alt="" /></li></ul></li></ul><hr /><h3 id="tcp-协议"><a class="markdownIt-Anchor" href="#tcp-协议"></a> TCP 协议</h3><ul><li>发送端和接收端的 TCP 实体以段的形式交换数据。 TCP 段（ TCP segment ）由一个固定的 20 字节的头（加上可选的部分）以及随后0个或者多个数据字节构成。</li><li>TCP 软件决定了段的大小。它可以将多次写操作中的数据累积起来，放到一个段中发送，也可以将一次写操作中的数据分割到多个段中发送。<ul><li>有两个因素限制了段的长度。首先，包括 TCP 头在内的每个段，必须适合 IP 的 65 515 个字节有效载荷</li><li>其次，每个网络都有一个最大传输单元（MTU, maximum transfer unit ）。发送端和接收端的每个段必须适合 ，才能以单个不分段的数据包发送和接收。实际上， <code>MTU 通常是 1500 字节</code>（以太网的有效载荷大小）</li></ul></li></ul><hr /><h3 id="tcp-段的头"><a class="markdownIt-Anchor" href="#tcp-段的头"></a> TCP 段的头</h3><p><img src="https://s2.loli.net/2022/01/06/VoMFTADq5pI2Sma.png" alt="" /></p><ul><li><strong>序号</strong>：指出段中数据在发送端数据流中的位置。</li><li><strong>确认号</strong>：指出本机希望下一个接收的字节的序号。</li><li><strong>头长</strong>：指出以32比特为单位的段头长度。它是针对变长的“选项”域设计的。</li><li><strong>码位</strong>：有些报文段是用于传输数据的，但有些报文段仅仅携带了确认信息，另一些报文段携带的是建立和关闭连接的请求。它使用“码位”来指出段的目的与内容。这8个比特各位的意义如表：</li></ul><table><thead><tr><th style="text-align:center">码位</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">CWR, 拥塞控制信号</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">ECE, 显式拥塞通知</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">URG, 紧急指针字段可用</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">ACK, 确认字段可用</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">PSH, 本报文段请求急迫(PUSH)操作</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">RST, 连接复位</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">SYN, 序号同步，用于建立连接中的同步</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">FIN, 发送方字节流结束</td></tr></tbody></table><ul><li>由于有时<code>发送方希望终止操作，不想接收方接收完所有的比特</code>。如远程主机上的程序错误时就需要这种信号。TCP将数据指定为**“紧急”型**，<code>接收方收到这种数据后，会不必排队而尽快通知应用程序</code>。URG比特为1时，表明它是紧急的，其中的“紧急指针”指出了紧急数据在报文段中的结束位置。</li><li>当所有的紧急数据消失之后，TCP软件会告诉应用程序恢复正常的操作状态。<code>PUSH位提供了数据强迫传输机制，以强迫传输当前流中的数据</code>，而不必等待缓冲区满。远程登录中，终端的击键信号就是用PUSH作来提供的</li></ul><p><img src="https://s2.loli.net/2022/01/06/lkKinphrNt5cxmI.png" alt="" /></p><ul><li>校验和（ Checksum ）提供了额外的可靠性。它校验的范围包括头、数据，以及与 UDP一样的概念性伪头。除了伪头的协议号为 TCP (6)，并且校验和必需强制执行。</li></ul><hr /><h3 id="tcp-连接建立"><a class="markdownIt-Anchor" href="#tcp-连接建立"></a> TCP 连接建立</h3><ul><li>TCP 使用了三次握手法来建立连接</li></ul><p><img src="https://s2.loli.net/2022/01/06/zE6tMHgaTskv2Ax.png" alt="" /></p><ul><li>第一次：客户机向服务器发送链接请求。<code>（服务器是死循环监听状态）</code>。那么首部中的<code>SYN=1，seq是序号</code>。TCP规定了SYN报文段不能携带数据，但是要消耗一个序号。表明我们连接发送的第一个编号是x。</li><li>第二次：服务器收到了客户机的请求（SYN是一个标示）。于是自己也发送一个<code>同意连接SYN和一个确认收到ACK</code>，seq是y.说明我这边第一次发送的编号是y。<code>Ack是收到了x+1之前的所有帧</code>。</li><li>第三次：客户端收到确认之后也发送一个确认过去</li></ul><hr /><h3 id="tcp-连接释放"><a class="markdownIt-Anchor" href="#tcp-连接释放"></a> TCP 连接释放</h3><ul><li>TCP 使用了四次挥手法来释放连接</li></ul><p><img src="https://s2.loli.net/2022/01/06/G6OWTsRXeQ3H9U5.png" alt="" /></p><ul><li>第一挥：由客户机主动发送释放报文，并且单方面停止发送数据。</li><li>第二挥：服务器收到发送确认。其实<code>这个时候客户机-&gt;服务器已经关闭</code>了。</li><li>第三挥：因为服务器数据还没传完。这个时候服务器发送，客户端还是要收。传完了就发送关闭请求。</li><li>第四挥：客户端发送确认请求，等2MSL后超时关闭。</li><li>虽然 TCP 连接是全双工的，但是，为了理解 TCP 连接是如何释放的，最好将 TCP接看成<code>一对单工连接</code>。<ul><li>每个单工连接的释放彼此独立。为了释放一个连接，任何一方都可以发送一个<code>设置了 FIN 标志位</code>的 TCP 段，这表示它己经没有数据要发送了。</li><li>当 FIN 段被另一方确认后，这个方向上的连接就被关闭，不再发送任何数据。</li><li>通常情况下，释放一个连接需要 4 个TCP 段：每个方向上一个 FIN 和一个 ACK。然而，第一个 ACK 和第二个 FIN 有可能被组合在同一个段中，从而将所需段总数降低到 3 个。</li></ul></li></ul><hr /><h3 id="tcp-连接管理模型"><a class="markdownIt-Anchor" href="#tcp-连接管理模型"></a> TCP 连接管理模型</h3><ul><li><p>建立连接和释放连接所需要的步骤可以用一个有限状态机来表示，在每一种状态中，都存在特定的合法事件。当一个合法事件发生时，可能需要采取某个动作。当发生其他事件时，则报告一个错误。<br /><img src="https://s2.loli.net/2022/01/06/YiXhVKetkp5NGaW.png" alt="" /></p></li><li><p>有限状态机本身如图所示。在图中用粗线表示客户主动连接到一个被动服务器上的一般情形，其中客户部分用的是实线，服务器部分用的是虚线。细线表示了不常用的事件序列。<br /><img src="https://s2.loli.net/2022/01/06/lYLoqy4WjZIsExe.png" alt="" /></p></li></ul><hr /><h3 id="tcp-滑动窗口"><a class="markdownIt-Anchor" href="#tcp-滑动窗口"></a> TCP 滑动窗口</h3><p><img src="https://s2.loli.net/2022/01/06/RD9KnpriQhcP3bL.png" alt="" /></p><p><img src="https://s2.loli.net/2022/01/06/87oxXgfvntFJMa4.png" alt="" /></p><hr /><h3 id="tcp-计时器管理"><a class="markdownIt-Anchor" href="#tcp-计时器管理"></a> TCP 计时器管理</h3><ul><li>TCP 使用多个计时器（至少从概念上讲是计时器）来完成它的工作。其中最重要的是重传计时器 （RTO, Retransmission Timeout ）<ul><li>当 TCP 实体发出一个段时，它同时启动一个重传计时器。如果在该计时器超时前该段被确认，则计时器被停止。</li><li>另一方面，如果在确认到来之前计时器超时，则段被重传（并且该计时器被重新启动）。</li></ul></li></ul><p><img src="https://s2.loli.net/2022/01/06/WNZVSjx3eHc6pIm.png" alt="" /></p><ul><li>如果超时间隔设置得太短，则会发生大量<code>不必要的重传</code>，这么多无用数据包反而堵塞 Internet;</li><li>如果超时间隔被设置得太长，则一旦数据包丢失之后，由于<code>太长的重传延迟</code>，所以性能会受到影响。</li><li>解决方案是使用一个动态算法，它根据网络性能的连续测量’情况，不断地调整超时间隔。</li></ul><hr /><h3 id="tcp-拥塞控制"><a class="markdownIt-Anchor" href="#tcp-拥塞控制"></a> TCP 拥塞控制</h3><ul><li>TCP使用带有丢失信号的 <strong>AIMD</strong> 来控制拥塞<ul><li>实现为网络中可能存在的段数的拥塞窗口 (cwnd)</li><li>使用多种协同工作的机制</li></ul></li></ul><p><img src="https://s2.loli.net/2022/01/06/gLdhT2GucCk1iHb.png" alt="" /></p><ul><li>确认返回到发送端的速率恰好是数据包通过路径上最慢链路时的速率。这正是发送端应该使用的精确发送速率。</li><li>如果发送端以这个速率往网络注入新的数据包，这些数据包就能以慢速链路允许的速率一样快的速度被转发出去，但它们不会再排队和堵塞沿途上的任何一个路由器。</li><li>这个时序就是<strong>确认时钟（ack clock）</strong>。这是 TCP 的基本组成部分。通过使用一个确认时钟，  TCP 平滑输出流量和避免不必要的路由器队列。</li></ul><p><img src="https://s2.loli.net/2022/01/06/sAiPUX9VFBnaMTf.png" alt="" /></p><ul><li>阈值是<code>之前损失 cwn</code>的一半</li></ul><p><img src="https://s2.loli.net/2022/01/06/P5CXZVgMHFQ6A2r.png" alt="" /></p><ul><li>在 3 个重复的 ACK 后重新传输丢失的数据包</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>专业课</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>期末复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统｜线程</title>
    <link href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/os-thread/"/>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/os-thread/</url>
    
    <content type="html"><![CDATA[<h1 id="进程管理"><a class="markdownIt-Anchor" href="#进程管理"></a> 进程管理</h1><h2 id="进程概念"><a class="markdownIt-Anchor" href="#进程概念"></a> 进程概念</h2><h3 id="进程"><a class="markdownIt-Anchor" href="#进程"></a> 进程</h3><ul><li>程序是被动实体，进程是<code>活动实体</code>：当可执行文件加载到内存时，该程序成为进程，<code>一个程序可以对应多个进程</code></li><li>进程 = 程序 + 执行状态</li></ul><!--more--><p><img src="Thread_1.png" alt="" /></p><hr /><h3 id="进程特征"><a class="markdownIt-Anchor" href="#进程特征"></a> 进程特征</h3><ul><li>结构特征：进程实体由程序段、数据段和PCB构成</li><li>动态性：进程是程序的一次执行过程</li><li>并发性<ul><li>多个进程同时存在于内存中，在一段时间内同时运行</li><li>本质是程序的<code>交替运行</code></li></ul></li><li>独立性：进程是独立运行、独立分配资源的基本单位</li><li>异步性：进程按<code>独立的、不可预知</code>的速度向前推进</li><li>交互性：进程之间需要交互</li></ul><hr /><h3 id="进程状态"><a class="markdownIt-Anchor" href="#进程状态"></a> 进程状态</h3><ul><li><code>牛头图</code></li></ul><p><img src="Thread_2.png" alt="" /></p><hr /><h3 id="进程控制块-process-control-block-pcb"><a class="markdownIt-Anchor" href="#进程控制块-process-control-block-pcb"></a> 进程控制块 (Process Control Block, PCB)</h3><ul><li>操作系统中的每个进程用进程控制块来表示</li></ul><p><img src="Thread_3.png" alt="" /></p><p><img src="Thread_4.png" alt="" /></p><hr /><h3 id="进程调度"><a class="markdownIt-Anchor" href="#进程调度"></a> 进程调度</h3><ul><li>目标是无论何时都有进程运行，最大化CPU利用率</li><li>进程调度器选择一个可用进程到CPU上执行</li></ul><hr /><h4 id="调度队列"><a class="markdownIt-Anchor" href="#调度队列"></a> 调度队列</h4><ul><li>进程在进入系统时，会加到<b>作业队列</b>中：包括系统内所有进程</li><li><b>就绪队列</b>：驻留在内存中的、就绪的、等待运行的进程<ul><li>通常用链表实现</li></ul></li><li><b>设备队列</b>：等待特定I/O设备的进程列表</li></ul><p><img src="Thread_5.png" alt="" /></p><ul><li><code>队列图</code>：圆圈表示资源，箭头表示流向，矩形框表示队列</li></ul><p><img src="Thread_6.png" alt="" /></p><hr /><h4 id="调度程序"><a class="markdownIt-Anchor" href="#调度程序"></a> 调度程序</h4><ul><li><b>长期调度程序</b>：从大容量存储设备（通常为磁盘）的缓冲池中选择进程，加载到内存以便执行。</li><li><b>短期调度程序（CPU调度程序）</b>：从准备执行的进程中选择进程，并分配CPU。</li><li>这两种调度程序的主要区别是执行频率。</li><li>大多数进程可分为：<code>I/O密集型进程</code>和<code>CPU密集型进程</code><ul><li>I/O密集型进程：执行I/O比执行计算需要花费更多时间</li><li>CPU密集型进程：很少产生I/O请求，花更多时间执行计算。</li></ul></li><li><b>中期调度程序</b>：将进程从内存（或CPU竞争）中移出，从而降低多道程序程度</li></ul><p><img src="Thread_7.png" alt="" /></p><hr /><h3 id="进程控制"><a class="markdownIt-Anchor" href="#进程控制"></a> 进程控制</h3><ul><li>在操作系统中，一般把进程控制用的程序段称为原语（原子操作），原语的特点是<code>执行期间不允许中断</code>，它是一个不可分割的基本单位</li></ul><hr /><h4 id="进程的创建"><a class="markdownIt-Anchor" href="#进程的创建"></a> 进程的创建</h4><ul><li><p>允许一个进程创建另一个进程</p><ul><li>创建者称为<code>父进程</code>，被创建的进程称为<code>子进程</code>。</li><li>大多数操作系统对进程的识别采用唯一的<code>进程识别符(pid)</code>，每个进程都有一个唯一的pid</li></ul><p><img src="Thread_9.png" alt="" /></p><ul><li>子进程可以从操作系统直接获得资源，也可以从父进程获取资源</li><li>撤销父进程时，需要撤销其子进程</li></ul></li><li><p>在操作系统中，<code>终端用户登录系统、作业调度、系统提供服务、用户程序的应用请求</code>等都会引起进程的创建。</p></li><li><p>创建一个新进程的过程如下：</p><ol><li>为新进程分配一个pid，并申请一个空白PCB</li><li>为进程分配资源，为新进程的程序和数据以及用户栈分配空间</li><li>初始化 PCB 主要包括初始化标志信息、初始化处理机状态信息和初始化处理机控制信息，以及设置进程的优先级等。</li><li>若进程就绪队列能够接纳新进程，则将新进程插入就绪队列，等待被调度运行</li></ol></li><li><p>创建新进程时，有两种执行可能</p><ul><li>父进程与子进程并发执行</li><li>父进程等待，直到某个或全部子进程执行完</li></ul></li><li><p>新进程的地址空间也有两种可能</p><ul><li>子进程是父进程的复制品</li><li>子进程加载另一个新程序</li></ul></li></ul><hr /><ul><li><p>以UNIX为例</p><ul><li>通过系统调用<code>fork()</code>，可以创建新进程</li><li>新进程的地址空间复制原来进程的地址空间<ul><li>父进程和子进程可以轻松通信</li></ul></li><li><code>对于子进程，fork()的返回值为0，父进程的返回值为子进程的pid</code></li><li>系统调用<code>exec()</code>加载二进制文件到内存中并开始执行</li><li>系统调用<code>wait()</code>把进程移出就绪队列，直到子进程终止。</li><li>调用<code>exec()</code>用新进程覆盖了进程的地址空间，所以不会返回控制</li></ul><p><img src="Thread_10.png" alt="" /></p></li><li><p>以Windows为例</p><ul><li>进程创建采用Windows API函数<code>CreateProcess()</code></li><li>它类似于fork()，但是它在创建进程时要求将一个指定程序加载到子进程的地址空间</li></ul></li></ul><hr /><h4 id="进程的终止"><a class="markdownIt-Anchor" href="#进程的终止"></a> 进程的终止</h4><ul><li>通过系统调用<code>exit()</code>请求操作系统删除自身，进程终止</li><li>进程可以返回状态值到父进程。所有进程资源都由操作系统释放</li><li>引起进程终止的事件主要有<ol><li>正常结束，表示进程的任务己完成并准备退出运行。</li><li>异常结束，表示进程在运行时，发生了某种异常事件，使程序无法继续运行，如存储区越界、保护错、非法指令、特权指令错、运行超时、算术运算铺、 I/O 故障等。</li><li>外界干预，指进程应外界的请求而终止运行，如操作员或操作系统干预、父进程请求和父进程终止。</li></ol></li><li><b>僵尸进程</b>：进程已经终止，但是其父进程尚未调用wait()。</li><li><b>孤儿进程</b>：其父进程尚未调用wait()就终止。</li></ul><hr /><h4 id="进程切换"><a class="markdownIt-Anchor" href="#进程切换"></a> 进程切换</h4><ul><li>进程的上下文采用进程PCB表示</li><li>通常，通过执行<code>状态保存</code>，保存CPU当前状态；之后，<code>状态恢复</code>重新开始运行</li></ul><p><img src="Thread_8.png" alt="" /></p><hr /><h3 id="进程间通信"><a class="markdownIt-Anchor" href="#进程间通信"></a> 进程间通信</h3><ul><li>协作进程需要有一种进程间通信(InterProcess Communication,IPC)机制</li></ul><p><img src="Thread_11.png" alt="" /></p><p><img src="Thread_12.png" alt="" /></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>专业课</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ARM微处理器编程｜指令系统-寻址方式</title>
    <link href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B%EF%BD%9C%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/"/>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B%EF%BD%9C%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="arm汇编语法格式"><a class="markdownIt-Anchor" href="#arm汇编语法格式"></a> ARM汇编语法格式</h1><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><mi>o</mi><mi>p</mi><mi>c</mi><mi>o</mi><mi>d</mi><mi>e</mi><mo>&gt;</mo><mo stretchy="false">{</mo><mi>c</mi><mi>o</mi><mi>n</mi><mi>d</mi><mo stretchy="false">}</mo><mo stretchy="false">{</mo><mi>S</mi><mo stretchy="false">}</mo><mo>&lt;</mo><mi>R</mi><mi>d</mi><mo>&gt;</mo><mo separator="true">,</mo><mo>&lt;</mo><mi>R</mi><mi>n</mi><mo>&gt;</mo><mo separator="true">,</mo><mo>&lt;</mo><mi>s</mi><mi>h</mi><mi>i</mi><mi>f</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">_</mi><mi>o</mi><mi>p</mi><mi>e</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;opcode&gt;\{cond\}\{S\}&lt;Rd&gt;,&lt;Rn&gt;,&lt;shifter\_operand&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mclose">}</span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span><br /><img src="https://img-blog.csdnimg.cn/20210509155554187.png" alt="" /></p><ul><li>opcode：指令助记符，如ADD、SUB、MOV等；</li><li>cond：条件码助记符，如EQ(0000)、NE(0001)、AL(1110)等；</li><li>S：如果指令有S后缀，则该指令的操作会影响CPSR的值；</li><li>Rd：目标寄存器；</li><li>Rn：包含第一个源操作数的寄存器；</li><li>shifter_operand：表示第二个源操作数，可以为寄存器或立即数。</li></ul><p><code>所谓寻址方式就是处理器根据指令中给出的地址信息来寻找物理地址的方式。</code></p><h1 id="立即寻址"><a class="markdownIt-Anchor" href="#立即寻址"></a> 立即寻址</h1><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><mi>o</mi><mi>p</mi><mi>c</mi><mi>o</mi><mi>d</mi><mi>e</mi><mo>&gt;</mo><mo stretchy="false">{</mo><mi>c</mi><mi>o</mi><mi>n</mi><mi>d</mi><mo stretchy="false">}</mo><mo stretchy="false">{</mo><mi>S</mi><mo stretchy="false">}</mo><mo>&lt;</mo><mi>R</mi><mi>d</mi><mo>&gt;</mo><mo separator="true">,</mo><mo>&lt;</mo><mi>R</mi><mi>n</mi><mo>&gt;</mo><mo separator="true">,</mo><mi mathvariant="normal">#</mi><mo>&lt;</mo><mi>i</mi><mi>m</mi><mi>m</mi><mi>e</mi><mi>d</mi><mi>i</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;opcode&gt;\{cond\}\{S\}&lt;Rd&gt;, &lt;Rn&gt;, \#&lt;immediate&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mclose">}</span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">#</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span></p><ul><li>立即寻址也叫立即数寻址，这是一种特殊的寻址方式，<code>操作数本身就在指令中给出，只要取出指令也就取到了操作数。</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs c">ADD R0，R0，＃<span class="hljs-number">1</span>          ；R0←R0＋<span class="hljs-number">1</span><br>ADD R0，R0，＃<span class="hljs-number">0x3f</span>       ；R0←R0＋<span class="hljs-number">0x3f</span><br></code></pre></td></tr></table></figure><ul><li>在以上两条指令中，第二个源操作数即为立即数，<code>要求以“＃”为前缀</code>，对于以十六进制表示的立即数，还要求在“＃”后加上“0x”或“&amp;” ，另外％表示二进制数。</li></ul><h2 id="合法的立即数"><a class="markdownIt-Anchor" href="#合法的立即数"></a> 合法的立即数</h2><ul><li>所有的ARM指令都是32 bits固定长度，没有任何一条ARM 指令可包括一个32 bit的立即数。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210509161330444.png" alt="" /></p><ul><li>immediate：立即数</li><li>immed_8：8 位的常数</li><li>rotate_imm：4 位的循环右移值<br /><img src="https://img-blog.csdnimg.cn/20210509161612257.png" alt="" /></li><li>每个立即数都是<code>由一个 8 位的常循环右移偶数位得到</code><ul><li>4 bit 移位值 (0-15)乘于2，得到一个范围在0-30，步长为2的移位值。</li><li><code>最后8位一定要移动偶数位</code></li><li>合法的立即数：<code>二进制有效位间隔不超过8位，且后面的0为偶数个</code></li></ul></li></ul><blockquote><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><mi>i</mi><mi>m</mi><mi>m</mi><mi>e</mi><mi>d</mi><mi>i</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo>&gt;</mo><mo>=</mo><mi>i</mi><mi>m</mi><mi>m</mi><mi>e</mi><mi>d</mi><mi mathvariant="normal">_</mi><mn>8</mn><mi mathvariant="normal">循</mi><mi mathvariant="normal">环</mi><mi mathvariant="normal">右</mi><mi mathvariant="normal">移</mi><mi mathvariant="normal">（</mi><mn>2</mn><mi mathvariant="normal">∗</mi><mi>r</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi mathvariant="normal">_</mi><mi>i</mi><mi>m</mi><mi>m</mi><mi mathvariant="normal">）</mi></mrow><annotation encoding="application/x-tex">&lt;immediate&gt;=immed\_8 循环右移（2∗rotate\_imm）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord">8</span><span class="mord cjk_fallback">循</span><span class="mord cjk_fallback">环</span><span class="mord cjk_fallback">右</span><span class="mord cjk_fallback">移</span><span class="mord cjk_fallback">（</span><span class="mord">2</span><span class="mord">∗</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">m</span><span class="mord cjk_fallback">）</span></span></span></span></p></blockquote><ul><li>ROR 循环右移：即将操作数循环按指定的数量向右循环移位，左边用右边移出的位来填充<br /><img src="https://img-blog.csdnimg.cn/20210509161707791.png" alt="" /></li><li>下列命令中，汇编器把立即数转换为移位操作</li></ul><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-type">MOV</span> r0,#<span class="hljs-number">4096</span>;uses <span class="hljs-number">0x40</span> <span class="hljs-type">ROR</span> <span class="hljs-number">26</span><br><span class="hljs-type">ADD</span> r1,r2,#<span class="hljs-number">0xFF0000</span>     ;; uses <span class="hljs-number">0xFF</span> <span class="hljs-type">ROR</span> <span class="hljs-number">16</span><br>;也可使用 <span class="hljs-type">MVN</span>来进行位反转:<br><span class="hljs-type">MOV</span> r0, #<span class="hljs-number">0xFFFFFFFF</span>  ;; assembles to <span class="hljs-type">MVN</span> r0,#<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h1 id="寄存器寻址"><a class="markdownIt-Anchor" href="#寄存器寻址"></a> 寄存器寻址</h1><ul><li>寄存器寻址就是<code>利用寄存器中的数值作为操作数</code>，这种寻址方式是各类微处理器经常采用的一种方式，也是一种执行效率较高的寻址方式</li></ul><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-type">ADD</span> <span class="hljs-type">R0</span>，<span class="hljs-type">R1</span>，<span class="hljs-type">R2</span>   ；<span class="hljs-type">R0</span>←<span class="hljs-type">R1</span>＋<span class="hljs-type">R2</span><br></code></pre></td></tr></table></figure><h1 id="寄存器间接寻址"><a class="markdownIt-Anchor" href="#寄存器间接寻址"></a> 寄存器间接寻址</h1><ul><li>寄存器间接寻址就是<code>以寄存器中的值作为操作数的地址</code>，而操作数本身存放在存储器中。</li></ul><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-type">LDR</span>  <span class="hljs-type">R0</span>，[<span class="hljs-type">R1</span>]                 ；<span class="hljs-type">R0</span>←[<span class="hljs-type">R1</span>]<br><span class="hljs-type">STR</span>  <span class="hljs-type">R0</span>，[<span class="hljs-type">R1</span>]                 ；[<span class="hljs-type">R1</span>]←<span class="hljs-type">R0</span><br></code></pre></td></tr></table></figure><h1 id="基址变址寻址"><a class="markdownIt-Anchor" href="#基址变址寻址"></a> 基址变址寻址</h1><ul><li>基址变址寻址就是将<code>寄存器（该寄存器一般称作基址寄存器）的内容与指令中给出的地址偏移量相加</code>，从而得到一个操作数的有效地址。</li><li>变址寻址方式常用于访问某基地址附近的地址单元。</li><li>地址偏移量通常有以下三种表示方式<ul><li>常量</li><li>寄存器</li><li>比例</li></ul></li></ul><h2 id="偏移寻址offset-addressing"><a class="markdownIt-Anchor" href="#偏移寻址offset-addressing"></a> 偏移寻址（offset addressing）</h2><p><img src="https://img-blog.csdnimg.cn/20210509163218271.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_1,color_FFFFFF,t_70" alt="" /></p><ul><li>使用一个绝对值不大于4095的数值，可使用带符号数，即在-4095~+4095之间；如：<code>LDR R2, [Rn, #-0x8]</code></li><li>使用寄存器偏移的方法计算偏移量；如：<code>LDR R2, [Rn, -R3]</code></li><li>使用对寄存器移位的方法计算偏移量；如：<code>LDR R2, [Rn, R3,LSL #2]</code></li><li>使用语句标号。如：<code>LDR R2, START ;R2&lt;-[START]</code><ul><li>在这种寻址方式中，<code>程序计算器PC是隐含的基址寄存器</code>，偏移量是语句标号所在的地址和PC（当前正在执行的指令）之间的差值。</li></ul></li></ul><h2 id="事先事后-更新寻址"><a class="markdownIt-Anchor" href="#事先事后-更新寻址"></a> 事先/事后 更新寻址</h2><ul><li>Pre-indexed: <code>STR r0,[r1,#12]!</code><br /><img src="https://img-blog.csdnimg.cn/20210509163704206.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_1,color_FFFFFF,t_70" alt="" /><br /><img src="https://img-blog.csdnimg.cn/20210509163736175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_1,color_FFFFFF,t_70" alt="" /></li><li>Post-indexed: <code>STR r0,[r1],#12</code><br /><img src="https://img-blog.csdnimg.cn/20210509163800772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_1,color_FFFFFF,t_70" alt="" /><br /><img src="https://img-blog.csdnimg.cn/20210509163805228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_1,color_FFFFFF,t_70" alt="" /></li></ul><h1 id="多寄存器寻址"><a class="markdownIt-Anchor" href="#多寄存器寻址"></a> 多寄存器寻址</h1><ul><li>采用多寄存器寻址方式，一条指令可以完成多个寄存器值的传送。<code>这种寻址方式可以用一条指令完成传送最多16个通用寄存器的值。</code></li></ul><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-type">LDMIA</span> <span class="hljs-type">R13</span>，&#123;<span class="hljs-type">R1</span>，<span class="hljs-type">R2</span>，<span class="hljs-type">R3</span>，<span class="hljs-type">R4</span>&#125; <br>；或写成：<span class="hljs-type">LDMIA</span> <span class="hljs-type">R13</span>，&#123;<span class="hljs-type">R1</span>-<span class="hljs-type">R4</span>&#125; <br>；<span class="hljs-type">R1</span>←[<span class="hljs-type">R13</span>] <br>；<span class="hljs-type">R2</span>←[<span class="hljs-type">R13</span>＋<span class="hljs-number">4</span>]<br>；<span class="hljs-type">R3</span>←[<span class="hljs-type">R13</span>＋<span class="hljs-number">8</span>]<br>；<span class="hljs-type">R4</span>←[<span class="hljs-type">R13</span>＋<span class="hljs-number">12</span>]<br></code></pre></td></tr></table></figure><ul><li>该指令的后缀IA表示在每次执行完加载/存储操作后，<code>Rn按字长度增加</code>，因此，指令可将连续存储单元的值传送到R1～R4。<ul><li>IA (increment after) 事后递增方式</li><li>IB (increment before) 事先递增方式</li><li>DA (decrement after) 事后递减方式</li><li>DB (decrement before) 事先递减方式</li></ul></li><li>指令中寄存器和内存单元的对应关系：<code>编号低的寄存器对应于内存中低地址单元，编号高的寄存器对应于内存中高地址单元。</code></li><li><code>当使用IA方式存后需要使用DB方式取（一一对应）</code></li></ul><h1 id="堆栈寻址"><a class="markdownIt-Anchor" href="#堆栈寻址"></a> 堆栈寻址</h1><ul><li>堆栈是一种数据结构，按先进后出（First In Last Out，FILO）的方式工作，使用一个称作堆栈指针的专用寄存器指示当前的操作位置，<code>堆栈指针总是指向栈顶。</code></li><li>当堆栈指针指向最后压入堆栈的数据时，称为<code>满堆栈（Full Stack）</code>，而当堆栈指针指向下一个将要放入数据的空位置时，称为<code>空堆栈（Empty Stack）。</code></li><li>同时，根据堆栈的生成方式，又可以分为<code>递增堆栈（Ascending Stack）</code>和<code>递减堆栈（Decending Stack）</code>，<code>当堆栈由低地址向高地址生成时，称为递增堆栈，当堆栈由高地址向低地址生成时，称为递减堆栈</code>。</li><li>这样就有四种类型的堆栈工作方式，ARM微处理器支持这四种类型的堆栈工作方式，即：<ul><li>满递增堆栈 (FA)：堆栈指针指向最后压入的数据，且由低地址向高地址生成。</li><li>满递减堆栈(FD) ：堆栈指针指向最后压入的数据，且由高地址向低地址生成。</li><li>空递增堆栈(EA) ：堆栈指针指向下一个将要放入数据的空位置，且由低地址向高地址生成。</li><li>空递减堆栈(ED) ：堆栈指针指向下一个将要放入数据的空位置，且由高地址向低地址生成。</li></ul></li></ul><h1 id="相对寻址"><a class="markdownIt-Anchor" href="#相对寻址"></a> 相对寻址</h1><ul><li>与基址变址寻址方式相类似，相对寻址是基址寻址的一种变通。</li><li><code>相对寻址以程序计数器PC的当前值为基地址，指令中的地址标号作为偏移量</code>，将两者相加之后得到操作数的有效地址。</li></ul><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-type">BL</span>  <span class="hljs-type">NEXT</span>      ；跳转到子程序<span class="hljs-type">NEXT</span>处执行<br>              ；跳转地址：<span class="hljs-type">PC</span>+<span class="hljs-type">NEXT</span><br>……                         <br><span class="hljs-type">NEXT</span><br>……                             <br><span class="hljs-type">MOV</span>  <span class="hljs-type">PC</span>，<span class="hljs-type">LR</span>        ；从子程序返回<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>专业课</category>
      
      <category>ARM微处理器编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>arm</tag>
      
      <tag>寻址</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ARM微处理器编程｜指令系统-算术指令</title>
    <link href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B%EF%BD%9C%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/"/>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/ARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B%EF%BD%9C%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F-%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="arm指令"><a class="markdownIt-Anchor" href="#arm指令"></a> ARM指令</h1><h2 id="指令分区"><a class="markdownIt-Anchor" href="#指令分区"></a> 指令分区</h2><p><img src="https://img-blog.csdnimg.cn/20210507191847743.png" alt="" /></p><ul><li>ARM指令代码一般可以分为五个域<ul><li><strong>条件码域</strong>[31:28] ，4位条件码共有16种组合</li><li><strong>指令代码域</strong>[27:20]，除指令编码外、还包含几个很重要的指令特征位和可选后缀的编码</li><li>地址<strong>基址Rn域</strong>[19:16]，4位可编码R0-R15共16个寄存器</li><li><strong>目标或源寄存器Rd域</strong>[15:12]，4位可编码R0-R15共16个寄存器</li><li><strong>地址偏移或操作寄存器、操作数域</strong>[11:0]</li></ul></li></ul><h2 id="指令可选后缀"><a class="markdownIt-Anchor" href="#指令可选后缀"></a> 指令可选后缀</h2><h3 id="s-后缀"><a class="markdownIt-Anchor" href="#s-后缀"></a> S 后缀</h3><ul><li>含义：使用S后缀时，指令执行后程序状态寄存器的条件标志位将刷新；如：<code>ADDS R3,R5,R8</code></li><li>使用范围<ul><li>有些指令不需要加S后缀，在执行时同样可以刷新条件标志位。如：CMP, TEQ, TST等。</li><li>有些指令不会引起条件标志位的变化，如：<code>STR R5, [R7]</code></li></ul></li><li>在书写时，<code>S后缀紧跟在指令助记符后面</code></li></ul><h3 id="后缀"><a class="markdownIt-Anchor" href="#后缀"></a> ！后缀</h3><ul><li>含义：在指令的地址表达式中含有！后缀时，指令执行后，基址寄存器中的地址将发生变化（事先访问方式）</li></ul><blockquote><p>基址寄存器中的地址值 <strong>（指令执行后）</strong> ＝指令执行前的值＋地址偏移量</p></blockquote><ul><li>位置和范围<ul><li>！后缀必须紧跟在表达地址的表达式后面，<code>而地址表达式要有明确的地址偏移量</code></li><li><code>！后缀不能用在R15的后面</code></li><li>当使用在单个地址寄存器后面时，<code>必须确信这个寄存器有隐性的偏移量</code>，如：<code>STMDB R1!, &#123;R3,R14&#125;</code></li></ul></li></ul><h3 id="b-后缀-h-后缀"><a class="markdownIt-Anchor" href="#b-后缀-h-后缀"></a> B 后缀 / H 后缀</h3><ul><li><p>含义：</p><ul><li>B后缀的含义：指令所涉及的数据是一字节，不是一字或半字。</li><li>H后缀的含义：指令所涉及的数据是二字节，不是一字。</li></ul></li><li><p>位置</p><ul><li>B后缀紧跟在指令助记符后面。</li><li>H后缀紧跟在指令助记符后面。</li></ul></li></ul><h3 id="t-后缀"><a class="markdownIt-Anchor" href="#t-后缀"></a> T 后缀</h3><ul><li>含义：指令在特权模式下对存储器的访问，将被存储器看成是用户模式的访问。</li><li>限制：<ul><li>一般只用在字传送和无符号字节传送中</li><li>在用户模式下不可选用，选用是没有意义的</li><li>不能与事先更新寻址一起使用</li></ul></li></ul><h3 id="条件后缀"><a class="markdownIt-Anchor" href="#条件后缀"></a> 条件后缀</h3><p><img src="https://img-blog.csdnimg.cn/20210507193746395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_1,color_FFFFFF,t_70" alt="" /></p><ul><li>被测试条件位有Z、C、N和V</li><li>在汇编语言中，条件码助记符紧接在指令助记符后面，如果既选条件后缀也选S后缀，则书写中“S”排列在后面。</li><li>条件后缀是要测试条件标志位，而S后缀是要刷新条件标志位</li><li>条件后缀要测试的是指令执行前的标志位，而S后缀是依据指令执行的结果改变条件标志</li></ul><h1 id="指令类型"><a class="markdownIt-Anchor" href="#指令类型"></a> 指令类型</h1><h2 id="跳转指令"><a class="markdownIt-Anchor" href="#跳转指令"></a> 跳转指令</h2><h3 id="实现跳转的两种方法"><a class="markdownIt-Anchor" href="#实现跳转的两种方法"></a> 实现跳转的两种方法</h3><ul><li><p>使用专门的跳转指令（短跳转，从当前指令向前或向后的<code>32MB</code>的地址空间的跳转）</p><ul><li>B   跳转指令</li><li>BL  <code>带返回</code>的跳转指令（函数调用）</li><li>BX  <code>带状态切换</code>的跳转指令</li><li>BLX  带返回和状态切换的跳转指令<code>（ARM7不支持）</code></li></ul></li><li><p>直接向程序计数器PC写入跳转地址值（长跳转，可以实现在<code>4GB</code>的地址空间中的任意跳转）</p></li></ul><h3 id="跳转指令的编码"><a class="markdownIt-Anchor" href="#跳转指令的编码"></a> 跳转指令的编码</h3><p><img src="https://img-blog.csdnimg.cn/20210507194515538.png" alt="" /></p><ul><li>存储在跳转指令中的实际值是相对当前PC值的一个<code>偏移量</code>，而不是一个绝对地址</li><li>处理器把偏移量（24 位有符号数）左移两位，进行<code>符号扩展</code>后再与PC相加。</li><li><code>左移两位</code>：机器字长32位，指令中给出的偏移量是按字(32位)寻址的，而PC寄存器的内容按字节(8位)寻址，也就是说假如给出的偏移量是0x0100，那么对应按字节寻址的地址就应该是0x0400，即按字寻址的偏移量的4倍，也就是左移2位，才能与PC内容相加。</li></ul><h3 id="b-指令"><a class="markdownIt-Anchor" href="#b-指令"></a> B 指令</h3><blockquote><p>B{条件}  目标地址</p></blockquote><ul><li>B指令是最简单的跳转指令。一旦遇到一个 B 指令，ARM 处理器将立即跳转到给定的目标地址，从那里继续执行。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210507195444442.png" alt="" /></p><h3 id="bl-指令"><a class="markdownIt-Anchor" href="#bl-指令"></a> BL 指令</h3><blockquote><p>BL{条件} 目标地址</p></blockquote><ul><li>该指令是实现子程序调用的一个基本而常用的手段：跳转之前，会<code>在寄存器R14中保存PC的当前内容（下一条指令）</code>，因此，可以通过<code>将R14(LR) 的内容重新加载到PC中</code>，来返回到跳转指令之后的那个指令处执行。<br /><img src="https://img-blog.csdnimg.cn/20210507195910770.png" alt="" /></li></ul><h3 id="条件跳转"><a class="markdownIt-Anchor" href="#条件跳转"></a> 条件跳转</h3><p><img src="https://img-blog.csdnimg.cn/20210507200035199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><h3 id="bx指令"><a class="markdownIt-Anchor" href="#bx指令"></a> BX指令</h3><blockquote><p>BX{条件}  &lt;Rm&gt;</p></blockquote><ul><li>BX指令跳转到指令中所指定的目标地址，目标地址处的指令既可以是ARM指令，也可以是Thumb指令。</li><li>目标地址处的指令类型由寄存器<Rm>的bit[0]决定。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210507200142574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_1,color_FFFFFF,t_70" alt="" /></p><ul><li>伪代码：<br /><img src="https://img-blog.csdnimg.cn/20210507200217229.png" alt="" /></li></ul><h3 id="blx-指令"><a class="markdownIt-Anchor" href="#blx-指令"></a> BLX 指令</h3><blockquote><p>BLX  目标地址</p></blockquote><ul><li><code>BLX 目标地址</code>指令从ARM指令集跳转到指令中所指定的目标地址，并将处理器的工作状态<code>由ARM状态切换到Thumb状态</code>，该指令同时<code>将PC的当前内容保存到寄存器R14中</code>。</li><li>子程序的返回可以通过将寄存器R14值复制到PC中来完成。</li><li>从ARM到Thumb的状态切换，并可以通过BX R14返回。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210507200710828.png" alt="" /></p><blockquote><p>BLX{条件}   &lt;Rm&gt;</p></blockquote><ul><li><code>BLX&#123;条件&#125; &lt;Rm&gt;</code>指令跳转到指令中所指定的目标地址，目标地址处的指令既可以是ARM指令，也可以是Thumb指令。目标地址处的<code>指令类型由寄存器&lt;Rm&gt;的bit[0]决定</code>。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210507200654385.png" alt="" /></p><h3 id="子程序的返回方法"><a class="markdownIt-Anchor" href="#子程序的返回方法"></a> 子程序的返回方法</h3><ul><li><code>MOV PC, R14</code></li><li><code>BX R14</code></li><li>当子程序入口中使用了<code>STMFD R13!, &#123;&lt;registers&gt;,R14&#125;</code>时，可以用指令<code>LDMFD R13!, &#123;&lt;registers&gt;,PC&#125;</code>返回</li></ul><h2 id="数据处理指令"><a class="markdownIt-Anchor" href="#数据处理指令"></a> 数据处理指令</h2><p><img src="https://img-blog.csdnimg.cn/20210507202528458.png" alt="" /></p><blockquote><p>&lt;操作&gt;{&lt;cond&gt;}{S} Rd, Rn, Operand2</p></blockquote><ul><li>比较指令影响标志位，不指定Rd</li><li>数据搬移不指定Rn</li></ul><p><img src="https://img-blog.csdnimg.cn/20210507202716846.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_1,color_FFFFFF,t_70" alt="" /></p><ul><li>第二个操作数通过桶型移位器送到ALU中。</li></ul><p><img src="https://img-blog.csdnimg.cn/2021050720274189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><h3 id="数据搬移"><a class="markdownIt-Anchor" href="#数据搬移"></a> 数据搬移</h3><h4 id="mov-指令"><a class="markdownIt-Anchor" href="#mov-指令"></a> MOV 指令</h4><p><img src="https://img-blog.csdnimg.cn/20210507202909284.png" alt="" /></p><blockquote><p>MOV{条件}{S} 目的寄存器，源操作数</p></blockquote><ul><li>MOV指令可完成从另一个寄存器、被移位的寄存器或将一个立即数加载到目的寄存器。</li><li>其中S选项决定指令的操作是否影响CPSR中条件标志位的值，当没有S时指令不更新CPSR中条件标志位的值。<ul><li><code>当PC作为目标寄存器且指令中S位被置位时</code>，指令在执行跳转操作的同时，将当前处理器模式的SPSR内容复制到CPSR中。</li><li><code>MOVS PC, LR</code>可以实现从某些异常中断中返回</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20210507203513311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_1,color_FFFFFF,t_70" alt="" /></p><ul><li>指令示例</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">MOV</span>   <span class="hljs-built_in">R1</span>，<span class="hljs-built_in">R0</span> ；将寄存器<span class="hljs-built_in">R0</span>的值传送到寄存器<span class="hljs-built_in">R1</span><br><span class="hljs-keyword">MOV</span>   <span class="hljs-built_in">PC</span>，<span class="hljs-built_in">R14</span> ；将寄存器<span class="hljs-built_in">R14</span>的值传送到<span class="hljs-built_in">PC</span>，常用于子程序返回<br><span class="hljs-keyword">MOV</span>   <span class="hljs-built_in">R1</span>，<span class="hljs-built_in">R0</span>，LSL＃<span class="hljs-number">3</span> ；将寄存器<span class="hljs-built_in">R0</span>的值左移<span class="hljs-number">3</span>位后传送到<span class="hljs-built_in">R1</span><br><span class="hljs-keyword">MOV</span>   <span class="hljs-built_in">R1</span>，＃<span class="hljs-number">123</span> ；将立即数<span class="hljs-number">123</span>传送到<span class="hljs-built_in">R1</span><br></code></pre></td></tr></table></figure><h4 id="mvn-指令"><a class="markdownIt-Anchor" href="#mvn-指令"></a> MVN 指令</h4><blockquote><p>MVN{条件}{S} 目的寄存器，源操作数</p></blockquote><ul><li>MVN指令可完成从另一个寄存器、被移位的寄存器、或将一个立即数加载到目的寄存器。</li><li>与MOV指令不同之处是<code>在传送之前按位被取反了</code>，即把一个<code>被取反的值</code>传送到目的寄存器中。<br /><img src="https://img-blog.csdnimg.cn/20210507203909394.png" alt="" /></li></ul><h3 id="比较指令"><a class="markdownIt-Anchor" href="#比较指令"></a> 比较指令</h3><h4 id="cmp-指令"><a class="markdownIt-Anchor" href="#cmp-指令"></a> CMP 指令</h4><blockquote><p>CMP{条件} 操作数1，操作数2</p></blockquote><ul><li>CMP指令用于把一个寄存器的内容和另一个寄存器的内容或立即数进行<code>比较</code>，同时<code>更新CPSR中条件标志位的值</code>。</li><li>该指令进行一次<code>减法</code>运算，但<code>不存储结果</code>，只更改条件标志位。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210507204150610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><ul><li>指令示例</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">CMP</span>   <span class="hljs-built_in">R1</span>，<span class="hljs-built_in">R0</span>  ；将寄存器<span class="hljs-built_in">R1</span>的值与寄存器<span class="hljs-built_in">R0</span>的值相减，并根据结果设置CPSR的标志位<br><span class="hljs-keyword">CMP</span>   <span class="hljs-built_in">R1</span>，＃<span class="hljs-number">100</span>  ；将寄存器<span class="hljs-built_in">R1</span>的值与立即数<span class="hljs-number">100</span>相减，并根据结果设置CPSR的标志位<br></code></pre></td></tr></table></figure><h4 id="cmn-指令"><a class="markdownIt-Anchor" href="#cmn-指令"></a> CMN 指令</h4><blockquote><p>CMN{条件} 操作数1，操作数2</p></blockquote><ul><li>CMN指令用于<code>把一个寄存器的内容和另一个寄存器的内容或立即数取反后进行比较</code>，同时更新CPSR中条件标志位的值。</li><li>该指令实际完成操作数1和操作数2<code>相加</code>，并根据结果更改条件标志位。<br /><img src="https://img-blog.csdnimg.cn/20210507204332756.png" alt="" /></li><li>指令示例</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">CMN</span>   <span class="hljs-built_in">R1</span>，<span class="hljs-built_in">R0</span> ；将寄存器<span class="hljs-built_in">R1</span>的值与寄存器<span class="hljs-built_in">R0</span>的值相加，并根据结果设置CPSR的标志位<br><span class="hljs-keyword">CMN</span>   <span class="hljs-built_in">R1</span>，＃<span class="hljs-number">100</span>  ；将寄存器<span class="hljs-built_in">R1</span>的值与立即数<span class="hljs-number">100</span>相加，并根据结果设置CPSR的标志位<br></code></pre></td></tr></table></figure><h4 id="tst-指令"><a class="markdownIt-Anchor" href="#tst-指令"></a> TST 指令</h4><blockquote><p>TST{条件} 操作数1，操作数2</p></blockquote><ul><li>TST指令用于把一个寄存器的内容和另一个寄存器的内容或立即数<code>进行按位与运算</code>，并根据运算结果更新CPSR中条件标志位的值。</li><li>操作数1是要测试的数据，而操作数2是一个位掩码，该指令一般用来检测是否设置了特定的位。<code>TST指令用于测试寄存器中某些位是1还是0</code></li></ul><p><img src="https://img-blog.csdnimg.cn/20210507204758117.png" alt="" /></p><ul><li>指令示例</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">TST</span>   <span class="hljs-built_in">R1</span>，＃％<span class="hljs-number">1</span> ；用于测试在寄存器<span class="hljs-built_in">R1</span>中是否设置了最低位（％表示二进制数）<br><span class="hljs-keyword">TST</span>   <span class="hljs-built_in">R1</span>，＃<span class="hljs-number">0xfe</span> ；将寄存器<span class="hljs-built_in">R1</span>的值与立即数<span class="hljs-number">0xfe</span>按位与，并根据结果设置CPSR的标志位<br></code></pre></td></tr></table></figure><h4 id="teq-指令"><a class="markdownIt-Anchor" href="#teq-指令"></a> TEQ 指令</h4><blockquote><p>TEQ{条件} 操作数1，操作数2</p></blockquote><ul><li>TEQ指令用于把一个寄存器的内容和另一个寄存器的内容或立即数进行<code>按位异或运算</code>，并根据运算结果更新CPSR中条件标志位的值。</li><li>TEQ指令通常用于比较操作数1和操作数2<code>是否相等</code><br /><img src="https://img-blog.csdnimg.cn/20210507204931946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_1,color_FFFFFF,t_70" alt="" /></li></ul><h3 id="算术指令"><a class="markdownIt-Anchor" href="#算术指令"></a> 算术指令</h3><h4 id="add-指令"><a class="markdownIt-Anchor" href="#add-指令"></a> ADD 指令</h4><blockquote><p>ADD{条件}{S} 目的寄存器，操作数1，操作数2</p></blockquote><ul><li>ADD指令用于把两个操作数相加，并将结果存放到目的寄存器中。</li><li>操作数1应是一个寄存器，<code>操作数2可以是一个寄存器，被移位的寄存器，或一个立即数</code>。</li><li>指令示例</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">ADD</span>    <span class="hljs-built_in">R0</span>，<span class="hljs-built_in">R1</span>，<span class="hljs-built_in">R2</span>  ； <span class="hljs-built_in">R0</span> = <span class="hljs-built_in">R1</span> + <span class="hljs-built_in">R2</span><br><span class="hljs-keyword">ADD</span>    <span class="hljs-built_in">R0</span>，<span class="hljs-built_in">R1</span>，<span class="hljs-number">#256</span>  ； <span class="hljs-built_in">R0</span> = <span class="hljs-built_in">R1</span> + <span class="hljs-number">256</span><br><span class="hljs-keyword">ADDS</span>   <span class="hljs-built_in">R0</span>，<span class="hljs-built_in">R2</span>，<span class="hljs-built_in">R3</span>，LSL<span class="hljs-number">#1</span>  ； <span class="hljs-built_in">R0</span> = <span class="hljs-built_in">R2</span> + (<span class="hljs-built_in">R3</span> &lt;&lt; <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h4 id="adc-指令"><a class="markdownIt-Anchor" href="#adc-指令"></a> ADC 指令</h4><blockquote><p>ADC{条件}{S} 目的寄存器，操作数1，操作数2</p></blockquote><ul><li>ADC指令用于把两个操作数相加，<code>再加上CPSR中的C条件标志位的值</code>，并将结果存放到目的寄存器中。</li><li>它使用一个进位标志位，这样就可以<code>做比32位大的数的加法，注意不要忘记设置S后缀来更改进位标志。</code></li><li><code>ADC指令和ADD指令联合使用可以实现64位、128位的加法操作</code></li></ul><p><img src="https://img-blog.csdnimg.cn/2021050721045049.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><ul><li>以下指令序列<code>完成两个128位数的加法</code>，第一个数由高到低存放在寄存器R7～R4，第二个数由高到低存放在寄存器R11～R8，运算结果由高到低存放在寄存器R3～R0</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">ADDS</span>   <span class="hljs-built_in">R0</span>，<span class="hljs-built_in">R4</span>，<span class="hljs-built_in">R8</span>     ； 加低端的字<br><span class="hljs-keyword">ADCS</span>   <span class="hljs-built_in">R1</span>，<span class="hljs-built_in">R5</span>，<span class="hljs-built_in">R9</span>     ； 加第二个字，带进位<br><span class="hljs-keyword">ADCS</span>   <span class="hljs-built_in">R2</span>，<span class="hljs-built_in">R6</span>，<span class="hljs-built_in">R10</span>   ； 加第三个字，带进位<br><span class="hljs-keyword">ADC</span>     <span class="hljs-built_in">R3</span>，<span class="hljs-built_in">R7</span>，<span class="hljs-built_in">R11</span>    ； 加第四个字，带进位<br></code></pre></td></tr></table></figure><h4 id="sub-指令"><a class="markdownIt-Anchor" href="#sub-指令"></a> SUB 指令</h4><blockquote><p>SUB{条件}{S} 目的寄存器，操作数1，操作数2</p></blockquote><ul><li>SUB指令用于把操作数1减去操作数2，并将结果存放到目的寄存器中。</li><li>该指令可用于有符号数或无符号数的减法运算。</li></ul><p><img src="https://img-blog.csdnimg.cn/2021050721082463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><ul><li>指令示例</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">SUB</span>     <span class="hljs-built_in">R0</span>，<span class="hljs-built_in">R1</span>，<span class="hljs-built_in">R2</span>   ； <span class="hljs-built_in">R0</span> = <span class="hljs-built_in">R1</span> - <span class="hljs-built_in">R2</span><br><span class="hljs-keyword">SUB</span>     <span class="hljs-built_in">R0</span>，<span class="hljs-built_in">R1</span>，<span class="hljs-number">#256</span>   ； <span class="hljs-built_in">R0</span> = <span class="hljs-built_in">R1</span> - <span class="hljs-number">256</span><br><span class="hljs-keyword">SUBS</span>   <span class="hljs-built_in">R0</span>，<span class="hljs-built_in">R2</span>，<span class="hljs-built_in">R3</span>，LSL<span class="hljs-number">#1</span>  ； <span class="hljs-built_in">R0</span> = <span class="hljs-built_in">R2</span> - (<span class="hljs-built_in">R3</span> &lt;&lt; <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210507210829191.png" alt="" /></p><h4 id="sbc-指令"><a class="markdownIt-Anchor" href="#sbc-指令"></a> SBC 指令</h4><blockquote><p>SBC{条件}{S} 目的寄存器，操作数1，操作数2</p></blockquote><ul><li>SBC指令用于把操作数1减去操作数2，再减去<code>CPSR中的C条件标志位的反码</code>，并将结果存放到目的寄存器中。</li><li>该指令使用进位标志来<code>表示借位</code>，这样就可以做大于32位的减法，注意不要忘记设置S后缀来更改进位标志。</li><li>SBC指令和SUB指令联合使用可以实现64位、128位的减法操作</li></ul><p><img src="https://img-blog.csdnimg.cn/2021050721181143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><ul><li>指令示例</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">SBC</span> <span class="hljs-built_in">R0</span>，<span class="hljs-built_in">R1</span>，<span class="hljs-built_in">R2</span>  ；<span class="hljs-built_in">R0</span> = <span class="hljs-built_in">R1</span> - <span class="hljs-built_in">R2</span> - ！C，并根据结果设置CPSR的进位标志位<br></code></pre></td></tr></table></figure><h4 id="rsb-指令"><a class="markdownIt-Anchor" href="#rsb-指令"></a> RSB 指令</h4><blockquote><p>RSB{条件}{S} 目的寄存器，操作数1，操作数2</p></blockquote><ul><li>RSB指令称为<code>逆向减法指令</code>，用于把操作数2减去操作数1，并将结果存放到目的寄存器中。</li><li>该指令可用于有符号数或无符号数的减法运算。</li><li>指令示例</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">RSB</span>     <span class="hljs-built_in">R0</span>，<span class="hljs-built_in">R1</span>，<span class="hljs-built_in">R2</span>  ； <span class="hljs-built_in">R0</span> = <span class="hljs-built_in">R2</span> – <span class="hljs-built_in">R1</span><br><span class="hljs-keyword">RSB</span>     <span class="hljs-built_in">R0</span>，<span class="hljs-built_in">R1</span>，<span class="hljs-number">#256</span>  ； <span class="hljs-built_in">R0</span> = <span class="hljs-number">256</span> – <span class="hljs-built_in">R1</span><br><span class="hljs-keyword">RSBS</span>   <span class="hljs-built_in">R0</span>，<span class="hljs-built_in">R2</span>，<span class="hljs-built_in">R3</span>，LSL<span class="hljs-number">#1</span>  ； <span class="hljs-built_in">R0</span> = (<span class="hljs-built_in">R3</span> &lt;&lt; <span class="hljs-number">1</span>) - <span class="hljs-built_in">R2</span><br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210507211953772.png" alt="" /></p><h4 id="rsc-指令"><a class="markdownIt-Anchor" href="#rsc-指令"></a> RSC 指令</h4><blockquote><p>RSC{条件}{S} 目的寄存器，操作数1，操作数2</p></blockquote><ul><li>RSC指令用于把操作数2减去操作数1，<code>再减去CPSR中的C条件标志位的反码</code>，并将结果存放到目的寄存器中。</li><li>该指令使用进位标志来表示借位，这样就可以做大于32位的减法，<code>注意不要忘记设置S后缀来更改进位标志。</code></li><li>RSC指令和RSB指令联合使用可以实现64位、128位的减法操作</li><li>指令示例</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">RSC</span>   <span class="hljs-built_in">R0</span>，<span class="hljs-built_in">R1</span>，<span class="hljs-built_in">R2</span>   ； <span class="hljs-built_in">R0</span> = <span class="hljs-built_in">R2</span> – <span class="hljs-built_in">R1</span> - ！C<br></code></pre></td></tr></table></figure><h3 id="逻辑指令"><a class="markdownIt-Anchor" href="#逻辑指令"></a> 逻辑指令</h3><h4 id="and-指令"><a class="markdownIt-Anchor" href="#and-指令"></a> AND 指令</h4><blockquote><p>AND{条件}{S} 目的寄存器，操作数1，操作数2</p></blockquote><ul><li>AND指令用于在两个操作数上进行<code>逻辑与运算</code>，并把结果放置到目的寄存器中。</li><li>该指令常用于<code>屏蔽操作数1的某些位。</code></li><li><code>设置一个掩码值，AND指令可以提取寄存器中某些位的值</code></li></ul><p><img src="https://img-blog.csdnimg.cn/20210507212142185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></p><ul><li>指令示例</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">AND</span>   <span class="hljs-built_in">R0</span>，<span class="hljs-built_in">R0</span>，＃<span class="hljs-number">3</span>   ； 该指令保持<span class="hljs-built_in">R0</span>的<span class="hljs-number">0</span>、<span class="hljs-number">1</span>位，其余位清零。<br></code></pre></td></tr></table></figure><h4 id="orr-指令"><a class="markdownIt-Anchor" href="#orr-指令"></a> ORR 指令</h4><blockquote><p>ORR{条件}{S} 目的寄存器，操作数1，操作数2</p></blockquote><ul><li>ORR指令用于在两个操作数上进行<code>逻辑或</code>运算，并把结果放置到目的寄存器中。</li><li>该指令常用于设置操作数1的某些位。</li><li>设置一个掩码值，ORR指令可以<code>设置寄存器中某些位的值为1</code></li><li>指令示例</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">ORR</span>   <span class="hljs-built_in">R0</span>，<span class="hljs-built_in">R0</span>，＃<span class="hljs-number">3</span> ； 该指令设置<span class="hljs-built_in">R0</span>的<span class="hljs-number">0</span>、<span class="hljs-number">1</span>位，其余位保持不变。<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210507212724896.png" alt="" /></p><h4 id="eor-指令"><a class="markdownIt-Anchor" href="#eor-指令"></a> EOR 指令</h4><blockquote><p>EOR{条件}{S} 目的寄存器，操作数1，操作数2</p></blockquote><ul><li>EOR指令用于在两个操作数上进行<code>逻辑异或运算</code>，并把结果放置到目的寄存器中。</li><li>该指令常用于反转操作数1的某些位。</li><li>设置一个掩码值，EOR指令可以将寄存器中某些位的值<code>取反</code></li><li>指令示例</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">EOR</span>   <span class="hljs-built_in">R0</span>，<span class="hljs-built_in">R0</span>，＃<span class="hljs-number">3</span>   ； 该指令反转<span class="hljs-built_in">R0</span>的<span class="hljs-number">0</span>、<span class="hljs-number">1</span>位，其余位保持不变。<br></code></pre></td></tr></table></figure><h4 id="bic-指令"><a class="markdownIt-Anchor" href="#bic-指令"></a> BIC 指令</h4><blockquote><p>BIC{条件}{S} 目的寄存器，操作数1，操作数2</p></blockquote><ul><li>BIC指令用于<code>清除操作数1的某些位</code>，并把结果放置到目的寄存器中。</li><li>操作数2为32位的掩码，<code>如果在掩码中设置了某一位，则清除这一位，未设置的掩码位保持不变。</code></li><li>设置一个掩码值，BIC指令可以<code>将寄存器中某些位的值设置成0</code></li><li>指令示例</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">BIC</span>   R0，R0，＃％<span class="hljs-number">1011</span>  ； 该指令清除 R0 中的位 <span class="hljs-number">0</span>、<span class="hljs-number">1</span>、和<span class="hljs-number">3</span>，其余的位保持不变。<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210507213750629.jpg" alt="" /></p><h3 id="乘法指令与乘加指令"><a class="markdownIt-Anchor" href="#乘法指令与乘加指令"></a> 乘法指令与乘加指令</h3><ul><li>ARM微处理器支持的乘法指令与乘加指令共有6条，可<code>分为运算结果为32位和运算结果为64位</code>两类，与前面的数据处理指令不同<ul><li><code>指令中的所有操作数、目的寄存器必须为通用寄存器，不能对操作数使用立即数或被移位的寄存器</code></li><li><code>目的寄存器和操作数1必须是不同的寄存器。</code></li></ul></li><li>乘法指令与乘加指令共有以下6条<ul><li>MUL     32位乘法指令</li><li>MLA     32位乘加指令</li><li>SMULL   64位有符号数乘法指令</li><li>SMLAL   64位有符号数乘加指令</li><li>UMULL   64位无符号数乘法指令</li><li>UMLAL   64位无符号数乘加指令</li></ul></li></ul><h4 id="mul-指令"><a class="markdownIt-Anchor" href="#mul-指令"></a> MUL 指令</h4><blockquote><p>MUL{条件}{S} 目的寄存器，操作数1，操作数2</p></blockquote><ul><li>MUL指令完成将操作数1与操作数2的乘法运算，并把结果放置到目的寄存器中，同时可以根据运算结果设置CPSR中相应的条件标志位。<ul><li>其中，操作数1和操作数2<code>均为32位的有符号数或无符号数。</code></li></ul></li><li><code>结果仅保存了64位的低32位</code></li><li>指令示例</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">MUL</span>     <span class="hljs-built_in">R0</span>，<span class="hljs-built_in">R1</span>，<span class="hljs-built_in">R2</span> ；<span class="hljs-built_in">R0</span> = <span class="hljs-built_in">R1</span> × <span class="hljs-built_in">R2</span><br><span class="hljs-keyword">MULS</span>    <span class="hljs-built_in">R0</span>，<span class="hljs-built_in">R1</span>，<span class="hljs-built_in">R2</span> ；<span class="hljs-built_in">R0</span> = <span class="hljs-built_in">R1</span> × <span class="hljs-built_in">R2</span>，同时设置CPSR中的相关条件标志位<br></code></pre></td></tr></table></figure><ul><li>在早期的ARM版本中，<code>如果Rd和Rm是同一寄存器，则该行为是不可预测的。</code>（ARM Wiki和ARM官方文档）。<br /><img src="https://img-blog.csdnimg.cn/20210507215059944.png" alt="" /></li></ul><h4 id="mla-指令"><a class="markdownIt-Anchor" href="#mla-指令"></a> MLA 指令</h4><blockquote><p>MLA{条件}{S}   目的寄存器， 操作数1，操作数2，操作数3</p></blockquote><ul><li>MLA指令完成将操作数1与操作数2的乘法运算，<code>再将乘积加上操作数3</code>，并把结果放置到目的寄存器中，同时可以根据运算结果设置CPSR中相应的条件标志位。</li><li>其中，操作数1和操作数2均为32位的<code>有符号数或无符号数。</code></li><li>指令示例</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">MLA</span>     <span class="hljs-built_in">R0</span>，<span class="hljs-built_in">R1</span>，<span class="hljs-built_in">R2</span>，<span class="hljs-built_in">R3</span>  ；<span class="hljs-built_in">R0</span> = <span class="hljs-built_in">R1</span> × <span class="hljs-built_in">R2</span> + <span class="hljs-built_in">R3</span><br><span class="hljs-keyword">MLAS</span>    <span class="hljs-built_in">R0</span>，<span class="hljs-built_in">R1</span>，<span class="hljs-built_in">R2</span>，<span class="hljs-built_in">R3</span>   ；<span class="hljs-built_in">R0</span> = <span class="hljs-built_in">R1</span> × <span class="hljs-built_in">R2</span> + <span class="hljs-built_in">R3</span>，同时设置CPSR中的相关条件标志位<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210507215506657.png" alt="" /></p><h4 id="smull-指令"><a class="markdownIt-Anchor" href="#smull-指令"></a> SMULL 指令</h4><blockquote><p>SMULL{条件}{S}   目的寄存器Low，目的寄存器低High，操作数1，操作数2</p></blockquote><ul><li>SMULL指令完成将操作数1与操作数2的乘法运算，<code>并把结果的低32位放置到目的寄存器Low中，结果的高32位放置到目的寄存器High中</code>，同时可以根据运算结果设置CPSR中相应的条件标志位。</li><li>其中，操作数1和操作数2均为32位的<code>有符号数。</code></li><li>指令示例</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">SMULL</span> <span class="hljs-built_in">R0</span>，<span class="hljs-built_in">R1</span>，<span class="hljs-built_in">R2</span>，<span class="hljs-built_in">R3</span>  <br>；<span class="hljs-built_in">R0</span> = （<span class="hljs-built_in">R2</span> × <span class="hljs-built_in">R3</span>）的低<span class="hljs-number">32</span>位<br>                ；<span class="hljs-built_in">R1</span> = （<span class="hljs-built_in">R2</span> × <span class="hljs-built_in">R3</span>）的高<span class="hljs-number">32</span>位 <br></code></pre></td></tr></table></figure><h4 id="smlal-指令"><a class="markdownIt-Anchor" href="#smlal-指令"></a> SMLAL 指令</h4><blockquote><p>SMLAL{条件}{S}   目的寄存器Low，目的寄存器低High，操作数1，操作数2</p></blockquote><ul><li>SMLAL指令完成将操作数1与操作数2的乘法运算，<code>并把结果的低32位同目的寄存器Low中的值相加后又放置到目的寄存器Low中，结果的高32位同目的寄存器High中的值相加后又放置到目的寄存器High中</code>，同时可以根据运算结果设置CPSR中相应的条件标志位。</li><li>对于目的寄存器Low，在指令执行前存放64位加数的低32位，指令执行后存放结果的低32位。</li><li>对于目的寄存器High，在指令执行前存放64位加数的高32位，指令执行后存放结果的高32位。</li><li>其中，操作数1和操作数2均为32位的<code>有符号数。</code></li><li>指令示例</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">SMLAL</span> <span class="hljs-built_in">R0</span>，<span class="hljs-built_in">R1</span>，<span class="hljs-built_in">R2</span>，<span class="hljs-built_in">R3</span><br>；<span class="hljs-built_in">R0</span> = （<span class="hljs-built_in">R2</span> × <span class="hljs-built_in">R3</span>）的低<span class="hljs-number">32</span>位 ＋ <span class="hljs-built_in">R0</span><br>                ；<span class="hljs-built_in">R1</span> = （<span class="hljs-built_in">R2</span> × <span class="hljs-built_in">R3</span>）的高<span class="hljs-number">32</span>位 ＋ <span class="hljs-built_in">R1</span> ＋ C<br></code></pre></td></tr></table></figure><h4 id="umull-指令"><a class="markdownIt-Anchor" href="#umull-指令"></a> UMULL 指令</h4><blockquote><p>UMULL{条件}{S}   目的寄存器Low，目的寄存器低High，操作数1，操作数2</p></blockquote><ul><li>UMULL指令完成操作同SMULL</li><li>其中，操作数1和操作数2均为<code>32位的无符号数。</code></li></ul><h4 id="umlal-指令"><a class="markdownIt-Anchor" href="#umlal-指令"></a> UMLAL 指令</h4><blockquote><p>UMLAL{条件}{S}   目的寄存器Low，目的寄存器低High，操作数1，操作数2</p></blockquote><ul><li>UMLAL指令完成操作同SMLAL</li><li>其中，操作数1和操作数2均为<code>32位的无符号数。</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>专业课</category>
      
      <category>ARM微处理器编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>arm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EOJ 3294. WiFi</title>
    <link href="/EOJ%E9%A2%98%E8%A7%A3/eoj-3294/"/>
    <url>/EOJ%E9%A2%98%E8%A7%A3/eoj-3294/</url>
    
    <content type="html"><![CDATA[<p><strong>久违的eoj题解</strong><br /><strong><a href="https://blog.csdn.net/qq_28329417/article/details/113730691?utm_medium=distribute.pc_relevant_t0.none-task-blog-OPENSEARCH-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-OPENSEARCH-1.control">思路来源</a></strong></p><h1 id="题面"><a class="markdownIt-Anchor" href="#题面"></a> <a href="https://acm.ecnu.edu.cn/problem/3294/">题面</a></h1><p><strong>单点时限: 3.0 sec<br />内存限制: 512 MB</strong></p><p>章鱼王沿着国王大道巡视着他强大的王国，国王大道可以被看做一条直线，章鱼王的城堡的位置是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。</p><p>章鱼王知道他的国家里有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个 WiFi 信号发射器，第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个发射器在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 位置，代表章鱼王城堡向东 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 米（若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a_i&lt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 则为向西），WiFi 的强度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，代表 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 处能接收到强度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的信号，而与信号发射器距离每增加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 米，信号强度就减少 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，直到信号为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 就不再减少。</p><p>章鱼王有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span> 个询问，他想知道在国王大道 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 位置处能接收到的最大信号强度。</p><p><strong>输入格式</strong><br />第一行为数据组数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>T</mi><mo>≤</mo><mn>10</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(T\leq 10)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>  。</p><p>每组数据第一行为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">n,q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span> ，第二行为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个数字 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，第三行为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个数字 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，接下来一行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span> 个询问 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p><p>保证 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>40</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">40\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">4</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据满足：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>q</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">1\leq n,q\leq 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>。<br />保证 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据满足：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>q</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo separator="true">,</mo><mn>0</mn><mo>≤</mo><mi mathvariant="normal">∣</mi><msub><mi>a</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo separator="true">,</mo><mn>0</mn><mo>≤</mo><msub><mi>b</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo separator="true">,</mo><mn>0</mn><mo>≤</mo><mi mathvariant="normal">∣</mi><msub><mi>c</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">1\leq n,q\leq 10^5, 0\leq |a_i|\leq 10^9,0\leq b_i\leq 10^9,0\leq |c_i|\leq 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>。</p><p>所有数均为整数。</p><p><strong>输出格式</strong><br />对于每组数据中的每个询问，输出一行结果。</p><p><strong>样例</strong></p><table><thead><tr><th style="text-align:left"><strong>input</strong></th></tr></thead><tbody><tr><td style="text-align:left">1<br>2 3<br>0 6<br>3 6<br>0 -1 5</td></tr><tr><td style="text-align:left"><strong>output</strong></td></tr><tr><td style="text-align:left">3<br>2<br>5</td></tr></tbody></table><h1 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h1><p>假设在位置 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>o</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">pos</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span></span></span></span> 处的WiFi发射器的信号强度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">val</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>，该WiFi发射器在点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 处的信号强度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 。 则可得$$p = val-|x-pos|=\left{\begin{matrix}val+pos-x （x左边） \ val-pos+x（x右边）\end{matrix}\right.$$<br />要求得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 的最大值，即找到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 左边 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mo>+</mo><mi>p</mi><mi>o</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">val+pos</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span></span></span></span> 的最大值和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 右边 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mo>−</mo><mi>p</mi><mi>o</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">val-pos</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span></span></span></span> 的最大值。由于数据规模大，用顺序查找暴搜必然超时，所以采用二分查找。</p><p>对于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>左边的WiFi发射器，有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>−</mo><mi>p</mi><mi>o</mi><mi>s</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x-pos \geq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>=</mo><mi>v</mi><mi>a</mi><mi>l</mi><mo>−</mo><mi>x</mi><mo>+</mo><mi>p</mi><mi>o</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">p = val - x + pos</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span></span></span></span> ，那么我们只需二分查找找到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>≥</mo><mi>p</mi><mi>o</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">x \geq pos</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span></span></span></span>的点在按<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>v</mi><mi>a</mi><mi>l</mi><mo>+</mo><mi>p</mi><mi>o</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(val+pos)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mclose">)</span></span></span></span>键值排序的最后一个符合<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>≥</mo><mi>p</mi><mi>o</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">x \geq pos</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span></span></span></span>的Wifi发射器<br />同理，对于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>右边，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>−</mo><mi>p</mi><mi>o</mi><mi>s</mi><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x-pos &lt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>=</mo><mi>v</mi><mi>a</mi><mi>l</mi><mo>+</mo><mi>x</mi><mo>−</mo><mi>p</mi><mi>o</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">p = val + x - pos</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span></span></span></span>，二分查找找到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>&lt;</mo><mi>p</mi><mi>o</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">x &lt; pos</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span></span></span></span>的点在按<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>v</mi><mi>a</mi><mi>l</mi><mo>−</mo><mi>p</mi><mi>o</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(val-pos)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mclose">)</span></span></span></span>键值排序的最后一个符合<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>&lt;</mo><mi>p</mi><mi>o</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">x &lt; pos</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span></span></span></span> 的Wifi发射器</p><p>但是当我们按照 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mo>−</mo><mi>p</mi><mi>o</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">val-pos</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span></span></span></span> 或者 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mo>+</mo><mi>p</mi><mi>o</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">val + pos</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span></span></span></span> 排序之后，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>o</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">pos</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span></span></span></span>本身在数组中不一定是单调的。我们知道二分的前提是单调性。于是利用单调队列，在不影响原数组的顺序的情况下，处理出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>o</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">pos</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span></span></span></span>的单调性。</p><h1 id="ac代码"><a class="markdownIt-Anchor" href="#ac代码"></a> ac代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br><span class="hljs-type">int</span> pos,val;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node a,node b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(a.pos + a.val != b.pos + b.val)<br><span class="hljs-keyword">return</span> a.pos + a.val &lt; b.pos + b.val;<br><span class="hljs-keyword">return</span> a.pos &gt; b.pos; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp1</span><span class="hljs-params">(node a,node b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (a.val - a.pos != b.val - b.pos)<br><span class="hljs-keyword">return</span> a.val - a.pos &lt; b.val - b.pos;<br><span class="hljs-keyword">return</span> a.pos &lt; b.pos;<br>&#125;<br><br><span class="hljs-type">int</span> n,q;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> T;<br>cin &gt;&gt; T;<br><span class="hljs-keyword">while</span>(T--)<br>&#123;<br>cin &gt;&gt; n &gt;&gt; q;<br>node info[n], info1[n];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>&#123;<br>cin &gt;&gt; info[i].pos;<br>info1[i].pos=info[i].pos;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>&#123;<br>cin &gt;&gt; info[i].val;<br>info1[i].val=info[i].val;<br>&#125;<br><span class="hljs-comment">//按照x左右不同键值排序</span><br><span class="hljs-built_in">sort</span>(info,info+n,cmp);<br><span class="hljs-built_in">sort</span>(info1,info1+n,cmp1);<br><br><span class="hljs-comment">//单调队列，left中的pos递增，right中pos递减。两个队列中键值都是递增</span><br>vector&lt;node&gt; left,right;<br>left.<span class="hljs-built_in">push_back</span>(info[<span class="hljs-number">0</span>]);<br>right.<span class="hljs-built_in">push_back</span>(info1[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)<br>&#123;<br><span class="hljs-type">int</span> rear=left.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">if</span>(info[i].pos &gt; left[rear].pos)<br>&#123;<br>left.<span class="hljs-built_in">push_back</span>(info[i]);<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(info[i].pos &lt; left[rear].pos)<br>&#123;<br><span class="hljs-comment">//pos更小更易满足条件 x &gt;= my[i].pos，且由于已经排序了p1会更大</span><br><span class="hljs-keyword">while</span>(left.<span class="hljs-built_in">size</span>()&amp;&amp;info[i].pos&lt;left[left.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>].pos)<br>left.<span class="hljs-built_in">pop_back</span>();<br>left.<span class="hljs-built_in">push_back</span>(info[i]);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)<br>&#123;<br><span class="hljs-type">int</span> rear=right.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">if</span>(info1[i].pos &lt; right[rear].pos)<br>&#123;<br>right.<span class="hljs-built_in">push_back</span>(info1[i]);<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(info1[i].pos &gt; right[rear].pos)<br>&#123;<br><span class="hljs-comment">//pos更大更易满足条件 x &lt; my[i].pos，且由于已经排序了p2会更大</span><br><span class="hljs-keyword">while</span>(right.<span class="hljs-built_in">size</span>()&amp;&amp;info1[i].pos&gt;right[right.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>].pos)<br>right.<span class="hljs-built_in">pop_back</span>();<br>right.<span class="hljs-built_in">push_back</span>(info1[i]);<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> c;<br><span class="hljs-keyword">while</span>(q--) <br>&#123;<br>cin &gt;&gt; c;<br><span class="hljs-type">int</span> p1=<span class="hljs-number">0</span>,p2=<span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//二分查找</span><br><span class="hljs-type">int</span> l,r;<br>l=<span class="hljs-number">0</span>,r=left.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(l &lt; r)<br>&#123;<br><span class="hljs-type">int</span> mid = (l+r+<span class="hljs-number">1</span>)&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(left[mid].pos&lt;=c)<br>l=mid;<br><span class="hljs-keyword">else</span><br>r=mid<span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(left[l].pos&lt;=c)<br>p1=<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,left[l].pos+left[l].val-c);<br><br>l=<span class="hljs-number">0</span>,r=right.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(l &lt; r)<br>&#123;<br><span class="hljs-type">int</span> mid = (l+r+<span class="hljs-number">1</span>)&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(right[mid].pos&gt;c)<br>l=mid;<br><span class="hljs-keyword">else</span><br>r=mid<span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(right[l].pos&gt;c)<br>p2=<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,right[l].val-right[l].pos+c);<br><br>cout &lt;&lt; <span class="hljs-built_in">max</span>(p1,p2) &lt;&lt; endl;<br>&#125; <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>EOJ题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EOJ</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EOJ 2845.符号方程求解</title>
    <link href="/EOJ%E9%A2%98%E8%A7%A3/EOJ%202845.%E7%AC%A6%E5%8F%B7%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3/"/>
    <url>/EOJ%E9%A2%98%E8%A7%A3/EOJ%202845.%E7%AC%A6%E5%8F%B7%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<!--more--><h1 id="题面"><a class="markdownIt-Anchor" href="#题面"></a> 题面</h1><p><strong>单点时限:</strong> 2.0 sec<br /><strong>内存限制:</strong> 256 MB</p><p>解一元一次方程，输出方程的解（精确至小数点后 3 位）。</p><p>例如，以下是几个一元一次方程的实例:<br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn><mo>+</mo><mn>3</mn><mi>x</mi><mo>=</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">4+3x=8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span><br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn><mi>a</mi><mo>−</mo><mn>5</mn><mo>+</mo><mn>1</mn><mo>=</mo><mn>2</mn><mo>−</mo><mn>2</mn><mi>a</mi></mrow><annotation encoding="application/x-tex">6a-5+1=2-2a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault">a</span></span></span></span><br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>5</mn><mo>+</mo><mn>12</mn><mi>y</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">-5+12y=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span><br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo><mi>a</mi><mo>−</mo><mi>a</mi><mo>−</mo><mi>a</mi><mo>−</mo><mi>a</mi><mo>−</mo><mi>a</mi><mo>−</mo><mi>a</mi><mo>−</mo><mi>a</mi><mo>−</mo><mi>a</mi><mo>−</mo><mi>a</mi><mo>−</mo><mi>a</mi><mo>−</mo><mi>a</mi><mo>−</mo><mi>a</mi><mo>−</mo><mi>a</mi><mo>−</mo><mi>a</mi><mo>−</mo><mi>a</mi><mo>−</mo><mi>a</mi><mo>−</mo><mi>a</mi><mo>−</mo><mi>a</mi><mo>−</mo><mi>a</mi><mo>−</mo><mi>a</mi><mo>−</mo><mi>a</mi><mo>−</mo><mi>a</mi><mo>+</mo><mn>1098</mn><mo>=</mo><mn>123</mn><mo>−</mo><mn>1245</mn><mo>+</mo><mn>23712</mn><mo>−</mo><mn>1</mn><mo>−</mo><mn>1</mn><mo>−</mo><mn>0</mn><mo>−</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">+a-a-a-a-a-a-a-a-a-a-a-a-a-a-a-a-a-a-a-a-a-a+1098=123-1245+23712-1-1-0-20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">+</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">9</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">4</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord">3</span><span class="mord">7</span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span><br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mi>x</mi><mo>−</mo><mi>x</mi><mo>−</mo><mi>x</mi><mo>−</mo><mi>x</mi><mo>−</mo><mi>x</mi><mo>−</mo><mi>x</mi><mo>−</mo><mi>x</mi><mo>−</mo><mn>101</mn><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">-x-x-x-x-x-x-x-101=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span><br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>−</mo><mn>1</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">y-1=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span><br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">1=x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span><br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>6</mn><mi>c</mi><mo>−</mo><mn>5</mn><mi>c</mi><mo>+</mo><mn>1</mn><mo>=</mo><mn>2</mn><mo>−</mo><mn>2</mn><mi>c</mi></mrow><annotation encoding="application/x-tex">-6c-5c+1=2-2c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">6</span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault">c</span></span></span></span></p><p>在方程中，只包含整数、小写字母及+、-、= 三个符号（符号 - 既可作减号，也可作负号）。方程中没有括号，也没有除号，方程中的小写字母表示要求解的未知数。</p><p>输入保证一元一次方程均为合法的，且有唯一实数解。</p><p><strong>输入格式</strong><br />一行信息，是一个合法的一元一次方程。行的长度小于 80。</p><p><strong>输出格式</strong><br />一行信息，是方程的解。格式参考输出例子。</p><p><strong>样例</strong></p><table><thead><tr><th style="text-align:left"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>n</mi><mi>p</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">input</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span></th></tr></thead><tbody><tr><td style="text-align:left">6a-5+1=2-2a</td></tr><tr><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mi>u</mi><mi>t</mi><mi>p</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">output</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span></td></tr><tr><td style="text-align:left">a=0.750</td></tr></tbody></table><h1 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h1><p>解一元一次方程，就只要得到常数项的大小和未知数系数大小然后做除法。<br />在处理输入的方程的时候，就按照符号出现顺序来处理，用flag标记是在等号左边还是右边，注意等号两边的符号变化。约等于做一个移项。<br />这个多项式的处理方法就得记住一下，不然每次都硬推。</p><h1 id="ac代码"><a class="markdownIt-Anchor" href="#ac代码"></a> ac代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_data</span><span class="hljs-params">(string s,<span class="hljs-type">int</span> &amp;a,<span class="hljs-type">int</span> &amp;b,<span class="hljs-type">char</span> &amp;k)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> ceof;<br><span class="hljs-type">int</span> sign=<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> flag=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(s[i])<br>&#123;<br>ceof=<span class="hljs-number">0</span>,sign=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;+&#x27;</span>)<br>&#123;<br>sign=<span class="hljs-number">1</span>;<br>i++;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;-&#x27;</span>)<br>&#123;<br>sign=<span class="hljs-number">-1</span>;<br>i++;<br>&#125;<br><span class="hljs-keyword">if</span>(s[i]&gt;=<span class="hljs-string">&#x27;a&#x27;</span>&amp;&amp;s[i]&lt;=<span class="hljs-string">&#x27;z&#x27;</span>)<br>&#123;<br>k=s[i];<br>ceof=<span class="hljs-number">1</span>;<br>i++;<br><span class="hljs-keyword">if</span>(flag)<br>a+=sign*ceof;<br><span class="hljs-keyword">else</span><br>a-=sign*ceof;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;s[i]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)<br>&#123;<br><span class="hljs-keyword">while</span>(s[i]&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;s[i]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)<br>&#123;<br>ceof=ceof*<span class="hljs-number">10</span>+s[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>i++;<br>&#125;<br><span class="hljs-keyword">if</span>(s[i]&gt;=<span class="hljs-string">&#x27;a&#x27;</span>&amp;&amp;s[i]&lt;=<span class="hljs-string">&#x27;z&#x27;</span>)<br>&#123;<br>k=s[i];<br><span class="hljs-keyword">if</span>(flag)<br>a+=sign*ceof;<br><span class="hljs-keyword">else</span><br>a-=sign*ceof;<br>i++; <br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span>(flag)<br>b-=sign*ceof;<br><span class="hljs-keyword">else</span><br>b+=sign*ceof;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;=&#x27;</span>)<br>&#123;<br>flag=<span class="hljs-number">0</span>;<br>i++;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>string s;<br>cin &gt;&gt; s;<br><span class="hljs-type">int</span> ceof=<span class="hljs-number">0</span>,cons=<span class="hljs-number">0</span>;<br><span class="hljs-type">char</span> c;<br><span class="hljs-built_in">get_data</span>(s,ceof,cons,c);<br><span class="hljs-type">double</span> res;<br>res=(<span class="hljs-type">double</span>)cons/(<span class="hljs-type">double</span>)ceof;<br>cout.<span class="hljs-built_in">precision</span>(<span class="hljs-number">3</span>);<br>cout &lt;&lt; c &lt;&lt; <span class="hljs-string">&quot;=&quot;</span> &lt;&lt; fixed &lt;&lt; res;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>EOJ题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EOJ</tag>
      
      <tag>实训</tag>
      
      <tag>多项式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EOJ 2891. 多次函数</title>
    <link href="/EOJ%E9%A2%98%E8%A7%A3/EOJ%202891.%20%E5%A4%9A%E6%AC%A1%E5%87%BD%E6%95%B0/"/>
    <url>/EOJ%E9%A2%98%E8%A7%A3/EOJ%202891.%20%E5%A4%9A%E6%AC%A1%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<!--more--><h1 id="题面"><a class="markdownIt-Anchor" href="#题面"></a> <a href="https://acm.ecnu.edu.cn/problem/2891/">题面</a></h1><p><strong>单点时限: 2.0 sec<br />内存限制: 256 MB</strong></p><p>在一个平面坐标系统中显示一个多次函数的图像。</p><p>为简化起见，设多次函数的最大次数为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>，系数最多为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 位数。函数表示为： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>c</mi><mn>3</mn></msub><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><msub><mi>c</mi><mn>2</mn></msub><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msub><mi>c</mi><mn>1</mn></msub><mi>x</mi><mo>+</mo><msub><mi>c</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">f(x)=c_3x^3+c_2x^2+c_1x+c_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.964108em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.964108em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 。给出的函数是最简形式。 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 时可省略， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">c_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 为正数时可省略 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo></mrow><annotation encoding="application/x-tex">+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">+</span></span></span></span> ，次方为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 时可省略 ^1。</p><p>坐标系统的 x 轴和 y 轴范围限制在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mn>20</mn><mo separator="true">,</mo><mn>20</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[-20,20]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">2</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> ，具体格式见样例。</p><p><strong>输入格式</strong><br />不多于 20 行，每行一个最多为 3 次的函数。形式： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>c</mi><mn>3</mn></msub><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><msub><mi>c</mi><mn>2</mn></msub><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msub><mi>c</mi><mn>1</mn></msub><mi>x</mi><mo>+</mo><msub><mi>c</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">f(x)=c_3x^3+c_2x^2+c_1x+c_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.964108em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.964108em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 。</p><p><strong>输出格式</strong><br />显示每个函数的图像。两个函数之间用一个空行分隔，最后一个函数之后没有空行。</p><p><strong>样例</strong><br />略</p><h1 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h1><ul><li>把整个解题分为：多项式处理，计算，绘图。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">slove</span><span class="hljs-params">(<span class="hljs-type">char</span> s[])</span></span>;<br><span class="hljs-built_in">Solution</span>();<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">char</span> s[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> ceof[<span class="hljs-number">4</span>];<br><span class="hljs-type">char</span> dot[<span class="hljs-number">41</span>][<span class="hljs-number">41</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>处理多项式的思路和<a href="https://acm.ecnu.edu.cn/problem/2/">一元多项式乘法</a>那题类似，按照元素出现顺序依次处理，将系数按照指数大小存进ceof数组。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Solution::read</span><span class="hljs-params">(<span class="hljs-type">char</span> s[])</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> ceoft,exp;<br><span class="hljs-type">int</span> sign=<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> i=<span class="hljs-number">5</span>;<br><span class="hljs-keyword">while</span>(s[i])<br>&#123;<br>ceoft=<span class="hljs-number">0</span>,exp=<span class="hljs-number">0</span>,sign=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;+&#x27;</span>)<br>&#123;<br>sign=<span class="hljs-number">1</span>;<br>i++;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;-&#x27;</span>)<br>&#123;<br>sign=<span class="hljs-number">-1</span>;<br>i++;<br>&#125;<br><span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;x&#x27;</span>)<br>&#123;<br>ceoft=<span class="hljs-number">1</span>;<br>i++;<br><span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;^&#x27;</span>)<br>&#123;<br>i++;<br><span class="hljs-keyword">while</span>(s[i]&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;s[i]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)<br>&#123;<br>exp=exp*<span class="hljs-number">10</span>+s[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>i++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>exp=<span class="hljs-number">1</span>;<br>&#125;<br>ceof[exp]=sign*ceoft;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;s[i]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)<br>&#123;<br><span class="hljs-keyword">while</span>(s[i]&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;s[i]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)<br>&#123;<br>ceoft=ceoft*<span class="hljs-number">10</span>+s[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>i++;<br>&#125;<br><span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;x&#x27;</span>)<br>&#123;<br>i++;<br><span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;^&#x27;</span>)<br>&#123;<br>i++;<br><span class="hljs-keyword">while</span>(s[i]&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;s[i]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)<br>&#123;<br>exp=exp*<span class="hljs-number">10</span>+s[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>i++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>exp=<span class="hljs-number">1</span>;<br>&#125;<br>ceof[exp]=sign*ceoft;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>exp=<span class="hljs-number">0</span>;<br>ceof[exp]=sign*ceoft;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>因为次数最高只有三次，所以可以手动乘而不需要把各项的指数分别记录下来。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Solution::slove</span><span class="hljs-params">(<span class="hljs-type">char</span> s[])</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">read</span>(s);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">-20</span>;i&lt;<span class="hljs-number">21</span>; i++)<br>    &#123;<br>    <span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<br>        num=ceof[<span class="hljs-number">3</span>]*i*i*i+ceof[<span class="hljs-number">2</span>]*i*i+ceof[<span class="hljs-number">1</span>]*i+ceof[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span>(num&gt;<span class="hljs-number">-21</span> &amp;&amp; num&lt;<span class="hljs-number">21</span>) dot[<span class="hljs-number">20</span>-num][i+<span class="hljs-number">20</span>]=<span class="hljs-string">&#x27;*&#x27;</span>;<br>    &#125;<br><span class="hljs-built_in">print</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>把坐标系的初始化工作交给构造函数来做，注意一定要仔细，不然容易出错，最后计算完之后一起输出。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Solution::<span class="hljs-built_in">Solution</span>()<br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">41</span>; i++)<span class="hljs-comment">//初始化坐标系</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">41</span>; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">20</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(j==<span class="hljs-number">20</span>) dot[i][j]=<span class="hljs-string">&#x27;+&#x27;</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j==<span class="hljs-number">40</span>) dot[i][j]=<span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">else</span> dot[i][j]=<span class="hljs-string">&#x27;-&#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j==<span class="hljs-number">20</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>) dot[i][j]=<span class="hljs-string">&#x27;^&#x27;</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i==<span class="hljs-number">20</span>) dot[i][j]=<span class="hljs-string">&#x27;+&#x27;</span>;<br>                <span class="hljs-keyword">else</span> dot[i][j]=<span class="hljs-string">&#x27;|&#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> dot[i][j]=<span class="hljs-string">&#x27;.&#x27;</span>;<br>        &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<br>    ceof[i]=<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Solution::print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">41</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">41</span>; j++) <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,dot[i][j]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>因为题目对于最后的换行有要求，所以设置了一个check变量来检测是否到了EOF，是否要输出换行。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> s[<span class="hljs-number">30</span>];<br><span class="hljs-type">int</span> check=<span class="hljs-number">0</span>;<br>check=<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s);<br><span class="hljs-keyword">while</span>(check!=EOF)<br>    &#123;<br>        Solution k;<br>        k.<span class="hljs-built_in">slove</span>(s);<br>        check=<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s);<br>        <span class="hljs-keyword">if</span>(check!=EOF) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="ac代码"><a class="markdownIt-Anchor" href="#ac代码"></a> ac代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">slove</span><span class="hljs-params">(<span class="hljs-type">char</span> s[])</span></span>;<br><span class="hljs-built_in">Solution</span>();<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">char</span> s[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> ceof[<span class="hljs-number">4</span>];<br><span class="hljs-type">char</span> dot[<span class="hljs-number">41</span>][<span class="hljs-number">41</span>];<br>&#125;;<br><br>Solution::<span class="hljs-built_in">Solution</span>()<br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">41</span>; i++)<span class="hljs-comment">//画坐标系</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">41</span>; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">20</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(j==<span class="hljs-number">20</span>) dot[i][j]=<span class="hljs-string">&#x27;+&#x27;</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j==<span class="hljs-number">40</span>) dot[i][j]=<span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>                <span class="hljs-keyword">else</span> dot[i][j]=<span class="hljs-string">&#x27;-&#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j==<span class="hljs-number">20</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>) dot[i][j]=<span class="hljs-string">&#x27;^&#x27;</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i==<span class="hljs-number">20</span>) dot[i][j]=<span class="hljs-string">&#x27;+&#x27;</span>;<br>                <span class="hljs-keyword">else</span> dot[i][j]=<span class="hljs-string">&#x27;|&#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> dot[i][j]=<span class="hljs-string">&#x27;.&#x27;</span>;<br>        &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<br>    ceof[i]=<span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Solution::slove</span><span class="hljs-params">(<span class="hljs-type">char</span> s[])</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">read</span>(s);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">-20</span>;i&lt;<span class="hljs-number">21</span>; i++)<br>    &#123;<br>    <span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<br>        num=ceof[<span class="hljs-number">3</span>]*i*i*i+ceof[<span class="hljs-number">2</span>]*i*i+ceof[<span class="hljs-number">1</span>]*i+ceof[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span>(num&gt;<span class="hljs-number">-21</span> &amp;&amp; num&lt;<span class="hljs-number">21</span>) dot[<span class="hljs-number">20</span>-num][i+<span class="hljs-number">20</span>]=<span class="hljs-string">&#x27;*&#x27;</span>;<br>    &#125;<br><span class="hljs-built_in">print</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Solution::print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">41</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">41</span>; j++) <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,dot[i][j]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Solution::read</span><span class="hljs-params">(<span class="hljs-type">char</span> s[])</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> ceoft,exp;<br><span class="hljs-type">int</span> sign=<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> i=<span class="hljs-number">5</span>;<br><span class="hljs-keyword">while</span>(s[i])<br>&#123;<br>ceoft=<span class="hljs-number">0</span>,exp=<span class="hljs-number">0</span>,sign=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;+&#x27;</span>)<br>&#123;<br>sign=<span class="hljs-number">1</span>;<br>i++;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;-&#x27;</span>)<br>&#123;<br>sign=<span class="hljs-number">-1</span>;<br>i++;<br>&#125;<br><span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;x&#x27;</span>)<br>&#123;<br>ceoft=<span class="hljs-number">1</span>;<br>i++;<br><span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;^&#x27;</span>)<br>&#123;<br>i++;<br><span class="hljs-keyword">while</span>(s[i]&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;s[i]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)<br>&#123;<br>exp=exp*<span class="hljs-number">10</span>+s[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>i++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>exp=<span class="hljs-number">1</span>;<br>&#125;<br>ceof[exp]=sign*ceoft;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;s[i]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)<br>&#123;<br><span class="hljs-keyword">while</span>(s[i]&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;s[i]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)<br>&#123;<br>ceoft=ceoft*<span class="hljs-number">10</span>+s[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>i++;<br>&#125;<br><span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;x&#x27;</span>)<br>&#123;<br>i++;<br><span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;^&#x27;</span>)<br>&#123;<br>i++;<br><span class="hljs-keyword">while</span>(s[i]&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;s[i]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)<br>&#123;<br>exp=exp*<span class="hljs-number">10</span>+s[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>i++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>exp=<span class="hljs-number">1</span>;<br>&#125;<br>ceof[exp]=sign*ceoft;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>exp=<span class="hljs-number">0</span>;<br>ceof[exp]=sign*ceoft;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> s[<span class="hljs-number">30</span>];<br><span class="hljs-type">int</span> check=<span class="hljs-number">0</span>;<br>check=<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s);<br><span class="hljs-keyword">while</span>(check!=EOF)<br>    &#123;<br>        Solution k;<br>        k.<span class="hljs-built_in">slove</span>(s);<br>        check=<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s);<br>        <span class="hljs-keyword">if</span>(check!=EOF) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>EOJ题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EOJ</tag>
      
      <tag>实训</tag>
      
      <tag>多项式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EOJ 3126. 商品推荐</title>
    <link href="/EOJ%E9%A2%98%E8%A7%A3/EOJ%203126.%20%E5%95%86%E5%93%81%E6%8E%A8%E8%8D%90/"/>
    <url>/EOJ%E9%A2%98%E8%A7%A3/EOJ%203126.%20%E5%95%86%E5%93%81%E6%8E%A8%E8%8D%90/</url>
    
    <content type="html"><![CDATA[<!--more--><blockquote><p>一道easy实训题，依然是排序，主要还是熟悉熟悉cmp函数的编写</p></blockquote><h1 id="题面"><a class="markdownIt-Anchor" href="#题面"></a> 题面</h1><p><strong>单点时限:</strong> 2.0 sec</p><p><strong>内存限制:</strong> 256 MB</p><p>一个电子商务网站要向顾客推荐商品，可以让顾客指定规则。</p><p>现在某类顾客指定的规则是：对于同一类商品，如果一个商品的销量高于所有该类商品销量的中位数，并且价格低于所有该类商品价格的中位数 *，则向他推荐，显示商品编号，销量和价格。</p><p>如果有多个商品符合要求，推荐的顺序是按销量从大到小排序，销量一样则按价格从低到高排序。如果销量价格都一样，按输入顺序排序。如果没有符合要求的商品，则提示不推荐，显示no recommendation。</p><ul><li>List item</li></ul><p>中位数定义：<br />一组数据  按从小到大（或从大到小）的顺序排列，如果数据个数 n 为奇数（即，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>2</mn><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n=2k+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>），则排在中间位置（第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个）的数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a_k+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>为中位数；如果数据个数为偶数（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>2</mn><mi>k</mi></mrow><annotation encoding="application/x-tex">n=2k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>），则取最中间两个数据的平均值为中位数即，第k位和第k+1位两个数的平均值为中位数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mi>k</mi></msub><mo>+</mo><msub><mi>a</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">(a_k+a_{k+1})/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span>。</p><p><strong>输入格式</strong><br />第 1 行：一个整数  () 为问题数。</p><p>对于每一组测试数据按如下格式输入：</p><p>第 1 行：1 个正整数 ()，表示商品的个数</p><p>第 2 行 ∽n+1 行：商品编号（不超过 9 个字符），销量（非负整数，在 32 位整型表示以内）和价格（非负数，在 32 位浮点型表示以内）。</p><p>数据之间用一个空格分隔。</p><p><strong>输出格式</strong><br />对于每个问题，输出一行问题的编号（0 开始编号，格式：case #0: 等）。</p><p>然后对应每个问题，按符合条件的商品数目，每行输出一组商品编号，销量和价格，格式与输入时一样。无符合的则显示no recommendation。</p><p><strong>样例</strong></p><table><thead><tr><th style="text-align:left">input</th></tr></thead><tbody><tr><td style="text-align:left">3<br>2<br>11 2 7<br>12 1 6<br>5<br>e01 0 7<br>e02 87 5.5<br>e03 8 10<br>e04 97 6<br>e05 55 8<br>8<br>a100 201 23.0<br>a101 518 19.7<br>a102 289 36.7<br>a103 218 22.9<br>a104 37 1.2<br>a105 515 42.0<br>a106 577 25.6<br>a107 136 44.5</td></tr><tr><td style="text-align:left">output</td></tr><tr><td style="text-align:left">case #0:<br>no recommendation<br>case #1:<br>e04 97 6<br>e02 87 5.5<br>case #2:<br>a101 518 19.7</td></tr></tbody></table><h1 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h1><p>首先定义一个商品类。因为题目要求原样输出价格，干脆把商品编号，销量和价格全部按照字符串来读入和存放。同时为了之后排序方便，又维护了 flag 变量，判断是否合乎标准，还有次序，价格和销量由于之后的排序。<br />分别用两个数组来存销量和价格，编写cmpa用于数组排序，之后就可以按照公式得到价格和销量的中位数值。遍历结构体数组，查找符合要求的商品，并把flag设置为1。<br />然后编写cmpb函数按照是否合规、销量、价格和输入次序的优先级给结构体数组排序，最后输出。</p><h1 id="ac代码"><a class="markdownIt-Anchor" href="#ac代码"></a> ac代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Goods</span><br>&#123;<br>    <span class="hljs-type">char</span> id[<span class="hljs-number">10</span>],amount[<span class="hljs-number">100</span>],price[<span class="hljs-number">100</span>];<br>    <span class="hljs-type">int</span> flag,cnt;<br>    <span class="hljs-type">double</span> pri,amo;<br>&#125;a[<span class="hljs-number">101</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cmpa</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *a,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> x,y;<br>    x=*((<span class="hljs-type">double</span> *)a);<br>    y=*((<span class="hljs-type">double</span> *)b);<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">100000</span>*x<span class="hljs-number">-100000</span>*y);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cmpb</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *a,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Goods</span> x,y;<br>    x=*((<span class="hljs-keyword">struct</span> Goods *)a);<br>    y=*((<span class="hljs-keyword">struct</span> Goods *)b);<br>    <span class="hljs-keyword">if</span>(x.flag!=y.flag) <span class="hljs-keyword">return</span> y.flag-x.flag;<br>    <span class="hljs-keyword">if</span>(x.amo!=y.amo) <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)<span class="hljs-number">100</span>*y.amo<span class="hljs-number">-100</span>*x.amo;<br>    <span class="hljs-keyword">if</span>(x.pri!=y.pri) <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)<span class="hljs-number">100</span>*x.pri<span class="hljs-number">-100</span>*y.pri;<br>    <span class="hljs-keyword">return</span> x.cnt-y.cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i,T;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;T);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;T;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> n;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>        <span class="hljs-type">int</span> j;<br>        <span class="hljs-type">double</span> pr[<span class="hljs-number">101</span>],am[<span class="hljs-number">101</span>];<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>        &#123;<br>            a[j].cnt=j;<br>            a[j].flag=<span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s %s %s&quot;</span>,a[j].id,a[j].amount,a[j].price);<br>            a[j].pri=<span class="hljs-built_in">atof</span>(a[j].price);<br>            pr[j]=a[j].pri;<br>            a[j].amo=<span class="hljs-built_in">atof</span>(a[j].amount);<br>            am[j]=a[j].amo;<br>        &#125;<br><br>        <span class="hljs-built_in">qsort</span>(am,n,<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>),cmpa);<br>        <span class="hljs-built_in">qsort</span>(pr,n,<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>),cmpa);<br><br>        <span class="hljs-type">double</span> midam,midpr;<br>        <span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>)<br>        &#123;<br>            midam=am[n/<span class="hljs-number">2</span>];<br>            midpr=pr[n/<span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            midam=(am[n/<span class="hljs-number">2</span>]+am[n/<span class="hljs-number">2</span><span class="hljs-number">-1</span>])/<span class="hljs-number">2.0</span>;<br>            midpr=(pr[n/<span class="hljs-number">2</span>]+pr[n/<span class="hljs-number">2</span><span class="hljs-number">-1</span>])/<span class="hljs-number">2.0</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(a[j].amo&gt;midam&amp;&amp;a[j].pri&lt;midpr)<br>            &#123;<br>                a[j].flag=<span class="hljs-number">1</span>;<br>                num++;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                a[j].flag=<span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;case #%d:\n&quot;</span>,i);<br><br>        <span class="hljs-keyword">if</span>(num==<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;no recommendation\n&quot;</span>);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">qsort</span>(a,n,<span class="hljs-built_in">sizeof</span>(a[<span class="hljs-number">0</span>]),cmpb);<br>            <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;num;j++)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %s %s\n&quot;</span>,a[j].id,a[j].amount,a[j].price);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>EOJ题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EOJ</tag>
      
      <tag>实训</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EOJ 2015. 自修室</title>
    <link href="/EOJ%E9%A2%98%E8%A7%A3/EOJ%202015.%20%E8%87%AA%E4%BF%AE%E5%AE%A4/"/>
    <url>/EOJ%E9%A2%98%E8%A7%A3/EOJ%202015.%20%E8%87%AA%E4%BF%AE%E5%AE%A4/</url>
    
    <content type="html"><![CDATA[<!--more--><h1 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h1><p><strong>单点时限:</strong> 2.0 sec</p><p><strong>内存限制:</strong> 256 MB</p><p>一直不去自修室的 Rocker 最近迫于学习压力决定每天都要去自修，鉴于自修室多多，何必与人争挤，所以 Rocker 要坐在左右一个座位都没人，如果不是第一排，那么他的前面一个座位也没有人的位置上，当然 Rocker 也可以坐在墙边但前面或左边或右边有座位的话要没有人才可以。</p><p>Rocker 眼力异常好，只要在门口瞟一眼就可以知道哪个位置上有人哪个没有人，但 Rocker 大脑毕竟不像电脑可以迅速计算出这间教室有没有符合他要求的位置，所以请你写一个程序帮助他。</p><p><strong>输入格式</strong><br />输入有多个 case，每个 case 第一行有一个数 n 表示自修室的总间数，接下来描述 n(n⩽100) 个自修室的座位情况，接下来按照 Rocker 对于每间自修室，第一行有四个整数 ID,Dis,R,C(Dis⩽2000000,5⩽R,C⩽15)，分别是教室的门号，教室距离 Rocker 寝室的距离，座位的行数以及列数。接下来是一个 R∗C 的 0-1 矩阵，0 表示该座位没有人，1 表示有人。(每间教室 ID，Dis 互异)，Rocker 按照距离远近依次找教室自修，去距离寝室最近的一间满足他条件的教室自修。</p><p><strong>输出格式</strong><br />每个 case 输出一行，如果 Rocker 可以自修的教室 ID，若无教室符合条件，输出 “Bad Luck,Rocker!”</p><p><strong>样例</strong></p><table><thead><tr><th style="text-align:left">input</th></tr></thead><tbody><tr><td style="text-align:left">2<br>4110 16 15 15<br>111111111111111<br>111111111111111<br>111111111111111<br>111111111111111<br>111111111111111<br>111111111111111<br>111111111111111<br>111111111111111<br>111111111111111<br>111111111111111<br>111111111111111<br>111111111111111<br>111111111111111<br>111111111111111<br>111111111111111<br>4102 15 14 15<br>111111111111111<br>111111111111111<br>111111111111111<br>111111111111111<br>111111111111111<br>111111101111111<br>111111000011111<br>111111111111111<br>111111111111111<br>111111111111111<br>111111111111111<br>111111111111111<br>111111111111111<br>111111111111111</td></tr><tr><td style="text-align:left">output</td></tr><tr><td style="text-align:left">4102</td></tr></tbody></table><h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1><p>思路很清晰了，做一个 Room 的结构体，包含ID，Dis，和Flag（即是否符合）三个成员。<br />然后按字符串逐行读入每个自习室。为了避免两边和第一排的讨论，我们首先就审清一个最大的20*20的二维数组，并且将其初始化为‘0’，确保边界都是空状态。<br />然后只要按照题目要求来遍历，搜索到目标空位就把flag设置为1（可坐）。<br />所有的自习室都输入完之后按照距离远近排序，最后将距离最近的，flag为1的自习室ID输出即可，若不存在就输出对应字符串。</p><h1 id="ac代码"><a class="markdownIt-Anchor" href="#ac代码"></a> ac代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Room</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> id,dis,flag;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *a,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Room</span> x,y;<br>    x=*((<span class="hljs-keyword">struct</span> Room *)a);<br>    y=*((<span class="hljs-keyword">struct</span> Room *)b);<br>    <span class="hljs-keyword">if</span>(x.dis-y.dis&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n)!=EOF)<br>    &#123;<br>        <span class="hljs-type">int</span> i,j,k;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Room</span> a[<span class="hljs-number">101</span>];<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        &#123;<br>            <span class="hljs-type">int</span> line,row;<br>            <span class="hljs-type">char</span> seat[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>];<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld %lld %d %d&quot;</span>,&amp;a[i].id,&amp;a[i].dis,&amp;row,&amp;line);<br>            <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">20</span>;j++) <span class="hljs-comment">//清空座位</span><br>            &#123;<br>                <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">20</span>;k++)<br>                &#123;<br>                    seat[j][k]=<span class="hljs-string">&#x27;0&#x27;</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>,<span class="hljs-built_in">getchar</span>();j&lt;row+<span class="hljs-number">1</span>;j++) <span class="hljs-comment">//记录人</span><br>            &#123;<br>                <span class="hljs-keyword">for</span>(k=<span class="hljs-number">1</span>;k&lt;line+<span class="hljs-number">1</span>;k++)<br>                &#123;<br>                    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>,&amp;seat[j][k]);<br>                &#125;<br>                <span class="hljs-built_in">getchar</span>();<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(a[i].flag=<span class="hljs-number">0</span>,j=<span class="hljs-number">1</span>;j&lt;row+<span class="hljs-number">1</span>;j++) <span class="hljs-comment">//判断是否有座位</span><br>            &#123;<br>                <span class="hljs-keyword">for</span>(k=<span class="hljs-number">1</span>;k&lt;line+<span class="hljs-number">1</span>;k++)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(seat[j][k]==<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;seat[j<span class="hljs-number">-1</span>][k]==<span class="hljs-string">&#x27;0&#x27;</span><br>                    &amp;&amp;seat[j][k+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;seat[j][k<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;0&#x27;</span>)<br>                    &#123;<br>                        a[i].flag=<span class="hljs-number">1</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(a[i].flag==<span class="hljs-number">1</span>)<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">qsort</span>(a,n,<span class="hljs-built_in">sizeof</span>(a[<span class="hljs-number">0</span>]),cmp);<br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(a[i].flag==<span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,a[i].id);<br>                cnt=<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Bad Luck,Rocker!\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>EOJ题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EOJ</tag>
      
      <tag>实训</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EOJ 1594. Triangle</title>
    <link href="/EOJ%E9%A2%98%E8%A7%A3/EOJ%201594.%20Triangle/"/>
    <url>/EOJ%E9%A2%98%E8%A7%A3/EOJ%201594.%20Triangle/</url>
    
    <content type="html"><![CDATA[<!--more--><blockquote><p>一道艰难的实训题</p></blockquote><p><strong>单点时限:</strong> 2.0 sec</p><p><strong>内存限制:</strong> 256 MB</p><p>A triangle is a basic shape of planar geometry. It consists of three straight lines and three angles in between. Sides are usually labeled a,b,c, with their opposite angles labeled α,β,γ respectively.</p><p>A look into a book about geometry shows that the following formulas exists:<br /><img src="https://img-blog.csdnimg.cn/20200423194206738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /><br />The values of a,b,c,α,β,γ forms a set of six parameters that fully define a triangle. If a large enough set of parameters are given, the missing ones can be calculated using the formulas above.</p><p>You are to write a program that calculates the missing parameters for a given subset of the six parameters of a triangle. For some sets of parameters, it is not possible to calculate the triangle because either too few is known about the triangle or the parameters would lead to an invalid triangle. The sides of a valid triangle are greater than 0 and the angles are greater than 0 and less than π. Your program should detect this case and output: <mark>Invalid input.</mark> The same phrase should be output if more than the minimal set needed to compute the triangle is given but the parameters conflict with each other, e.g. all three angles are given but their sum is greater than π.</p><p>Other sets of parameters can lead to more than one but still a finite number of valid solutions for the triangle. In such a case, your program should output: “More than one solution.”</p><p>In all other cases, your program should compute the missing parameters and output all six parameters.</p><p><strong>输入格式</strong><br />The first line of the input file contains a number indicating the number of parameter sets to follow. Each following line consists of six numbers, separated by a single blank character. The numbers are the values for the parameters a,α,b,β,c,γ respectively. A value of −1 indicates that the corresponding parameter is undefined and has to be calculated. All floating-point numbers include at least eight significant digits.</p><p><strong>输出格式</strong><br />Your program should output a line for each set of parameters found in the input file. If a unique solution for a valid triangle can be found for the given parameters, your program should output the six parameters a,α,b,β,c,γ separated by a blank character. Otherwise the line should contain the phrase <mark>More than one solution</mark>. or <mark>Invalid input</mark>. as explained above.</p><p>The numbers in the output file should include at least six significant digits. Your calculations should be precise enough to get the six most significant digits correct (i.e. a relative error of 0.000001 is allowed).</p><p><strong>样例</strong></p><table><thead><tr><th style="text-align:left">input</th></tr></thead><tbody><tr><td style="text-align:left">4<br>47.9337906847 0.6543010109 78.44555175791.4813893731 66.5243757656 1.0059022695<br>62.72048064 2.26853639 -1.00000000 0.56794657 -1.00000000 -1.00000000<br>15.69326944 0.24714213 -1.00000000 1.80433105 66.04067877 -1.00000000<br>72.83685175 1.04409241 -1.00000000 -1.00000000 -1.00000000 -1.00000000</td></tr><tr><td style="text-align:left">output</td></tr><tr><td style="text-align:left">47.933791 0.654301 78.445552 1.481389 66.524376 1.005902<br>62.720481 2.268536 44.026687 0.567947 24.587225 0.305110<br>Invalid input.<br>Invalid input.</td></tr></tbody></table><p><strong>解题思路</strong><br />比较棘手的一道题，题意就是通过给出的条件解出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>所代表的元素，初中解三角形的功底要扎实，对各种情况分类讨论。</p><ol><li>无效输入的情况：<br />①  题目所给的数据少于三个，无法得到一个解（计算前判断）<br />② 要素无法构成三角形(judge函数，计算后判断)：<br />1. 仍有未知项（即-1）<br />2. 三个角之和不等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span></span><br />3. 两边之和小于第三边<br />4. 不满足正弦定理</li><li>求解三角形：<br /><img src="https://img-blog.csdnimg.cn/2020042320123839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_16,color_FFFFFF,t_70" alt="" /></li><li>判断解的个数：<br />已知两边和其中一边的对角不能唯一确定三角形，可能出现两解，一解或无解的情况。在本题中使用正弦定理来判断。<br />若已知 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">、</mi><mi>b</mi><mi mathvariant="normal">、</mi><mi>α</mi></mrow><annotation encoding="application/x-tex">a、b、\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord cjk_fallback">、</span><span class="mord mathdefault">b</span><span class="mord cjk_fallback">、</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>，由正弦定理可以得到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>i</mi><mi>n</mi><mi>β</mi><mo>=</mo><mfrac><mrow><mi>b</mi><mi>s</mi><mi>i</mi><mi>n</mi><mi>α</mi></mrow><mi>a</mi></mfrac></mrow><annotation encoding="application/x-tex">sin\beta=\frac{bsin\alpha}{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight" style="margin-right:0.0037em;">α</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>i</mi><mi>n</mi><mi>β</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">sin\beta&gt;1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，无解；若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>i</mi><mi>n</mi><mi>β</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">sin\beta=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，一解；若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>i</mi><mi>n</mi><mi>β</mi><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">sin\beta&lt;1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>两解。在代码中则通过比较 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>s</mi><mi>i</mi><mi>n</mi><mi>α</mi></mrow><annotation encoding="application/x-tex">bsin\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span> 的大小来判断。</li></ol><p><strong>代码思路</strong><br />写代码的时候没有怎么打注释，所以解释一下。<br />由于题目有精度要求，所以宏定义一个小数mask。<br />在输入时指定<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span></span></span></span>来分别储存已知的角和边的个数。<br />首先定义三个函数</p><ol><li>已知三边时调用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>e</mi><mi>t</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">geta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span></span></span></span>函数求角</li><li>已知两边及其夹角时调用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>e</mi><mi>t</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">gete</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span></span></span></span>函数求对边</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">c=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 时调用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mn>2</mn><mi>c</mi></mrow><annotation encoding="application/x-tex">c2c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord">2</span><span class="mord mathdefault">c</span></span></span></span> 函数求第三个角</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">e=3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 时调用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mn>2</mn><mi>c</mi></mrow><annotation encoding="application/x-tex">e2c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mord">2</span><span class="mord mathdefault">c</span></span></span></span> 求所有的角</li></ol><p>之后进入主函数</p><ol><li>读入数据并记录已知元素个数；</li><li>判断元素数量是否满足最低限度；</li><li>仅根据已知边或角的数量来处理：已知两角求第三个角或已知三边求所有角；</li><li>边角情况混合处理：<br />（1）已知一边及其对角<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>α</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a,\alpha)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mclose">)</span></span></span></span>，此时可以解出来的情况有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>β</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(-1,\beta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mclose">)</span></span></span></span>或<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>b</mi><mo separator="true">,</mo><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(b,-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>；<br />①<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>β</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(-1,\beta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mclose">)</span></span></span></span>，用正弦定理求出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>;<br />②<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>b</mi><mo separator="true">,</mo><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(b,-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，此时需要根据 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>i</mi><mi>n</mi><mi>β</mi></mrow><annotation encoding="application/x-tex">sin\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span></span></span></span> 来判断解的情况；<br />（2）已知两边和未知边的对角，直接调用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>e</mi><mi>t</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">gete</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span></span></span></span> 函数解出第三边；</li><li>至此我们好像已经遍历了所有情况，只需要循环至所有元素都被解出来；</li><li>调用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mi>u</mi><mi>d</mi><mi>g</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">judge</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">u</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span></span></span></span> 函数判断元素是否可以组成三角形，判断是否有多解；</li><li>输出。</li></ol><p><strong>ac代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <br><span class="hljs-comment">/* run this program using the console pauser or add your own getch, system(&quot;pause&quot;) or input loop */</span><br><span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">double</span> pi=<span class="hljs-number">4</span>*<span class="hljs-built_in">atan</span>(<span class="hljs-number">1</span>);<br><span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">double</span> mask=<span class="hljs-number">1e-6</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">double</span> a[<span class="hljs-number">6</span>];<br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">double</span> <span class="hljs-title">geta</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">double</span> a,<span class="hljs-type">long</span> <span class="hljs-type">double</span> b,<span class="hljs-type">long</span> <span class="hljs-type">double</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">acos</span>((a*a+b*b-c*c)/(<span class="hljs-number">2</span>*a*b));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">double</span> <span class="hljs-title">gete</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">double</span> x,<span class="hljs-type">long</span> <span class="hljs-type">double</span> y,<span class="hljs-type">long</span> <span class="hljs-type">double</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(x*x+y*y<span class="hljs-number">-2</span>*x*y*<span class="hljs-built_in">cos</span>(c));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">c2c</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">long</span> <span class="hljs-type">double</span> t=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">6</span>;i+=<span class="hljs-number">2</span>)<br>&#123;<br><span class="hljs-keyword">if</span>(a[i]&lt;<span class="hljs-number">0</span>)<br><span class="hljs-keyword">continue</span>;<br>t+=a[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">6</span>;i+=<span class="hljs-number">2</span>)<br><span class="hljs-keyword">if</span>(a[i]&lt;<span class="hljs-number">0</span>)<br>a[i]=pi-t;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">e2c</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">6</span>;i+=<span class="hljs-number">2</span>)<br><span class="hljs-keyword">if</span>(a[i]&lt;<span class="hljs-number">0</span>)<br>a[i]=<span class="hljs-built_in">geta</span>(a[(i+<span class="hljs-number">1</span>)%<span class="hljs-number">6</span>],a[(i+<span class="hljs-number">3</span>)%<span class="hljs-number">6</span>],a[i<span class="hljs-number">-1</span>]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)<br><span class="hljs-keyword">if</span>(a[i]&lt;<span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(a[<span class="hljs-number">1</span>]+a[<span class="hljs-number">3</span>]+a[<span class="hljs-number">5</span>]-pi)&gt;mask)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>]+a[<span class="hljs-number">2</span>]&lt;=a[<span class="hljs-number">4</span>]||a[<span class="hljs-number">2</span>]+a[<span class="hljs-number">4</span>]&lt;=a[<span class="hljs-number">0</span>]||a[<span class="hljs-number">0</span>]+a[<span class="hljs-number">4</span>]&lt;=a[<span class="hljs-number">2</span>])<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i += <span class="hljs-number">2</span>) <br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(a[i]*<span class="hljs-built_in">sin</span>(a[i+<span class="hljs-number">3</span>])-<span class="hljs-built_in">sin</span>(a[i+<span class="hljs-number">1</span>])*a[i+<span class="hljs-number">2</span>])&gt;mask)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> T;<br>cin &gt;&gt; T;<br><span class="hljs-keyword">while</span>(T--)<br>&#123;<br><span class="hljs-type">int</span> n=<span class="hljs-number">0</span>,c=<span class="hljs-number">0</span>,e=<span class="hljs-number">0</span>;<br><span class="hljs-type">bool</span> flag=<span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)<br>&#123;<br>cin &gt;&gt; a[i];<br><span class="hljs-keyword">if</span>(a[i]&gt;<span class="hljs-number">0</span>)<br>&#123;<br>n++;<br><span class="hljs-keyword">if</span>(i&amp;<span class="hljs-number">1</span>) c++;<br><span class="hljs-keyword">else</span> e++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">3</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Invalid input.&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">while</span>(n&lt;<span class="hljs-number">6</span>)<br>&#123;<br><span class="hljs-type">int</span> s=n;<br><span class="hljs-keyword">if</span>(c==<span class="hljs-number">2</span>)<br>&#123;<br><span class="hljs-built_in">c2c</span>();<br>n++;<br>c=<span class="hljs-number">3</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(e==<span class="hljs-number">3</span>)<br>&#123;<br><span class="hljs-built_in">e2c</span>();<br>n+=<span class="hljs-number">3</span>-c;<br>c=<span class="hljs-number">3</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i+=<span class="hljs-number">2</span>)<br>&#123;<br><span class="hljs-keyword">if</span>(a[i]&gt;<span class="hljs-number">0</span>&amp;&amp;a[i+<span class="hljs-number">1</span>]&gt;<span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">6</span>;j+=<span class="hljs-number">2</span>)<br>&#123;<br><span class="hljs-keyword">if</span>((a[j]&gt;<span class="hljs-number">0</span>&amp;&amp;a[j+<span class="hljs-number">1</span>]&gt;<span class="hljs-number">0</span>)||(a[j]&lt;<span class="hljs-number">0</span>&amp;&amp;a[j+<span class="hljs-number">1</span>]&lt;<span class="hljs-number">0</span>))<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span>(a[j]&lt;<span class="hljs-number">0</span>)<br>&#123;<br>a[j]=a[i]/<span class="hljs-built_in">sin</span>(a[i+<span class="hljs-number">1</span>])*<span class="hljs-built_in">sin</span>(a[j+<span class="hljs-number">1</span>]);<br>n++;<br>e++;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span>(a[i+<span class="hljs-number">1</span>]&lt;pi/<span class="hljs-number">2</span>&amp;&amp;a[i]&lt;a[j]&amp;&amp;a[i]&gt;a[j]*<span class="hljs-built_in">sin</span>(a[i+<span class="hljs-number">1</span>]))<br>flag=<span class="hljs-literal">true</span>;<br><span class="hljs-type">double</span> temp=<span class="hljs-built_in">sin</span>(a[i+<span class="hljs-number">1</span>])*a[j]/a[i];<br><span class="hljs-keyword">if</span>(temp&gt;<span class="hljs-number">1</span>||temp&lt;<span class="hljs-number">0</span>)<br><span class="hljs-keyword">continue</span>;<br>a[j+<span class="hljs-number">1</span>]=<span class="hljs-built_in">asin</span>(<span class="hljs-built_in">sin</span>(a[i+<span class="hljs-number">1</span>])*a[j]/a[i]);<br>n++;<br>c++;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(e==<span class="hljs-number">2</span>)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i+=<span class="hljs-number">2</span>)<br>&#123;<br><span class="hljs-keyword">if</span>(a[i]&lt;<span class="hljs-number">0</span>&amp;&amp;a[i+<span class="hljs-number">1</span>]&gt;<span class="hljs-number">0</span>)<br>&#123;<br>a[i]=<span class="hljs-built_in">gete</span>(a[(i+<span class="hljs-number">2</span>)%<span class="hljs-number">6</span>],a[(i+<span class="hljs-number">4</span>)%<span class="hljs-number">6</span>],a[i + <span class="hljs-number">1</span>]);<br>n++;<br>e++;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(s==n)<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>())<br>&#123;<br><span class="hljs-keyword">if</span>(flag)<br>cout &lt;&lt; <span class="hljs-string">&quot;More than one solution.&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)<br>cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">6</span>) &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">6</span>) &lt;&lt; a[<span class="hljs-number">5</span>] &lt;&lt; endl;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>cout &lt;&lt; <span class="hljs-string">&quot;Invalid input.&quot;</span> &lt;&lt; endl;<br> &#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>补充</strong><br />有位带哥提醒我 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span></span> 可以用M_PI表示，更方便些</p>]]></content>
    
    
    <categories>
      
      <category>EOJ题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EOJ</tag>
      
      <tag>实训</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EOJ 205. 数列项</title>
    <link href="/EOJ%E9%A2%98%E8%A7%A3/EOJ%20205.%20%E6%95%B0%E5%88%97%E9%A1%B9/"/>
    <url>/EOJ%E9%A2%98%E8%A7%A3/EOJ%20205.%20%E6%95%B0%E5%88%97%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<!--more--><p><strong>单点时限:</strong> 2.0 sec</p><p><strong>内存限制:</strong> 256 MB</p><p>非负数列项的第1项为0，第2项为1，后面的每项为其前面的 k(2≤k≤10) 项之和（若不存在前面的某个项，计算时以0表示）。<br />例如： k=3, 则数列项依次为：0,1,1（因前面的项不足3项，计算时以(0)表示，1+0+(0)=1）,2,4,……</p><p><strong>输入格式</strong><br />一行由一个空格分隔的正整数 k 和 n。</p><p>80%的数据点: 2≤k≤3,1≤n≤10</p><p>10%的数据点: 2≤k≤5,1≤n≤50</p><p>10%的数据点: 2≤k≤10,1≤n≤100</p><p><strong>输出格式</strong><br />在一行中输出数列的第n项。</p><p><strong>样例</strong></p><table><thead><tr><th style="text-align:left">input</th></tr></thead><tbody><tr><td style="text-align:left">2 1</td></tr><tr><td style="text-align:left">output</td></tr><tr><td style="text-align:left">0</td></tr></tbody></table><table><thead><tr><th style="text-align:left">input</th></tr></thead><tbody><tr><td style="text-align:left">4 6</td></tr><tr><td style="text-align:left">output</td></tr><tr><td style="text-align:left">8</td></tr></tbody></table><table><thead><tr><th style="text-align:left">input</th></tr></thead><tbody><tr><td style="text-align:left">3 4</td></tr><tr><td style="text-align:left">output</td></tr><tr><td style="text-align:left">2</td></tr></tbody></table><p><strong>思路</strong><br />一道大数运算题<br />因为每个数都是前k个数的和并且后面的数一定大于前面的数，所以只需要申请一个k行的二维数组来存放数据。<br />如果n小于2则直接输出。<br />通过对下标取模定位到数字所在行，将该行更新为k个数字之和。也就是说对于第i个数的第j位而言，它的数码是所有行的第j位的和再模10。直到把这一行处理完，即新的数字替换了旧的数字。简单说就是模拟一个k个数的竖式加法计算。处理了n-2次（0行和1行初始化为0和1）后退出循环，将目标行从后往前输出即可（去掉前置0）。</p><p><strong>ac代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/* run this program using the console pauser or add your own getch, system(&quot;pause&quot;) or input loop */</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> k,n;<br>cin &gt;&gt; k &gt;&gt; n;<br><span class="hljs-type">int</span> res[k][<span class="hljs-number">100</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">100</span>;j++)<br>res[i][j]=<span class="hljs-number">0</span>;<br>&#125;<br>res[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>) cout &lt;&lt; <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n==<span class="hljs-number">2</span>) cout &lt;&lt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;n;i++)<br>&#123;<br><span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>,carry=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">100</span>;j++)<br>&#123;<br>sum=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> m=<span class="hljs-number">0</span>;m&lt;k;m++)<br>sum+=res[m][j];<br>sum+=carry;<br>res[i%k][j]=sum%<span class="hljs-number">10</span>;<br>carry=sum/<span class="hljs-number">10</span>;<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> flag;<br><span class="hljs-keyword">for</span>(flag=<span class="hljs-number">99</span>;res[(n<span class="hljs-number">-1</span>)%k][flag]==<span class="hljs-number">0</span>;flag--) ;<br><span class="hljs-keyword">for</span>(;flag&gt;=<span class="hljs-number">0</span>;flag--)<br>cout &lt;&lt; res[(n<span class="hljs-number">-1</span>)%k][flag];<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>EOJ题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EOJ</tag>
      
      <tag>实训</tag>
      
      <tag>大数运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EOJ 97. 邮件地址排序</title>
    <link href="/EOJ%E9%A2%98%E8%A7%A3/EOJ%2097.%20%E9%82%AE%E4%BB%B6%E5%9C%B0%E5%9D%80%E6%8E%92%E5%BA%8F/"/>
    <url>/EOJ%E9%A2%98%E8%A7%A3/EOJ%2097.%20%E9%82%AE%E4%BB%B6%E5%9C%B0%E5%9D%80%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<!--more--><p><strong><strong>单点时限</strong>:</strong> 2.0 sec<br /><strong><strong>内存限制</strong>:</strong> 256 MB</p><p>现接收到一大批电子邮件，邮件地址格式为：用户名@主机域名，要求把这些电子邮件地址做主机域名的字典序升序排序，如果主机域名相同，则做用户名的字典序降序排序。</p><p><strong>输入格式</strong><br />第一行输入一个正整数 n，表示共有 n 个电子邮件地址需要排序。<br />接下来 n 行，每行输入一个电子邮件地址（保证所有电子邮件地址的长度总和不超过 10^6）。</p><p><strong>·</strong> 对于 50% 的数据，保证 n⩽100,|si|⩽100。</p><p>用户名只包含字母数字和下划线，主机域名只包含字母数字和点。</p><p><strong>输出格式</strong><br />按排序后的结果输出 n 行，每行一个电子邮件地址。</p><p><strong>样例</strong></p><table><thead><tr><th style="text-align:left"><strong>input</strong></th></tr></thead><tbody><tr><td style="text-align:left">8 <br><a href="mailto:23485@qq.com">23485@qq.com</a><br><a href="mailto:rieruer@163.com">rieruer@163.com</a><br><a href="mailto:39489384@qq.com">39489384@qq.com</a><br><a href="mailto:eruie@ecnu.edu.cn">eruie@ecnu.edu.cn</a><br><a href="mailto:rtff@163.com">rtff@163.com</a><br><a href="mailto:84934804@qq.com">84934804@qq.com</a><br><a href="mailto:fdll@ecnu.edu.cn">fdll@ecnu.edu.cn</a><br><a href="mailto:598695@qq.com">598695@qq.com</a></td></tr><tr><td style="text-align:left"><strong>output</strong></td></tr><tr><td style="text-align:left"><a href="mailto:rtff@163.com">rtff@163.com</a><br><a href="mailto:rieruer@163.com">rieruer@163.com</a><br><a href="mailto:fdll@ecnu.edu.cn">fdll@ecnu.edu.cn</a><br><a href="mailto:eruie@ecnu.edu.cn">eruie@ecnu.edu.cn</a><br><a href="mailto:84934804@qq.com">84934804@qq.com</a><br><a href="mailto:598695@qq.com">598695@qq.com</a><br><a href="mailto:39489384@qq.com">39489384@qq.com</a><br><a href="mailto:23485@qq.com">23485@qq.com</a></td></tr></tbody></table><p><strong>思路</strong><br />就是中规中矩普普通通的排序题，唯一的难点就是数据量，最多的样例输入的数据量好像是三十万。<br />是刚接触编程写的题目，那时候只学了C语言，感觉没法写，感觉很苦恼，不过看了一些动态内存分配，还是磕磕绊绊写完了，现在看来还是有点价值的。<br />用结构体分开存两部分，然后用qsort函数排序。</p><p><strong>ac代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Address</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span>* user, *main;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *a,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *b)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Address</span> <span class="hljs-title">x</span>,<span class="hljs-title">y</span>;</span><br>    x=*((<span class="hljs-keyword">struct</span> Address *)a);<br>    y=*((<span class="hljs-keyword">struct</span> Address *)b);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(x.main,y.main)==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(y.user,x.user);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(x.main,y.main);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> n,count=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;n);<br>    getchar();<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Address</span> *<span class="hljs-title">ip</span>=</span><span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span>(count&lt;n)<br>    &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> counts=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">char</span> ch;<br>        <span class="hljs-type">char</span>* temp=<span class="hljs-literal">NULL</span>;<br>        <span class="hljs-type">char</span>* tempuser=<span class="hljs-literal">NULL</span>;<br>        <span class="hljs-type">char</span>* tempmain=<span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">do</span><br>        &#123;<br>            ch=getchar();<br>            counts++;<br>            temp=(<span class="hljs-type">char</span>*)<span class="hljs-built_in">realloc</span>(temp, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>)*(counts+<span class="hljs-number">1</span>));<br>            temp[counts<span class="hljs-number">-1</span>]=ch;<br>        &#125;<span class="hljs-keyword">while</span>(ch!=<span class="hljs-string">&#x27;\n&#x27;</span>);<br>        temp[counts]=<span class="hljs-string">&#x27;\0&#x27;</span>;<br>        count++;<br>        ip=(<span class="hljs-keyword">struct</span> Address *)<span class="hljs-built_in">realloc</span>(ip,n*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Address));<br>        ip[count<span class="hljs-number">-1</span>].user=<span class="hljs-literal">NULL</span>;<br>        ip[count<span class="hljs-number">-1</span>].main=<span class="hljs-literal">NULL</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> i,j,len=<span class="hljs-built_in">strlen</span>(temp);<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;temp[i]!=<span class="hljs-string">&#x27;@&#x27;</span>;i++)<br>        &#123;<br>            tempuser=(<span class="hljs-type">char</span> *)<span class="hljs-built_in">realloc</span>(tempuser,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>)*(i+<span class="hljs-number">1</span>));<br>            tempuser[i]=temp[i];<br>        &#125;<br>        tempuser=(<span class="hljs-type">char</span> *)<span class="hljs-built_in">realloc</span>(tempuser,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>)*(i+<span class="hljs-number">2</span>));<br>        tempuser[i]=<span class="hljs-string">&#x27;\0&#x27;</span>;<br>        i++;<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;i&lt;len;i++,j++)<br>        &#123;<br>            tempmain=(<span class="hljs-type">char</span> *)<span class="hljs-built_in">realloc</span>(tempmain,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>)*(j+<span class="hljs-number">1</span>));<br>            tempmain[j]=temp[i];<br>        &#125;<br>        tempmain=(<span class="hljs-type">char</span> *)<span class="hljs-built_in">realloc</span>(tempmain,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>)*(j+<span class="hljs-number">2</span>));<br>        tempmain[j]=<span class="hljs-string">&#x27;\0&#x27;</span>;<br>        ip[count<span class="hljs-number">-1</span>].user=(<span class="hljs-type">char</span> *)<span class="hljs-built_in">realloc</span>(ip[count<span class="hljs-number">-1</span>].user,<br>                         <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>)*(<span class="hljs-built_in">strlen</span>(tempuser) + <span class="hljs-number">1</span>));<br>        ip[count<span class="hljs-number">-1</span>].main=(<span class="hljs-type">char</span> *)<span class="hljs-built_in">realloc</span>(ip[count<span class="hljs-number">-1</span>].main,<br>                         <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>)*(<span class="hljs-built_in">strlen</span>(tempmain) + <span class="hljs-number">1</span>));<br>        <span class="hljs-built_in">strcpy</span>(ip[count<span class="hljs-number">-1</span>].user,tempuser);<br>        <span class="hljs-built_in">strcpy</span>(ip[count<span class="hljs-number">-1</span>].main,tempmain);<br>        <span class="hljs-built_in">free</span>(tempuser);<br>        <span class="hljs-built_in">free</span>(tempmain);<br>        <span class="hljs-built_in">free</span>(temp);<br>    &#125;<br>    qsort(ip,n,<span class="hljs-keyword">sizeof</span>(ip[<span class="hljs-number">0</span>]),cmp);<br>    <span class="hljs-type">int</span> j;<br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s@%s&quot;</span>,ip[j].user,ip[j].main);<br>    &#125;<br>    <span class="hljs-built_in">free</span>(ip);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>EOJ题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EOJ</tag>
      
      <tag>实训</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EOJ 3744. 与矩阵</title>
    <link href="/EOJ%E9%A2%98%E8%A7%A3/EOJ%203744.%20%E4%B8%8E%E7%9F%A9%E9%98%B5/"/>
    <url>/EOJ%E9%A2%98%E8%A7%A3/EOJ%203744.%20%E4%B8%8E%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<!--more--><blockquote><p>第一次遇见这题是在三月的月赛，当时摸了没做出来，之后才琢磨出来的，确实挺菜的。</p></blockquote><p>题面：</p><p><strong>单点时限</strong>: 1.0 sec</p><p><strong>内存限制</strong>: 512 MB</p><p>前有牛顿瘟疫“家里蹲”发明微积分。</p><p>现有 Cuber QQ 新冠肺炎“家里蹲”发明与矩阵。</p><p>与矩阵是一个 n×n 的矩阵。规定矩阵中的第 i 行第 j 列记为 (i,j) 。</p><p>生成一个与矩阵的方式是，先生成一个长度为 n 的数列 a1,a2,…,an−1,an ，而矩阵中 (i,j)=ai&amp;aj 。</p><p>其中 &amp; 是指按位与运算，其计算方式是参与运算的两数各对应的二进位相与。只有对应的两个二进位都为 1 时，结果位才为 1 。</p><p>Cuber QQ 发现，同一个与矩阵可能对应着一些不同的数列，不过 Cuber QQ 现在只想知道字典序最小的数列是什么样的。</p><p>对于两个数列 a1,a2,…,an−1,an 和 b1,b2,…,bn−1,bn ，如果存在一个整数 k (1≤k≤n) 满足 ak+1 &lt; bk+1 且 a1=b1,a2=b2,…,ak=bk ，我们就认为数列 a1,a2,…,an−1,an 的字典序要小于数列 b1,b2,…,bn−1,bn 。</p><p>当然，Cuber QQ 不会这么容易让你得到答案，他会把矩阵所有的 (i,i) (1≤i≤n) 的位置全部隐藏，只显示为 0 。</p><p><strong>输入格式</strong><br />第一行输入一个整数 n (1≤n≤1000) ，表示矩阵的大小。</p><p>接下来的 n 行，每行 n 个用空格隔开的整数 ai,1,ai,2,…,ai,n (0≤ai,j≤107) ，表示与矩阵。</p><p>输入保证至少存在一个可能的解。</p><p><strong>输出格式</strong><br />输出包含一行 n 个用空格隔开的数，表示字典序最小的数列。</p><table><thead><tr><th style="text-align:left"><strong>input</strong></th></tr></thead><tbody><tr><td style="text-align:left">3 <br>0 0 1 <br>0 0 2 <br>1 2 3</td></tr><tr><td style="text-align:left"><strong>output</strong></td></tr><tr><td style="text-align:left">1 2 3</td></tr></tbody></table><p><strong>提示</strong><br />样例中给出的数列为 1,2,3 。</p><p><strong>思路</strong><br />用bitset数组a将数列里的每个数按位储存，将其初始化为0。<br />对角线元素被隐藏了，不去管它。<br />扫描整个矩阵，因为它是‘与’矩阵，所以当扫描到非零元素（i,j）时，把它的每一位按位存进a[i],a[j]。<br />扫描完（i,j）和（j,i）后就可以得到对应的a[i],a[j]。<br />最后把数组转换成unsigned long 输出即可。</p><p><strong>ac代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bitset&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>bitset&lt;32&gt; a[<span class="hljs-number">1002</span>];<br><span class="hljs-comment">/* run this program using the console pauser or add your own getch, system(&quot;pause&quot;) or input loop */</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-type">long</span> <span class="hljs-type">int</span> num[n][n];<br><span class="hljs-type">int</span> i,j,k;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>cin &gt;&gt; num[i][j];<br><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">1001</span>;i++) a[i].<span class="hljs-built_in">reset</span>();<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>&#123;<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>&#123;<br><span class="hljs-keyword">if</span>(num[i][j]!=<span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-type">long</span> <span class="hljs-type">int</span> c=num[i][j];<br><span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">32</span>;k++)<br>&#123;<br><span class="hljs-keyword">if</span>((c&gt;&gt;k)&amp;<span class="hljs-number">1</span>)<br>&#123;<br>a[i][k]=<span class="hljs-number">1</span>;<br>a[j][k]=<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>cout &lt;&lt; a[i].<span class="hljs-built_in">to_ulong</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>EOJ题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EOJ 1627. Binary Code</title>
    <link href="/EOJ%E9%A2%98%E8%A7%A3/EOJ%201627.%20Binary%20Code/"/>
    <url>/EOJ%E9%A2%98%E8%A7%A3/EOJ%201627.%20Binary%20Code/</url>
    
    <content type="html"><![CDATA[<!--more--><p>题面：</p><p><strong>单点时限</strong>: 2.0 sec<br /><strong>内存限制</strong>: 256 MB</p><p>考虑一个 N 位的二进制串 b1…bN，其对应的二进制矩阵为：<br /><img src="https://img-blog.csdnimg.cn/20200418185946497.png" alt="" /><br />然后将这个矩阵的行按照字典顺序排序，‘0’ 在 ‘1’ 之前。</p><p>你的任务是<strong>编写一个程序，给定排序后的矩阵的最后一列，求出已排序的矩阵的第一行。</strong></p><p>例如：考虑二进制串（00110），排序后的矩阵为：</p><p>0 0 0 1 1</p><p>0 0 1 1 0</p><p>0 1 1 0 0</p><p>1 0 0 0 1</p><p>1 1 0 0 0</p><p>则该矩阵的最后一列为（1 0 0 1 0）。给出了这一列，你的程序应该确定第一行为（0 0 0 1 1）。</p><p><strong>输入格式</strong><br />输入第一行包含一个整数 N(0&lt;=20000)，表示二进制串的位数。第二行包含 N 个整数，表示已排序的矩阵的最后一列（从上到下）。</p><p><strong>输出格式</strong><br />输出文件仅一行，包含 N 个整数，从左到右依次表示已排序的矩阵的第一行；若无解，则输出-1。</p><p><strong>样例</strong></p><table><thead><tr><th style="text-align:left"><strong>input</strong></th></tr></thead><tbody><tr><td style="text-align:left">5 <br> 1 0 0 1 0</td></tr><tr><td style="text-align:left"><strong>output</strong></td></tr><tr><td style="text-align:left">0 0 0 1 1</td></tr></tbody></table><p><strong>思路</strong><br />首先我们可以明确一点，在这个矩阵里每一列的0和1的个数相同。<br />给出的数据是排序好的矩阵的最后一列，所以我们可以得出将所有行数据右移一位之后各行数据所对应的新位置。</p><p>以题目给的样例来说，每一列共有3个0和2个1，所以前三行的第一位必然是0，后两行第一位是1，右移后的新顺序即为0、1的顺序。</p><p>第一行左移后就会变成第二行（<strong>第1个0出现的行</strong>），以此类推，第二行变第三行，第三行变第五行，第四行变第一行，第五行变第四行，因为这是左移后得到的顺序，所以原顺序的最后一个元素即为新顺序的倒数第二个元素。</p><p>画个简图：<br /><img src="https://img-blog.csdnimg.cn/2020041819312055.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_1,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDAxMTU2,size_2,color_FFFFFF,t_4" alt="" /><br />所以，我们只需要用两个数组储存原顺序和新顺序，然后一步步往前推，最后输出第一行即可。</p><p><strong>ac代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/* run this program using the console pauser or add your own getch, system(&quot;pause&quot;) or input loop */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxn 20001</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> zero,one,total,n,cnt=<span class="hljs-number">0</span>;<br><span class="hljs-type">char</span> input[maxn],*p;<br><span class="hljs-type">int</span> temp[maxn],next[maxn];<br>cin &gt;&gt; n;<br>cin.<span class="hljs-built_in">get</span>();<br>p=input;<br>zero=one=total=<span class="hljs-number">0</span>;<br><span class="hljs-type">char</span> ch;<br><span class="hljs-keyword">while</span>(cin.<span class="hljs-built_in">get</span>(ch))<br>&#123;<br><span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;0&#x27;</span>||ch==<span class="hljs-string">&#x27;1&#x27;</span>)<br>&#123;<br>*p=ch;<br>p++;<br>&#125;<br>&#125;<br>p=input;<br><span class="hljs-keyword">while</span>(*p)<br>&#123;<br><span class="hljs-keyword">if</span>(*p==<span class="hljs-string">&#x27;0&#x27;</span>)<br>&#123;<br>next[zero++]=total;<br>cnt++;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(*p==<span class="hljs-string">&#x27;1&#x27;</span>)<br>temp[one++]=total;<br>total++;<br>p++;<br>&#125;<br><span class="hljs-type">int</span> i,j;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;one;i++)<br>&#123;<br>next[zero++]=temp[i];<br>&#125;<br><span class="hljs-type">char</span> output[maxn];<br><span class="hljs-keyword">for</span>(i=j=<span class="hljs-number">0</span>;i&lt;total;i++)<br>&#123;<br>output[i]=input[next[j]];<br>j=next[j];<br><span class="hljs-keyword">if</span>(output[i]==<span class="hljs-string">&#x27;0&#x27;</span>)<br>cnt--;<br>&#125;<br><span class="hljs-keyword">if</span>(cnt)<br>&#123;<br>cout &lt;&lt; <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;total;i++)<br>&#123;<br>cout &lt;&lt; output[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>EOJ题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EOJ</tag>
      
      <tag>实训</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
